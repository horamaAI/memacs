# -*- mode: org -*-
#+TITLE: my emacs init file configs but in orgmode
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+LANGUAGE: en
#+OPTIONS: toc:3 timestamp:t
#+DESCRIPTION: My org-mode configs and descriptions (got most of them from Bernt Hansen (http://doc.norang.ca/org-mode.html))
#+KEYWORDS:  org-mode Emacs organization GTD getting-things-done git

#+begin_comment
;; following is another way of generating .el files from .org
;; here used 'org-babel-load-file' instead
;; #+PROPERTY: header-args :tangle ./emacs_init_configs.el
#+end_comment

* Preliminaries
  + main sources ::
    - http://www.newartisans.com/2007/08/using-org-mode-as-a-day-planner/
    - http://doc.norang.ca/org-mode.html
  + packages ::
    - melpa ::
      + elisp entries ::
        #+header: :tangle yes
        #+begin_src emacs-lisp
        (require 'package)
        (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
        ;; Comment/uncomment this line to enable MELPA Stable if desired.  See `package-archive-priorities`
        ;; and `package-pinned-packages`. Most users will not need or want to do this.
        ;;(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
        (package-initialize)
        ;; 'use-package' to ease further installations of packages
        (unless (package-installed-p 'use-package)
        (package-refresh-contents)
        (package-install 'use-package))

        #+end_src
      + some commands ::
        - refresh melpa list before installing :: ~M-x package-refresh-contents~ or ~M-x package-list-packages~
        - install package :: ~M-x package-install~
    - projectile :: for project management
      + entries ::
        #+header: :tangle yes
        #+begin_src emacs-lisp
        ;; use projectile for project management
        (use-package projectile
          :diminish projectile-mode
          :config (projectile-mode)
          :custom ((projectile-completion-system 'ivy))
          :bind-keymap
          ("C-c p" . projectile-command-map)
          :init
          ;; default projects home
          (when (file-directory-p "~/Documents/repos/")
            (setq projectile-project-search-path '("~/Documents/repos/")))
          ;; first thing to do when switching project: load up 'dired' which list files in project
          (setq projectile-switch-project-action #'projectile-dired)
          (projectile-mode +1))
        #+end_src
    - eglot :: as a c++ IDE
      + entries ::
        #+header: :tangle yes
        #+begin_src emacs-lisp
        ;; for c++ IDE
        (require 'eglot)
        (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd")) ;; c++ language server clangd 
        (add-hook 'c-mode-hook 'eglot-ensure)
        (add-hook 'c++-mode-hook 'eglot-ensure)
        #+end_src
  + themes ::
    - modus-vivendi ::
      + entries ::
        #+header: :tangle yes
        #+begin_src emacs-lisp
        ;; add directories/files to load-path so the files/directories can be found and used
        ; here, folder for themes to use for example
        ; expand-file-name to convert relative path to absolute
        (add-to-list 'load-path (expand-file-name "~/.emacs.d/themes/"))

        ;; clone it first: git clone https://gitlab.com/protesilaos/modus-themes.git ~/.emacs.d/themes/modus-themes
        (add-to-list 'load-path "~/.emacs.d/themes/modus-themes")
        (require 'modus-themes)
        ;; Load the theme files before enabling a theme (else you get an error).
        ;; (modus-themes-load-themes)
        ;; (load-theme 'modus-operandi) ; light theme
        ;; (load-theme 'modus-vivendi) ; dark theme
        (modus-themes-load-theme 'modus-operandi-tinted) ; 'tinted' is the slightly tone down counterpart of standard themes operandi and vivendi
        ;; (modus-themes-load-theme 'modus-vivendi-tinted) ;
        #+end_src

    - other themes ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ;;;; load darcula theme not dracula
      ;;(use-package darcula-theme
      ;;  :ensure t
      ;;  :config(load-theme 'darcula t))
      
      ;; choose light version of timu-spacegrey
      ;; (load-theme 'timu-spacegrey t)
      ;; (setq timu-spacegrey-flavour "light")
      #+end_src
  + memacs folder ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq partial-memacs "~/Documents/repos/org/memacs/")
    (setq memacs (expand-file-name partial-memacs))
    #+end_src
  + emacs startup options ::
    - open main agenda file :: 'tasks_list.org'
    - open emacs manual :: ~(info-emacs-manual) ;; C-h r~ (first, install 'emacs-common-non-dfsg' on your OS)
    - entries ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ;; open file on start
      (find-file (file-name-concat memacs "GTD/tasks_list.org"))
      (info-emacs-manual) ;; C-h r
      #+end_src
  + other customizations ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Note: some configs are managed by emacs, so order my change after evaluation
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; allow open recent file
    (recentf-mode 1)
    (setq recentf-max-menu-items 25)
    (setq recentf-max-saved-items 25)
    (global-set-key "\C-x\ \C-r" 'recentf-open-files)

    ;; line wrap on buffer visualisation (won't affect the actual buffer, just the display of the buffer)
    (global-visual-line-mode t)

    ;; always display line numbers
    (global-display-line-numbers-mode)

    ;; show line fill column globally (note that it doesn't break automatically, just display the fill-column)
    (global-display-fill-column-indicator-mode)

    ;; set company-mode (autocomplete) on all buffers
    (add-hook 'after-init-hook 'global-company-mode)

    ;; get matching parentheses and other characters
    (show-paren-mode +1)
    #+end_src
* My organization of org files tree (details in [[file:organisation_org_files.org][organisation_org_files.org]])
#+INCLUDE: "./organisation_org_files.org::Folders and files:"

* Org mode configs
- notes ::
  + different sources, but mainly, detailed templates are from :
    - http://doc.norang.ca/org-mode.html
    - http://www.newartisans.com/2007/08/using-org-mode-as-a-day-planner/
  + careful, some configs are managed by emacs, so the order my change
  + make emacs faster by adding it to OS startup in background ::
    - linux (debian) ::
      + sources ::
	- https://wikemacs.org/wiki/Emacs_server
	- https://wiki.debian.org/systemd
  + better for all first level task to have a =property drawer= specifying the category ::
    #+begin_src org :exports src
    example for use of categories
    * Health and Recreation
      :PROPERTIES:
      :CATEGORY: Health
      :END:
      ...
    * House Maintenance
      :PROPERTIES:
      :CATEGORY: House
      :END:
    #+end_src
- basic org mode settings ::
  #+header: :tangle yes
  #+begin_src emacs-lisp
  ;; set which extensions will use orgmode: .org, .org_archive, and .txt
  (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
  
  ;; 'mode-specific-map' : for events that follow C-c prefix key
  (define-key mode-specific-map [?a] 'org-agenda)
    
  ;; 'Ido' activation (interactive use of buffers and files)
  (require 'ido)
  (ido-mode t)
  
  ;; org-agenda-files: to add folders containing files contributing to the agenda
  ; GTD-private: contains contributing agenda files that should not be shared publicly
  (setq org-agenda-files (list (file-name-concat memacs "GTD") (file-name-concat memacs "GTD-private")))
  
  ;; Disable keys in org-mode
  ;;    C-c [ 
  ;;    C-c ]
  ;;    C-c ;
  ;;    C-c C-x C-q  cancelling the clock (we never want this)
  (add-hook 'org-mode-hook
            '(lambda ()
               ;; Undefine C-c [ and C-c ] since this breaks my
               ;; org-agenda files when directories are include It
               ;; expands the files in the directories individually
               (org-defkey org-mode-map "\C-c[" 'undefined) ;; deactivate automatic, instead do manually addition to 'org-agenda-files' since is better than the automatic version that could mess up previous configurations of list of directories used for the files contributing to the agenda
               (org-defkey org-mode-map "\C-c]" 'undefined)
               (org-defkey org-mode-map "\C-c;" 'undefined) ;; is it really necessary ? how much do I accidentally hit the comment function ?
               (org-defkey org-mode-map "\C-c\C-x\C-q" 'undefined))
            'append)
  
  ;; activate evaluation of PlantUML source code blocks by adding plantuml to org-babel-load-languages. 
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((plantuml . t))) ; this line activates plantuml
  
  #+end_src
- bh's diverse set of tool functions definitions ::
  #+header: :tangle yes
  #+begin_src emacs-lisp
  (defun bh/hide-other ()
    (interactive)
    (save-excursion
      (org-back-to-heading 'invisible-ok)
      (hide-other)
      (org-cycle)
      (org-cycle)
      (org-cycle)))
  
  (defun bh/set-truncate-lines ()
    "Toggle value of truncate-lines and refresh window display."
    (interactive)
    (setq truncate-lines (not truncate-lines))
    ;; now refresh window display (an idiom from simple.el):
    (save-excursion
      (set-window-start (selected-window)
                        (window-start (selected-window)))))
  
  (defun bh/make-org-scratch ()
    (interactive)
    (find-file "/tmp/publish/scratch.org")
    (gnus-make-directory "/tmp/publish"))
  
  (defun bh/switch-to-scratch ()
    (interactive)
    (switch-to-buffer "*scratch*"))  
  #+end_src
** Org Mode TODO states, triggers, and project definition
:PROPERTIES:
:CUSTOM_ID: TodoKeywords
:END:
- basic settings for project management task actions ::
  #+header: :tangle yes
  #+begin_src emacs-lisp
  ;; action tasks status
  ;; vertical bar (|) used to separate TODO keywords (states that need action) from other states in the sequence (eg: DONE state, needs no further action)
  ;; If not provided, the last state is used as DONE state.
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))
  
  ;; customize design of trigger states
  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "royal blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))
  #+end_src

- fast Todo Selection ::
  + allows changing from any todo task state to any other state directly by selecting the appropriate key from the fast todo selection key menu.
    #+header: :tangle yes
    #+begin_src emacs-lisp
    
    ;; allow for faster task state change, using shortcut defined in 'org-todo-keywords'
    ;; can then change state by simply typing C-c C-t, ex: C-c C-t n to change to 'next' state, assuming 'next' exists in 'org-todo-keywords'
    (setq org-use-fast-todo-selection t)
    
    ;; change todo states using S-left and S-right, and skipping all normal processings when entering or leaving a todo state: cycle through todo states but skips setting timestamps and entering notes.
    ;; very convenient when all you want to do is fix up the status of an entry.
    (setq org-treat-S-cursor-todo-selection-as-state-change nil)
    
    #+end_src

- TODO state triggers <<todo_state_triggers>> :: to automatically assign tags to tasks based on state changes
  + tags and states ::
    - on some pre-defined triggers, automatically assign tags to tasks based on state changes.
    - eg :: If a task moves to =CANCELLED= state then it gets a =CANCELLED= tag. Moving a =CANCELLED= task back to =TODO= removes the =CANCELLED= tag.
    - These are mainly used for filtering tasks in agenda views.
  + current settings break down ::
    - Moving a task to =CANCELLED= adds a =CANCELLED= tag
    - Moving a task to =WAITING= adds a =WAITING= tag
    - Moving a task to =HOLD= adds =WAITING= and =HOLD= tags
    - Moving a task to a done state removes =WAITING= and =HOLD= tags
    - Moving a task to =TODO= removes =WAITING=, =CANCELLED=, and =HOLD= tags
    - Moving a task to =NEXT= removes =WAITING=, =CANCELLED=, and =HOLD= tags
    - Moving a task to =DONE= removes =WAITING=, =CANCELLED=, and =HOLD= tags
  + todo state flow ::
    - task states flow ::
      #+begin_src plantuml :file normal_task_states.png :cache yes
      title Task States
      [*] -> TODO
      TODO -> NEXT
      TODO -> DONE
      NEXT -> DONE
      DONE -> [*]
      TODO --> WAITING
      WAITING --> TODO
      NEXT --> WAITING
      WAITING --> NEXT
      HOLD --> CANCELLED
      WAITING --> CANCELLED
      CANCELLED --> [*]
      TODO --> HOLD
      HOLD --> TODO
      TODO --> CANCELLED
      TODO: t
      NEXT: n
      DONE: d
      WAITING:w
      note right of WAITING: Note records\nwhat it is waiting for
      HOLD:h
      note right of CANCELLED: Note records\nwhy it was cancelled
      CANCELLED:c
      WAITING --> DONE
      #+end_src
    - task states transition definition ::
      #+header: :tangle yes
      #+begin_src emacs-lisp    
      ;; "TODO state triggers" (automatically assign tags to tasks on state changes.)
      ;; ex: Moving task to done state removes WAITING and HOLD tags
      (setq org-todo-state-tags-triggers
            (quote (("CANCELLED" ("CANCELLED" . t))
                    ("WAITING" ("WAITING" . t))
                    ("HOLD" ("WAITING") ("HOLD" . t))
                    (done ("WAITING") ("HOLD"))
                    ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                    ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                    ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
      #+end_src

- GTDs and projects ::
  + bh definition of a project :: any task with a subtask with a todo state keyword
  + bh definition of phone calls :: "phone calls created in a done state by a capture task. The time of the call is recorded for as long as the capture task is active. If need to look up other details and want to close the capture task early, can just =C-c C-c= to close the capture task (stopping the clock) and then =f9 SPC= to resume the clock in the phone call while doing other things"
    #+begin_src plantuml :file phone_states.png :cache yes
    title Phone Call Task State
    [*] -> PHONE
    PHONE -> [*]
    #+end_src
  + meetings ::
    - bh definition of meetings :: "created in a done state by a capture task. Use MEETING capture template when someone interrupts (question/discussion)
    - time of meeting recorded for as long as the capture task is active. ::
    - can escape capture time early :: C-c C-c will close capture
    - resume capture time record (bh configs) :: =f9 SPC= 
    - example ::
      #+begin_src plantuml :file meeting_states.png :cache yes
      title Meeting Task State
      [*] -> MEETING
      MEETING -> [*]
      #+end_src

** Org-mode notes taking, Capture and refiling
:PROPERTIES:
:CUSTOM_ID: CaptureTemplates
:END:

- capture and capture templates ::
  + quick process ::
    1. create a note using note capture templates :: ==C-c c n==
    2. type a heading for the note
    3. save it :: ==C-c C-c==
    4. remember to refile it later when have time
    5. if there is no specific task to refile the note into, then it belongs to it goes to the catchall ==* Notes== task
    6. tips ::
       + have a catchall ==notes== task in every project file
       + in bh configs, notes are created with a ==NOTE== tag already applied by the capture template, so it's easy to refile the note anywhere
       + as long as the note is in a project file that contributes to the agenda (ie. org-agenda-files) then easy to find the note back with notes agenda view ==F12 N==
       + can limit the agenda view of notes using standard agenda tag filtering
       + project related notes are not generally useful off project, and can be archived with the project and removed from the agenda when the project is removed
  + starting org-capture :: ==C-c c==
  + use a minimal number of capture templates rather than going through all available templates ::
  + can clock task in capture mode ::
  + can remove empty lock drawers (marked with logbook) when clocking lines is 0 :: 
    - hence, use mechanism to remove empty logbooks when occuring ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ;; quick clocking in/out of capture mode tasks often takes less than a minute to capture new task details => can leave empty clock drawers in tasks which aren't really useful. If remove clocking lines with 0:00 length, one might end up with empty LOGBOOK (clock drawer). Hence, need to remove those empty LOGBOOK drawers when they occur on clock out
      ;; remove empty LOGBOOK drawers on clock out
      (defun bh/remove-empty-drawer-on-clock-out ()
        (interactive)
        (save-excursion
          (beginning-of-line 0)
          (org-remove-empty-drawer-at "LOGBOOK" (point))))
      
      (add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)
      #+end_src
  + capture templates definitions :: meetings, phone calls, etc.
  + better to have just one file with different subtask, than may files ::    
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; 'capture' for notes (previously known as 'remember')
    ;; not quite helpful to have lot of capture templates, use minimal to capture quicknote and resume current task, then after refile them properly
    ;; the other benefit of minimal template is when new org file created, not always necessary to configure a new template for it
    (setq org-directory (getenv "HOME" ))
    (setq org-default-notes-file (concat org-directory "/Documents/repos/org/perso_stuff/GTD/refile.org"))	
    (setq org-capture-templates
    	    ;; clock-in means the task is clocked, and when task is filed (using C-c C-c), then the clock resumes on the original task
    	    '(("m" "Meeting" entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Calendar")
    	       "* Meeting %^{Description} %^g\n %? :MEETING:\n Added: %U\n" :clock-in t :clock-resume t)
    	      ;; for example, a mail that needs a response
    	      ("r" "Needs response" entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Calendar")
    	       "* NEXT Respond to %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
    	      ("p" "Phone call" entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Calendar")
    	       "* Phone %? :PHONE:\n%U\n" :clock-in t :clock-resume t)
    	      ("t" "Tasks diary" entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Tasks")
    	       "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
    	      ("u" "Us.es Tasks"  entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Tasks")
    	       "* TODO %? :US.ES:\n%U\n%a\n" :clock-in t :clock-resume t)
    	      ("c" "Cpp Tasks"  entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Tasks")
    	       "* TODO %? :CPP:\n%U\n%a\n" :clock-in t :clock-resume t)
    	      ("n" "Note"  entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Notes")
    	       "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
    	      ("x" "Most used commands" entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Most used commands")
    	       "- %?\n%U\n%a\n" :clock-in t :clock-resume t)
    	      ("h" "Habit" entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Habit")
    	       "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")
    	      ("e" "e-mail related task" entry (file+headline "~/Documents/repos/org/memacs/GTD/refile.org" "Source related tasks")
    	       "- %? , as activity response to source:\t%i\n%U\n%a\n" :clock-in t :clock-resume t)
    	      ("j" "Journal" entry (file+datetree "~/Documents/repos/org/memacs/GTD/journal.org")
    	       "* %?\n%U\n" :clock-in t :clock-resume t)))	
    #+end_src
  + add 'refile' tag to tag everything in file with the refile tag (that one line at top) :: #+FILETAGS: REFILE
  + process quick capture in the middle of something else ::
    1. =C-c c= :: start capture
    2. select =t= :: since a task to add in capture
    3. enter all needed details for TODO item
    4. =C-c C-c= :: file it away in refile file (defined with org-default-notes-file) and resume previous task
       + with bh configs, time spent while logging capture is clocked

- refiling things ::
  - refiling tasks ::
    + need target for refiling files :: choice is letting et any file in org-agenda-files contribute to the list of valid refile targets
    + using IDO (“Interactively DO things”) :: IDO is nice, for example, it makes easy locating targets ::
      - sources :: https://www.masteringemacs.org/article/introduction-to-ido-mode
    + frequency :: at most 1/week regularly; but better to do as soon as possible
    + process for refiling ::
      - =C-c C-w= :: start refile process
        - can start typing to get matching targets and =C-SPC= to restrict matches to current list
        - =C-j= :: to select current completion
      - ex :: to refile a task to us.es_notes.org under header 'to investigate' for example ::
        1. put cursor on task
        2. =C-c C-w= RET
        3. type: =us.e C-SPC to inv RET=
        4. done
      - refile configs ::
        #+header: :tangle yes
        #+begin_src emacs-lisp
        ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
        (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                         (org-agenda-files :maxlevel . 9))))
        
        ; Use full outline paths for refile targets - we file directly with IDO
        (setq org-refile-use-outline-path t)
        
        ; Targets complete directly with IDO
        (setq org-outline-path-complete-in-steps nil)
        
        ; Allow refile to create parent tasks with confirmation
        (setq org-refile-allow-creating-parent-nodes (quote confirm))
        
        ; Use IDO for both buffer and file completion and ido-everywhere to t
        (setq org-completion-use-ido t)
        (setq ido-enable-flex-matching t) ; use ido flex matching
        (setq ido-everywhere t)
        (setq ido-max-directory-size 100000)
        (ido-mode (quote both))
        ; Use the current window when visiting files and buffers with ido
        (setq ido-default-file-method 'selected-window)
        (setq ido-default-buffer-method 'selected-window)
        ; Use the current window for indirect buffer display
        (setq org-indirect-buffer-display 'current-window)
        
        ;;;; Refile settings
        ; Exclude DONE state tasks from refile targets
        (defun bh/verify-refile-target ()
          "Exclude todo keywords with a done state from refile targets"
          (not (member (nth 2 (org-heading-components)) org-done-keywords)))
        
        (setq org-refile-target-verify-function 'bh/verify-refile-target)
        
        #+end_src
    + find tasks to refile ::
      - run agenda view :: =F12 SPC= (bh config)
      - and scroll to tasks to refile section ::
	+ can do a bulk refile that go to same refile target ::
	  - mark all tasks to refile in same target :: =m=
	  - refile all marked bulk :: =B r=
      - can refile tasks as subtasks of current clocking task from [to_refile] file :: =C-2 C-c C-w=
      - if task to refile is a one-shot uninteresting task (like a coffee break) => create a capture journal entry for it that goes to generic tree (eg: diary.org date tree) ::
      - if it's task that actually needs to be tracked and marked done, and applied to some project => create a capture task instead which files it in dedicated tree (eg: refile.org) ::
  - refiling notes ::
    + when have a * Note headline to org files ::
      - add NOTE tag to make it easier to find notes across multiple files using agenda search functions for example ::
	+ tags should be created by the capture template for notes
	+ when refiling notes though, try to find most appropriate section, rather than put it all under the catchall * Notes of the refile target
  - refiling phone calls and meetings ::
    + ex of use :: billed calls, needs to be refiled in appropriate target (in project, accounting, etc.) when clocked properly
    + handled through capture modes ::
      - can time calls and meetings using capture mode template settings to clock in and out the capture task while phone call/meeting is in progress
    + again, need to be refiled in appropriate target :: reports are important

** Org-mode agenda view, customizing, search/filter, and generating agenda views

- notes on bh custom agenda views ::
  + one block agenda view that has everything on it
  + separate single view agenda for slower PC (takes prohibitively long to generate block agenda on slow machine)
  + newer org-mode versions enable filtering
  + with bh custom agenda view, can ::
    - Single block agenda shows the following
      + overview of today
      + Finding tasks to be refiled
      + Finding stuck projects
      + Finding NEXT tasks to work on
      + Show all related tasks
      + Reviewing projects
      + Finding tasks waiting on something
      + Findings tasks to be archived
    - Finding notes
    - Viewing habits
  + keybinding for today agenda view :: =F12 a=

*** Matching tags and properties (filtering and viewings tags/properties)
:PROPERTIES:
:CUSTOM_ID: match_tags_props
:END:

 - filtering is not just enabled only in agenda mode

 - source :: https://orgmode.org/manual/Matching-tags-and-properties.html

 - basics ::
   + =|= for OR, =&= for AND (& binds more strongly than |)
   + parentheses not implemented
   + each element in search is either a tag, a regular expression matching tags, or an expression like ‘PROPERTY OPERATOR VALUE’ with a comparison operator, accessing a property value.
   + each element may be preceded by =-= to select against it (condition is forbidden), and =+= is syntactic sugar for positive selection (condition is required)
   + =/= backward compatibility of =|=
   + if value is enclosed in double quotes *AND* angular brackets, then it's a date/time (ex: "<2008-12-24 18:30>")
     - ex of date/time comparison: DEADLINE<="<2008-12-24 18:30>"
     - <now>, <today>, and <tomorrow> are also valid
   + instead of tag, one can also specify a regular expression enclosed in curly braces
     - example :: =work+{^boss.*}= matches headlines that contain the tag ‘:work:’ and any tag starting with ‘boss’.

**** Group tags

   - source :: https://orgmode.org/manual/Tag-Hierarchy.html

   - tags can be defined in hierarchies (defining multiple group tags and nesting them creates a tag hierarchy)

   - a tag can be defined as a group tag for a set of other tags. The group tag can be seen as the “broader term” for its set of tags

   - example use-case :: create a taxonomy of terms (tags) that can be used to classify nodes in a document or set of documents

   - when searching for a group tag, it return matches for all members in the group and its subgroups

   - in an agenda view, filtering by a group tag displays or hide headlines tagged with at least one of the members of the group or any of its subgroups, this makes tag searches and filters more flexible

   - to set group tags :: use brackets and insert a colon between the group tag and its related tags (beware that all whitespaces are mandatory so that Org can parse line correctly)
     + in the following example, ‘GTD’ is the group tag and it is related to two other tags: ‘Control’, ‘Persp’ ::
       #+begin_src org :exports src
       #+TAGS: [ GTD : Control Persp ]
       #+end_src
     + defining ‘Control’ and ‘Persp’ as group tags creates a hierarchy of tags ::
       #+begin_src org :exports src
       #+TAGS: [ Control : Context Task ]
       #+TAGS: [ Persp : Vision Goal AOF Project ]
       #+end_src
     + the result is conceptually a hierarchy of tags ::
       - 'GTD' ::
	 + 'Persp'
	   - 'Vision'
	   - 'Goal'
	   - 'AOF'
	   - 'Project'
	 + 'Control'
	   - 'Context'
	   - 'Task'
     + can use the :startgrouptag, :grouptags and :endgrouptag keyword directly when setting org-tag-alist directly ::
       #+begin_src org :exports src
       (setq org-tag-alist '((:startgrouptag)
		       ("GTD")
		       (:grouptags)
		       ("Control")
		       ("Persp")
		       (:endgrouptag)
		       (:startgrouptag)
		       ("Control")
		       (:grouptags)
		       ("Context")
		       ("Task")
		       (:endgrouptag)))
       #+end_src
     + tags in a group can be mutually exclusive if using same group syntax as used for grouping mutually exclusive tags together: using curly brackets ::
       #+begin_src org :exports src
       #+TAGS: { Context : @Home @Work @Call }
       #+end_src
       + when setting org-tag-alist you can use :startgroup and :endgroup instead of :startgrouptag and :endgrouptag to make the tags mutually exclusive
	 #+begin_example
	 ;; Tags that are mutually excluding example (use of dummy tags :startgroup and :endgroup)
	 ;; (setq org-tag-alist '((:startgroup . nil)
	 ;;                       ("@work" . ?w) ("@home" . ?h)
	 ;;                       ("@tennisclub" . ?t)
	 ;;                       (:endgroup . nil)
	 ;; 		         ("laptop" . ?l) ("pc" . ?p)))
	 #+end_example
     + members of a group tag can also be regular expressions, creating the possibility of a more dynamic and rule-based tag structure. The regular expressions in the group must be specified within curly brackets ::
       - expanded example ::
	 #+begin_src org :exports src
	 #+TAGS: [ Vision : {V@.+} ]
	 #+TAGS: [ Goal : {G@.+} ]
	 #+TAGS: [ AOF : {AOF@.+} ]
	 #+TAGS: [ Project : {P@.+} ]
	 #+end_src
       - searching for the tag ‘Project’ will list all tags also including regular expression matches for ‘P@.+’, and similarly for tag searches on ‘Vision’, ‘Goal’ and ‘AOF’. For example, this would work well for a project tagged with a common project-identifier, e.g., ‘P@2014_OrgTags’
     + if one wants to ignore group tags temporarily, toggle group tags support with org-toggle-tags-groups (bound to =C-c C-x q=). If wants to disable tag groups completely, set org-group-tags to nil
     + searching through group tags ::
       - group tags are expanded as regular expressions. E.g., if ‘work’ is a group tag for the group ‘:work:lab:conf:’, then searching for ‘work’ also searches for ‘{\(?:work\|lab\|conf\)}’ and searching for ‘-work’ searches for all headlines but those with one of the tags in the group (i.e., ‘-{\(?:work\|lab\|conf\)}’)

   - examples ::
     + 0. 'work/!-WAITING-NEXT' :: select 'work'-tagged TODO lines that are neither 'WAITING' nor 'NEXT'
     + 0.2. 'work/!+WAITING|+NEXT' :: select 'work'-tagged TODO lines that are either 'WAITING' or 'NEXT'
     + 1. '+work-boss' :: select headlines marked 'work', discard those also marked 'boss'
     + 2. 'work|laptop' :: select lines tagged work or laptop
     + 3. 'work|laptop+night' :: same as 2. but now with lines also tagged night
     + 4. (also works with regex) : 'work+{*boss.*}' :: matches headlines containing tag 'work' and any tag starting with 'boss'
     + 5. 'work+TODO​="WAITING"': select 'work'-tagged TODO lines with the specific TODO keyword 'WAITING'
     + 5.1. 'work/WAITING' same but in backward compatibility mode
     + 6. 'work+TODO​="WAITING"|home+TODO​="WAITING"': waiting tasks both at work and at home
     + 7. a hard one with number of different operators used to test the value of a property ::
       #+begin_src org :exports src
         +work-boss+PRIORITY="A"+Coffee="unlimited"+Effort<2+With={Sarah\|Denny}+SCHEDULED>="<2008-10-11>"
       #+end_src
       - 'Effort' in this case is a plain number, so can use operators: <,<=,>,>=,=,and <> (but with strings same operators apply too)

**** Matching property drawers and column views
   - source :: https://orgmode.org/manual/Properties-and-Columns.html
   - a property (or more specifically a property /drawer/) is a key-value pair associated with an entry
   - Properties can be set so they are associated with a single entry, with every entry in a tree, or with the whole buffer
   - 2 main applications for properties in Org mode ::
     + properties are like tags, but with a value ::
       - Imagine maintaining a file where you document bugs and plan releases for a piece of software.
       - Instead of using tags like ‘release_1’, ‘release_2’, can use a property, say ‘Release’, that in different subtrees has different values (‘1.0’, ‘2.0’, etc.)
     + second, can use properties to implement (very basic) database capabilities in an Org buffer ::
       - Imagine keeping track of your music CDs, where properties could be things such as the album, artist, release date, number of tracks, etc.
   - Drawers :: 
     + for informations associated with an entry, but that not normally want to see
     + can contain anything *but* a headline and another drawer
     + drawers look like this ::
       #+begin_src org :exports src
       ** This is a headline
       Still outside the drawer
       :DRAWERNAME:
       This is inside the drawer.
       :END:
       After the drawer.
       #+end_src
     + insert drawer below current headline :: =C-c C-x d= // calls 'org-insert-drawer'
     + insert property drawer below current headline :: // calls 'org-insert-property-drawer'
     + different drawer types ::
       - drawer :: generic one, as seen above
       - properties drawer :: key-value pairs seen above
       - LOGBOOK drawer (logs for tracking TODO state changes, clocking time, and notes) ::
	 + to track notes into LOGBOOK drawer, customize the variable 'org-log-into-drawer'
	 + to overrule the setting of variable 'org-log-into-drawer' for a subtree, use setting ‘LOG_INTO_DRAWER’ property
	 + it's too much to record a note for every state, thus, org-mode expects configuration on a per-keyword basis for this ::
	   - this is achieved by adding special markers in parentheses after each keyword ::
	     + ‘!’ :: for a timestamp
	     + ‘@’ :: for a note with timestamp
	   - example ::
	     #+begin_src org :exports src
	     (setq org-todo-keywords
		 '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")))
	     #+end_src
	     + this setting will ::
	       - define global TODO keywords and fast access keys
	       - and also request ::
		 + that a time is recorded when the entry is set to ‘DONE’
		 + that a note is recorded when switching to ‘WAIT’ or ‘CANCELED’
		 + more special for 'WAIT' :: ‘!’ after the slash means that in addition to the note taken when entering the state, a timestamp should be recorded when leaving the ‘WAIT’ state, if and only if the target state does not configure logging for entering it
		   - So it has no effect when switching from ‘WAIT’ to ‘DONE’, because ‘DONE’ is configured to record a timestamp only
		   - But when switching from ‘WAIT’ back to ‘TODO’, the ‘/!’ in the ‘WAIT’ setting now triggers a timestamp even though ‘TODO’ has no logging configured
	   - can also use exact same syntax for setting logging preferences local _to a buffer_ ::
	     #+begin_src org :exports src
	     #+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@)
	     #+end_src
	   - to record a timestamp without a note for TODO keywords configured with ‘@’, just type =C-c C-c= to enter a blank note when prompted
	   - to define logging settings that are local to a subtree or a single item :: define a ‘LOGGING’ property in this entry
	     + any non-empty ‘LOGGING’ property resets *all* logging settings to nil
	     + can then turn on logging for this specific tree using ‘STARTUP’ keywords like ‘lognotedone’ or ‘logrepeat’ (for repeated tasks), as well as adding state specific settings like ‘TODO(!)’
	     + example ::
	       #+begin_src org :exports src		     
	       ;; * TODO Log each state with only a time
	       ;;   :PROPERTIES:
	       ;;   :LOGGING: TODO(!) WAIT(!) DONE(!) CANCELED(!)
	       ;;   :END:
	       ;; * TODO Only log when switching to WAIT, and when repeating
	       ;;   :PROPERTIES:
	       ;;   :LOGGING: WAIT(@) logrepeat
	       ;;   :END:
	       ;; * TODO No logging at all
	       ;;   :PROPERTIES:
	       ;;   :LOGGING: nil
	       ;;   :END:
	       #+end_src
	 + clocking work time :: to clock time spent on specific tasks in a project
	   + more details :: https://orgmode.org/manual/Clocking-Work-Time.html
	   + have to start/stop yourself to clock task when starting/stopping it
	   + automatic when task is done
	   + also computes the total time spent on each subtree of a project
	   + remembers a history or tasks recently clocked, so that can jump quickly between a number of time absorbing tasks
	 + add time-stamped note to ‘LOGBOOK’ drawer :: =C-c C-z=
       - ARCHIVE drawer :: For archiving (Moving a tree to an archive file).
	 + the ‘ARCHIVE’ property can define the archive location for entire subtrees
	 + archive subtree starting at point position to the location given by =org-archive-location= :: =C-c C-x C-s=, or short =C-c $ (org-archive-subtree)=
	 + check if any direct children of current headline could be moved to the archive :: 
	   - checking each subtree for open *TODO entries* :: =C-u C-c C-x C-s=
	     + if none found, the command offers to move it to the archive location
	     + if point is not on a headline when command invoked => checks level 1 trees
	   - checking each subtree for *timestamps* instead of TODO entries :: =C-u C-u C-c C-x C-s=
	     + command offers to archive the subtree if it does contain a timestamp, and that timestamp is in the past
	 + default archive location is a file in same directory as current file, with the name derived by appending *‘_archive’* to the current file name
	   - can choose what heading to file archived items under, with the possibility to add them to a datetree in a file
	 + when a subtree is moved, it receives a number of special properties that record context information like the file from where the entry came, its outline path, the archiving time etc.
	   - can configure the variable =org-archive-save-context-info= to adjust the amount of information added
   - Property drawer forewords ::
     + Properties are key–value pairs
     + when associated with a single entry or with a tree, they need to be inserted into a special drawer with the name =PROPERTIES=, which has to be located right below a headline, and its planning line when applicable
     + Deadlines and Scheduling ::
       - timestamp may be preceded by special keywords to facilitate planning. Both the timestamp and the keyword have to be positioned immediately after the task they refer to
       - 'DEADLINE' ::
	 + on deadline date, task listed in the agenda
	 + today agenda carries warning about approaching or missed deadline, starting 'org-deadline-warning-days' before the due date, and until entry is marked as done
	 + ex ::
	   #+begin_src org :exports src
	   ;; *** TODO write article about the Earth for the Guide
	   ;; DEADLINE: <2004-02-29 Sun>
	   ;; The editor in charge is [[bbdb:Ford Prefect]]
	   #+end_src
	 + can specify different lead time for warnings for specific deadlines using the following syntax: here is an example with a warning period of 5 days ‘DEADLINE: <2004-02-29 Sun -5d>’
	   - Warning deactivated if task gets scheduled and one sets 'org-agenda-skip-deadline-prewarning-if-scheduled' to t
       - 'SCHEDULED' :: planning to start working on task on given date
	 + headline listed under the given date in agenda view
	 + in addition, a reminder that scheduled date has passed is present in the compilation for today, until entry is marked as done, i.e., the task is automatically forwarded until completed
	 + ex ::
	   #+begin_src org :exports src
           ;; *** TODO Call Trillian for a date on New Years Eve.
           ;;     SCHEDULED: <2004-12-25 Sat>
	   #+end_src
	 + if needs to delay the display of the task in the agenda, use ‘SCHEDULED: <2004-12-25 Sat -2d>’ :: the task is still scheduled on the 25th but will appear two days later
	 + in case the task contains a repeater, the delay is considered to affect all occurrences; if you want the delay to only affect the first scheduled occurrence of the task, use ‘--2d’ instead
	 + see =org-scheduled-delay-days= and =org-agenda-skip-scheduled-delay-if-deadline= for details on how to control this globally or per agenda
	 + !!important!! :: /Scheduling/ an item in org-mode is different than scheduling a meeting ::
	   - scheduling a meeting is just a simple appointment :: => mark entry with a simple plain timestamp, to get item shown on the date where it applies
	   - 'SCHEDULED' :: means setting a date when one wants to start working on an _*action item*_
       - deadlines and schedules with repeaters :: can use timestamps with repeaters in scheduling and deadline entries. Org-mode issues early and late warnings based on the assumption that the timestamp represents the nearest instance of the repeater
       - for more :: https://orgmode.org/manual/Deadlines-and-Scheduling.html
       - inserting deadlines or schedules for an item ::
	 + create a sparse tree with all deadlines that are either past-due, or which will become due within 'org-deadline-warning-days' :: =C-c / d (org-check-deadlines)=
	   - with =C-u= prefix, show all deadlines in the file
	   - with a numeric prefix, check that many days, ex :: =C-1 C-c / d= shows all deadlines due tomorrow
	 + sparse tree for deadlines and scheduled items before a given date :: =C-c / b (org-check-before-date)=
	 + sparse tree for deadlines and scheduled items _after_ a given date :: =C-c / a (org-check-after-date)=
	 + insert deadline :: =C-c C-d (org-deadline)=
	   - depending on the variable =org-log-redeadline=, takes a note when changing an existing deadline
	 + insert schedule :: =C-c C-s (org-schedule)=
	   - depending on the variable org-log-reschedule, takes a note when changing an existing scheduling time
	 + for both ::
	   - removes any ‘CLOSED’ timestamp
	   - when called with a prefix argument, also removes any existing deadline/scheduling date from the entry
	 + note :: =org-schedule= and =org-deadline= supports setting the date by indicating a relative time, e.g.:
	   - '+1d' :: sets the date to the next day after today
	   - '--1w' :: sets the date to the previous week before any current timestamp:: 
   - Property drawer syntax ::
     + Again, properties are key–value pairs
     + and again, when associated with a single entry or with a tree, they need to be inserted into a special drawer with the name =PROPERTIES=, which has to be located right below a headline, and its planning line when applicable
     + a property can only have one entry per drawer
     + each property is specified on a single line, with the key—surrounded by colons—first, and the value after it. Keys are case-insensitive
       - ex:
	 #+begin_src org :exports src
	 * CD collection
	 ** Classic
	 *** Goldberg Variations
	    :PROPERTIES:
	    :Title:     Goldberg Variations
	    :Composer:  J.S. Bach
	    :Artist:    Glenn Gould
	    :Publisher: Deutsche Grammophon
	    :NDisks:    1
	    :END:
	 #+end_src
	 + depending on the value of =org-use-property-inheritance=, a property set this way is associated either with a single entry, or with the subtree defined by the entry
	   - Property Inheritance ::
	     + if the parent in a tree has a certain property, the children can inherit this property
	     + Org mode does not turn this on by default, because it can slow down property searches significantly and is often not needed
	     + can turn it on by setting the variable =org-use-property-inheritance= to t, to make all properties inherited from the parent, to a list of properties that should be inherited, or to a regular expression that matches inherited properties
	     + if a property has the value nil, this is interpreted as an explicit un-define of the property, so that inheritance search stops at this value and returns nil
     + can define allowed values for a particular property ‘Xyz’ by setting a property ‘Xyz_ALL’ ::
       - ex of collection of CDs :: publishers and number of disks in a box are predefined:
	 #+begin_src org :exports src
	 * CD collection
	 :PROPERTIES:
	 :NDisks_ALL:  1 2 3 4
	 :Publisher_ALL: "Deutsche Grammophon" Philips EMI
	 :END:
	 #+end_src
       - this special property is inherited :: so if it is set in a level 1 entry, it applies to the entire tree
       - when allowed values are defined, setting the corresponding property becomes easier and is less prone to typing errors ::
     + can insert Properties on buffer level (located at the top of the buffer, allowing only comments above) ::
       - means they apply before the first headline and can be inherited by all entries in a file
       - ex ::
	 #+begin_src org :exports src
	 #+PROPERTY: NDisks_ALL 1 2 3 4
	 #+end_src
     + can add to the value of an existing property :: append a ‘+’ to the property name
       - ex :: here 'var' has the value 'foo=1 bar=2'
	 #+begin_src org :exports src
	 #+PROPERTY: var  foo=1
	 #+PROPERTY: var+ bar=2
	 #+end_src
     + can add to the values of inherited properties ::
       - ex :: 'Genres' property having the value 'Classic Baroque' under the 'Goldberg Variations' subtree
	 #+begin_src org :exports src
	 * CD collection
	 ** Classic
	     :PROPERTIES:
	     :Genres: Classic
	     :END:
	 *** Goldberg Variations
	     :PROPERTIES:
	     :Title:     Goldberg Variations
	     :Composer:  J.S. Bach
	     :Artist:    Glenn Gould
	     :Publisher: Deutsche Grammophon
	     :NDisks:    1
	     :Genres+:   Baroque
	     :END:
	 #+end_src
     + Property values set with global variable =org-global-properties= can be inherited by all entries in all Org files
   - Property drawer commands ::
     + (autocomplete) after an initial colon in a line, complete property keys :: =M-TAB (pcomplete)=
       - all keys used in the current file are offered as possible completions
     + set a property :: =C-c C-x p (org-set-property)=
       - prompts for a property name and a value
       - if necessary, the property drawer is created as well
     + set a property in the current entry :: =C-c C-c s (org-set-property)=
       - both the property and the value can be inserted using completion
     + insert a property drawer into the current entry :: =C-u M-x org-insert-drawer=
       - the drawer is inserted early in the entry, but after the lines with planning information like deadlines
       - if before first headline, the drawer is inserted at the top of the drawer after any potential comments
     + with point in a property drawer, execute property commands :: =C-c C-c (org-property-action)=
     + switch property at point to the next/previous allowed value :: =S-RIGHT (org-property-next-allowed-values)/S-LEFT (org-property-previous-allowed-value)=
     + remove a property from the current entry :: =C-c C-c d (org-delete-property)=
     + globally remove a property, from all entries in the current file :: =C-c C-c D (org-delete-property-globally)=
     + compute the property at point, using the operator and scope from the nearest column format definition :: =C-c C-c c (org-compute-property-at-point)=
   - Special properties ::
     + provide an alternative access method to Org mode features, like the TODO state or the priority of an entry
     + exist so that can include these states in a column view, or to use them in queries
     + special properties should not be used as keys in the properties drawer
     + special properties ::
       - ‘ALLTAGS’ :: all tags, including inherited ones
       - ‘BLOCKED’ :: 't' if task is currently blocked by children or siblings
       - ‘CATEGORY’ :: the category of an entry.
       - ‘CLOCKSUM’ :: the sum of CLOCK intervals in the subtree. =org-clock-sum= must be run first to compute the values in the current buffer
       - ‘CLOCKSUM_T’ :: the sum of CLOCK intervals in the subtree for today. =org-clock-sum-today= must be run first to compute the values in the current buffer.
       - ‘CLOSED’ :: when was this entry closed?
       - ‘DEADLINE’ :: the deadline timestamp
       - ‘FILE’ :: the filename the entry is located in
       - ‘ITEM’ :: the headline of the entry
       - ‘PRIORITY’ :: the priority of the entry, a string with a single letter
       - ‘SCHEDULED’ :: the scheduling timestamp
       - ‘TAGS’ :: the tags defined directly in the headline
       - ‘TIMESTAMP’ :: the first keyword-less timestamp in the entry
       - ‘TIMESTAMP_IA’ :: the first inactive timestamp in the entry
       - ‘TODO’ :: the TODO keyword of the entry
   - Property searches (commands also work for Tag searches) :: to create sparse trees and special lists with selection based on properties
     + create a sparse tree with all matching entries :: =C-c / m or C-c \ (org-match-sparse-tree)=
       - with =C-u= prefix argument :: ignore headlines that are not a TODO line
     + create a global list of tag/property matches from all agenda files :: =M-x org-agenda m (org-tags-view)=
     + create a global list of tag matches from all agenda files, but check only TODO items and force checking of subitems (see option =org-tags-match-list-sublevels=) :: =M-x org-agenda M (org-tags-view)=
     + create sparse trees based on a value of a single property :: =C-c / p=
       - prompts for the name of a property, and then for a value
       - a sparse tree is created with all entries that define this property with the given value
       - if value is enclosed in curly braces, it is interpreted as a regular expression and matched against the property values
     + syntax for the search string is described in :: [[#match_tags_props][Matching tags and properties]]
   - Column view :: to view and edit properties in an outline tree
   - test for properties combined with matching tags ::
   - Custom agenda views ::
     + notes ::
       - generating time of block agenda can be restraining, especially when one wants to view weighty data (checking clocking data, agenda block on weeks, months, etc) => generating a custom agenda view with only needed infos can be faster
     + custom agenda views can be used for ::
       - Single block agenda (shows following) ::
	 + today overview
	 + find NEXT tasks to work on
	 + find tasks to be refiled
	 + find stuck projects
	 + show all related tasks
	 + reviewing projects
	 + find tasks waiting on something
	 + find tasks to be archived
       - find notes ::
       - view habits ::

*** bh custom agenda views configs + mine, eventually :) (for this, use custom tag/identification ?)
    
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; Do not dim blocked tasks
    (setq org-agenda-dim-blocked-tasks nil)
      
    ;; Compact the block agenda view
    (setq org-agenda-compact-blocks t)
      
    ;; Custom agenda command definitions
    (setq org-agenda-custom-commands
	   (quote (("N" "Notes" tags "NOTE"
		    ((org-agenda-overriding-header "Notes")
                     (org-tags-match-list-sublevels t)))
		   ("h" "Habits" tags-todo "STYLE=\"habit\""
		    ((org-agenda-overriding-header "Habits")
                     (org-agenda-sorting-strategy
		      '(todo-state-down effort-up category-keep))))
		   (" " "Agenda"
		    ((agenda "" nil)
                     (tags "REFILE"
			   ((org-agenda-overriding-header "Tasks to Refile")
			    (org-tags-match-list-sublevels nil)))
                     (tags-todo "-CANCELLED/!"
				((org-agenda-overriding-header "Stuck Projects")
				 (org-agenda-skip-function 'bh/skip-non-stuck-projects)
				 (org-agenda-sorting-strategy
				  '(category-keep))))
                     (tags-todo "-HOLD-CANCELLED/!"
				((org-agenda-overriding-header "Projects")
				 (org-agenda-skip-function 'bh/skip-non-projects)
				 (org-tags-match-list-sublevels 'indented)
				 (org-agenda-sorting-strategy
				  '(category-keep))))
                     (tags-todo "-CANCELLED/!NEXT"
				((org-agenda-overriding-header (concat "Project Next Tasks"
								       (if bh/hide-scheduled-and-waiting-next-tasks
									   ""
									 " (including WAITING and SCHEDULED tasks)")))
				 (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
				 (org-tags-match-list-sublevels t)
				 (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-sorting-strategy
				  '(todo-state-down effort-up category-keep))))
                     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
				((org-agenda-overriding-header (concat "Project Subtasks"
								       (if bh/hide-scheduled-and-waiting-next-tasks
									   ""
									 " (including WAITING and SCHEDULED tasks)")))
				 (org-agenda-skip-function 'bh/skip-non-project-tasks)
			   p      (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-sorting-strategy
				  '(category-keep))))
                     (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
				((org-agenda-overriding-header (concat "Standalone Tasks"
								       (if bh/hide-scheduled-and-waiting-next-tasks
									   ""
									 " (including WAITING and SCHEDULED tasks)")))
				 (org-agenda-skip-function 'bh/skip-project-tasks)
				 (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-sorting-strategy
				  '(category-keep))))
                     (tags-todo "-CANCELLED+WAITING|HOLD/!"
				((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
								       (if bh/hide-scheduled-and-waiting-next-tasks
									   ""
									 " (including WAITING and SCHEDULED tasks)")))
				 (org-agenda-skip-function 'bh/skip-non-tasks)
				 (org-tags-match-list-sublevels nil)
				 (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
				 (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))
                     (tags "-REFILE/"
			   ((org-agenda-overriding-header "Tasks to Archive")
			    (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
			    (org-tags-match-list-sublevels nil))))
		    nil))))
    #+end_src

    + top-down priority task display for the custom agenda view (tasks with deadlines on top, next, etc.)
    + with config, bh working day style ::
      - Punch in (starts clock on the default task)
      - Look at agenda and make mental note of anything important to deal with today
      - Read email and news
	+ create notes, and tasks for things that need responses with /org-capture/
      - Check refile tasks and respond to emails
      - Look at agenda and work on important tasks for today
	+ clock it in
	+ work on it until it is DONE or gets interrupted
      - Work on tasks
      - Make journal entries (==C-c c j==) for interruptions
      - Punch out for lunch and punch back in after lunch
      - Work on more tasks
      - Refile tasks to empty the list
	+ tag tasks to be refiled with ==m== collecting all tasks for the same target
	+ bulk refile the tasks to the target location with ==B r==
	+ repeat (or refile individually with ==C-c C-w==) until all refile tasks are gone
      - Mark habits (as tasking and working process done) done today as DONE
      - Punch out at the end of the work day

** Choosing tasks to work on next and time management tips
*** How to pick a *new task* to work on
  + after going through tasks with deadlines, and today's tasks -> move on to tasks in the ==Next Tasks== list in the block agenda view
  + list new tasks :: ==F12 SPC== (bh config)
  + guidelines ::
    - Pick something off today's agenda ::
      + deadline for today (do this first - it's not late yet)
      + deadline in the past (it's already late)
      + a scheduled task for today (it's supposed to be done today)
      + a scheduled task that is still on the agenda
      + deadline that is coming up soon
    - pick a /NEXT/ task
    - if runs out of items to work on, look for a NEXT task in the current context, pick a task from the Tasks list of the current project.

*** Why keep everything in ==NEXT== list
  + ==NEXT== task is something available to work on now, it is the next logical step in a project, and it's efficient to locate the next to work on as fast as possible
  + if a task in the ==NEXT== list is not to be taken straight away, then it's easier to put it back in the ==TODO== list
  + having more than one list to pick a task from (==ONGOING== for example) is dangerous since they are likely to never be started/ended and can be confusing

*** Reading email, newsgroups, and conversations
  + pick a default task to time reading conversations
  + if emails/conversations need a response, then create a capture task with header: 'Respond to <user>'
  + can clock effort needed to respond (even recommended)
  + create a capture template for response needed tasks, advantages ::
    - can automatically link to email in task, hence making it easier to find later
    - automatically schedule respond task, and even be able to refile it to the appropriate org file
  + overall process ::
    1. read *ALL* mails
    2. create capture 'respond' task for each mail that needs a response
    3. when finished reading mails, go to newly captured tasks and refile them from the block agenda (with ==F12 a==)
    4. clock in an email task, deal with it
    5. repeat until all the 'Respond to <user>' tasks are marked ==DONE==
  + try considering emails/conversations/newsgroups as the same in order to benefit from the previous rules
    - default clocking task, capture, refiling, etc.
  + if a useful piece of information is worth remembering ::
    1. create a note for it with ==C-c c n==
    2. enter the topic
    3. file it
    4. (the time spent in the capture buffer is clocked with that capture note)

*** Filtering tips
**** GTD tips
  + beginning of the day
    1. AM, working day :: start by selecting into ==NEXT== list, tasks that are easy/fast to complete in order to knock off the ==NEXT== list
       1. get list of ==NEXT== tasks from the agenda block
       2. filter it as wanted
	  + bh config orders tasks in the ==NEXT== agenda view by estimated effort, so the short tasks are *first*
	  + bh config can limit the displayed agenda tasks to those estimated 10 minutes or less with ==/ + 1==
	    - so, can pick something that fits the minutes left before any other task (eg: take off for lunch)
**** Automatically remove context based tasks with ==/ RET==
  + ==/ RET== :: removes tasks automatically by filtering based on a user-provided function
  + eg, with ==/ RET==, filter out from agenda block tasks (and subtasks, because of tag inheritance) ::
    - on hold
    - about a hobby or any other task that needs infrequent or flexible work
  + config for ==/ RET== ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; filter from agenda block tasks that not need to be worked on urgently
    (defun bh/org-auto-exclude-function (tag)
      "Automatic task exclusion in the agenda with / RET"
      (and (cond
            ((string= tag "hold")
             t)
            ((string= tag "warhammer")
             t))
    	(concat "-" tag)))
    
    (setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)
    #+end_src

** Time Clocking
*** forewords ::
  + making a habit to clock in is beneficial on multiple fronts, for example estimating a task effort based on previous tasks, or identify tasks where too much time is spent
  + ==punching in== and ==punching out== :: at start and end of work day: punch in when arrive at work, punch out for lunch, punch in after lunch, and punch out at the end of the day
    - every minute is *clocked between punch-in and punch-out* times
    - punching in defines a default task to clock time on whenever the clock would normally stop (default org-mode setup)
      - with default org-mode setup one would lose clocked minutes during the day (a minute here, a minute there, and that all adds up)
      - especially true if one is writing notes when moving to a ==DONE== state :: in this case the clock normally stops before one have composed the note (whereas good notes take a few minutes to write)
    - bh clocking setup description ::
      1. Punch in (starts the clock)
	 + This clocks in a predefined task by ==org-id== that is the default task to clock in whenever the clock normally stops
      2. Clock in tasks normally, and let moving to ==DONE== state clock out
	 + clocking out automatically clocks time on a *parent task* or moves back to the *predefined default* task if no parent exists
      3. Continue clocking whatever tasks you work on
      4. Punch out (stops the clock)
    - bh config outcomes ::
      + 'default clocking task' ::
	- to put miscellaneous clock time into
	- task clocked in on when punching in
	- task clocked in while reorganizing org-files, reading email, clearing inbox, and doing other planning work that isn't for a specific project
      + can change default task multiple times during the day (between punch in/out), but since the clock moving up the project tree on clock out, no need to
      + single task gets clocked in when one punches-in
      + if one punches-in with a prefix on a task in 'Project X', then that task automatically becomes the default task and all clocked time goes on that project until one either punches out/in in some other task
      + if one is working on some task, then just simply clock in on the task
      + clocking out moves the clock up to a parent task with a todo keyword (if any) which keeps the clock time in the same subtree
      + moving a subtask to ==DONE== continues clocking to the project task, unless whole project is complete
      + if no such parent task with a todo keyword then the clock moves back to the default clocking task until some other task is clocked in, or one punches out
      + when an interruption occurs, then start a capture task which keeps clocked time on the interruption task until it is closed with ==C-c C-c==
  + eg ::
    - suppose have the following todo.org file ::
	#+begin_src org :exports src
	,#+FILETAGS: PERSONAL
	...
	,* Tasks
	,** Organization
	   :PROPERTIES:
	   :CLOCK_MODELINE_TOTAL: today
	   :ID:       eb155a82-92b2-4f25-a3c6-0304591af2f9
	   :END:
	   ...
	#+end_src
    - and the other following org file ::
	#+begin_src org :exports src
	,* TODO Project A
	,** NEXT TASK 1
	,** TODO TASK 2
	,** TODO TASK 3
	,* Tasks
	,** TODO Some miscellaneous task
	#+end_src
    - then work as follows ::
      1. punch in with ==F9-I== at start of day
	 + that clocks in the 'Organization' task by *id* in todo.org file
      2. ==F12-SPC== to review block agenda
	 + Pick 'TODO Some miscellaneous task' to work on next and clock that in with ==I==
	 + The clock is now on 'TODO Some miscellaneous task'
      3. complete task and mark it done with ==C-c C-t d==
	 + This stops the clock and moves it back to the 'Organization' task
      4. Next, work on 'Project A' so clock in 'Task 1'
	 + work on Task 1 and mark it DONE: this clocks out Task 1 and moves the clock to Project A
	 + Now work on Task 2 and clock that in
	 + as long as working on and clocking subtasks of Project A, all of the clock time in the interval is applied somewhere to the Project A tree
	 + when Project A marked as done, then the clock will move back to the default 'organization' task

*** Clocking setup
  + clock times, state changes, and other notes are kept in the =:LOGBOOK:= drawer
  + kbd ::
    - clocking in ::
      + ==I== when in the agenda
      + ==I== speed key on the first character of the heading line
      + ==f9 I== while on the task in the agenda
      + ==f9 I== while on the task in an org file
      + ==C-c C-x C-i== otherwise
      + ==C-u C-c C-x C-i d== fast clock in on default clocking task
	- alternative :: repeatedly clock out so clock moves up the project tree until clock out top-level task and the clock moves to the default task
      + change default clocking task :: visit the new task in any org buffer and clock it in with ==C-u C-u C-c C-x C-i==
	- then this new task will collect miscellaneous clock minutes when the clock would normally stop
    - show menu list with prefix for clocking in a task :: ==C-F11==
    - clock history selection buffer :: ==C-u C-c C-x C-i==
  + the set up ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
     ;;
     ;; Resume clocking task when emacs is restarted
     (org-clock-persistence-insinuate)
     ;;
     ;; Show lot of clocking history so it's easy to pick items off the C-F11 (Clock in a task (show menu with prefix)) list
     (setq org-clock-history-length 23)
     ;; Resume clocking task on clock-in if the clock is open
     (setq org-clock-in-resume t)
     ;; Change tasks to NEXT when clocking in
     (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
     ;; Separate drawers for clocking and logs
     (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
     ;; Save clock data and state changes and notes in the LOGBOOK drawer
     (setq org-clock-into-drawer t)
     ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
     (setq org-clock-out-remove-zero-time-clocks t)
     ;; Clock out when moving task to a done state
     (setq org-clock-out-when-done t)
     ;; Save the running clock and all clock history when exiting Emacs, load it on startup
     (setq org-clock-persist t)
     ;; Do not prompt to resume an active clock
     ;;(setq org-clock-persist-query-resume nil)
     ;; Enable auto clock resolution for finding open clocks
     (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
     ;; Include current clocking task in clock reports
     (setq org-clock-report-include-clocking-task t)
    
     (setq bh/keep-clock-running nil)
    
     (defun bh/clock-in-to-next (kw)
       "Switch a task from TODO to NEXT when clocking in.
     Skips capture tasks, projects, and subprojects.
     Switch projects and subprojects from NEXT back to TODO"
       (when (not (and (boundp 'org-capture-mode) org-capture-mode))
         (cond
          ((and (member (org-get-todo-state) (list "TODO"))
                (bh/is-task-p))
           "NEXT")
          ((and (member (org-get-todo-state) (list "NEXT"))
                (bh/is-project-p))
           "TODO"))))
    
     (defun bh/find-project-task ()
       "Move point to the parent (project) task if any"
       (save-restriction
         (widen)
         (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
           (while (org-up-heading-safe)
             (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
               (setq parent-task (point))))
           (goto-char parent-task)
           parent-task)))
    
     (defun bh/punch-in (arg)
       "Start continuous clocking and set the default task to the
     selected task.  If no task is selected set the Organization task
     as the default task."
       (interactive "p")
       (setq bh/keep-clock-running t)
       (if (equal major-mode 'org-agenda-mode)
           ;;
           ;; We're in the agenda
           ;;
           (let* ((marker (org-get-at-bol 'org-hd-marker))
                  (tags (org-with-point-at marker (org-get-tags-at))))
             (if (and (eq arg 4) tags)
                 (org-agenda-clock-in '(16))
               (bh/clock-in-organization-task-as-default)))
         ;;
         ;; We are not in the agenda
         ;;
         (save-restriction
           (widen)
           ; Find the tags on the current task
           (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
               (org-clock-in '(16))
             (bh/clock-in-organization-task-as-default)))))
    
     (defun bh/punch-out ()
       (interactive)
       (setq bh/keep-clock-running nil)
       (when (org-clock-is-active)
         (org-clock-out))
       (org-agenda-remove-restriction-lock))
    
     (defun bh/clock-in-default-task ()
       (save-excursion
         (org-with-point-at org-clock-default-task
           (org-clock-in))))
    
     (defun bh/clock-in-parent-task ()
       "Move point to the parent (project) task if any and clock in"
       (let ((parent-task))
         (save-excursion
           (save-restriction
             (widen)
             (while (and (not parent-task) (org-up-heading-safe))
               (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                 (setq parent-task (point))))
             (if parent-task
                 (org-with-point-at parent-task
                   (org-clock-in))
               (when bh/keep-clock-running
                 (bh/clock-in-default-task)))))))
    
     (defvar bh/organization-task-id "eb155a82-92b2-4f25-a3c6-0304591af2f9")
    
     (defun bh/clock-in-organization-task-as-default ()
       (interactive)
       (org-with-point-at (org-id-find bh/organization-task-id 'marker)
         (org-clock-in '(16))))
    
     (defun bh/clock-out-maybe ()
       (when (and bh/keep-clock-running
                  (not org-clock-clocking-in)
                  (marker-buffer org-clock-default-task)
                  (not org-clock-resolving-clocks-due-to-idleness))
         (bh/clock-in-parent-task)))
    
     (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)
    
    #+end_src

**** Clocking history (to find previously clocked task and resume it)
  + use :: restart clocks or jump directly to task clocked previously (resume clocking in whatever got interrupted)
  + eg scenario ::
    - working on and clocking ==Task A== (say: 'Organization')
    - gets interrupted and switch to ==Task B== ('Document use of org-mode')
    - Task B completed
    - now want to go back to Task A (Organization)
  + eg display :: when pushing clock history selection buffer ==C-u C-c C-x C-i==
    #+begin_example
    Default Task
    [d] norang          Organization                          <-- Task B
    The task interrupted by starting the last one
    [i] norang          Organization                          <-- Task B
    Current Clocking Task
    [c] org             NEXT Document my use of org-mode      <-- Task A
    Recent Tasks
    [1] org             NEXT Document my use of org-mode      <-- Task A
    [2] norang          Organization                          <-- Task B
    ...
    [Z] org             DONE Fix default section links        <-- 35 clock task entries ago
    #+end_example

  + process ::
    1. clock in Task A,
    2. go to Task B (or create a new task) and clock it in
    3. when Task B finished hit: ==C-u C-c C-x C-i i== // last 'i' for 'interrupted'
       + this displays the clock history selection window and selects the interrupted ==[i]== entry

**** Clock Everything - Create New Tasks
  + use :: create new tasks to clock in, and also manage bunch of tasks that can be clocked together
  + eg scenario :: create new capture task to record interruptions
    1. suppose was clocking task and an interruption occurs
    2. create a quick capture task journal entry ==C-c c j==
    3. type the heading
    4. go do that thing (eat lunch for eg)
    5. file it ==C-c C-c== (this restores the clock back to the previous clocking task)
    6. clock something else in or continue with the current clocking task
  + advantage :: can ignore the details like where the task really belongs in org file layout and just get on with completing the thing
    - beneficial since refiling the tasks with other bunch of tasks later when it is convenient to refile the tasks saves time in the long run
  + tips ::
    - if it's a one-shot uninteresting task (like coffee break), can create a capture journal entry for it that goes to 'diary.org' date tree for example
    - if it's a task that actually needs to be tracked and marked done, and applied to some project then can create a capture task instead which files it in 'refile.org'

**** Finding tasks to clock in
  + can use one of the following options (ordered by bh's decreasing order of frequency of used)
    1. use clock history :: ==C-u C-c C-x C-i== and go back to some unfinished thing that was clocked previously
    2. pick something off today's block agenda ==SCHEDULED== or ==DEADLINE== items that need to be done soon
    3. pick something off the ==NEXT== tasks agenda view, or work on some unfinished task that needs completion
    4. pick something off the other task list
    5. use an agenda view with filtering to pick something to work on
  + note :: punching in on a task will restrict the agenda view to that project so can focus on just that thing for some period of time

**** Editing clock entries (to reflect more reality)
  + example of editing need :: cannot clock in a task on time because away from computer. In this case the previous clocked task is still running and counts time for both tasks which is wrong
    - solution :: make a note of the time, and when computer available, clock in the right task and edit the start and end times to correct the clock history
  + to visit the clock line for an entry quickly use the agenda log mode :: ==F12 a l== shows all clock lines for today
    - ==F11== goes to the current clocked task but the agenda log mode is better for finding and visiting older clock entries
    - process ::
      1. ==F12 a l== to open the agenda in log mode and show only logged clock times
      2. move the cursor down to the clock line needing edition
      3. hit ==TAB==
      4. put cursor on the part of the date needing edition (use keyboard not mouse, clicking on the timestamp with the mouse goes back to the agenda for that day)
      5. hit ==S-<up arrow>== or ==S-<down arrow>== keys to change time
  + setup for time editing using discrete minute intervals (no rounding) increments ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ;; makes time editing use discrete minute intervals (no rounding) increments
      (setq org-time-stamp-rounding-minutes (quote (1 1)))
      #+end_src
  + ==S-<up arrow>== or ==S-<down arrow>== also updates the total for the clock line which is a nice convenience
  + careful to not create task overlaps when fixing time clock entries ::
    - can do that by viewing them with log mode on in the agenda
    - can use view in the agenda for this :: ==v c== in the daily agenda and clock gaps and overlaps are identified
  + setup for more accuracy of clock entries, following setting shows 1 minute clocking gaps ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; for more accuracy of clock entries, following setting shows 1 minute clocking gaps
    (setq org-agenda-clock-consistency-checks
          (quote (:max-duration "4:00"
                  :min-duration 0
                  :max-gap 0
                  :gap-ok-around ("4:00"))))
    #+end_src
*** Time reporting, time tracking
  - time reporting commands ::
    - check unclosed clock times in current agenda with agenda-view clock check :: ==v c==
    - check the last month's clock data in agenda :: ==F12 a v m b v c== : shows a full month in the agenda, moves to previous month, and shows the clocked times only
**** Based on clocking time
  + eg of usecase :: billing client at the beginning of month for last worked month
  + need to validate the correctness of the report before confirming
  + process main steps ::
    1. verify that the clock data is complete and correct
    2. use clock reports to summarize time spent
    3. create an invoice based on the clock data
       - can use external tool based on the org-mode clock data
    4. archive completed tasks

***** Verify that clock data is complete and correct
  + remove entries with zero duration :: see ==org-clock-out-remove-zero-time-clocks==, cleans clock entries that contribute to the clock report
  + remove clocked time with not closed entries (ie. it has no end time) :: counted as zero which is wrong
    - check unclosed clock times :: use agenda-view clock check: ==v c== in the agenda
      + the view also shows clocking gaps and overlaps in the agenda
    - while checking month report in agenda ::
      + ==F12 a v m b v c== :: shows a full month in the agenda, moves to previous month, and shows the clocked times only
      + the clocked-time only display in the agenda makes it easy to quickly scan down the list to see if an entry is missing an end time
      + if an entry is not closed, then can manually fix the clock entry based on other clock info around that time

***** Use clock reports to summarize time spent
  + note :: use different org files to track work clocked time clients, and other stuff
  + process to get a report of time spent on tasks for client XYZ ::
    1. visit the XYZ.org file
    2. run an agenda clock report for the last month :: ==F12 < a v m b R==
       - limits the agenda to this one file,
       - shows the agenda for a full month,
       - moves to last month,
       - and generates a clock report
  + Agenda clock report summarizing parameters ::
    - by default clock report shows only 5 levels with links to the task. For wider reports than default compact, override value for ':narrow'
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ;; Agenda clock report parameters
      (setq org-agenda-clockreport-parameter-plist
            (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))
      #+end_src

**** Estimates and column view (estimates tasks effort, and then clock the actual time)
***** Creating a task estimate with column mode
  + bh :: use ==properties== and ==column view== to do project estimates
  + set up for estimates with global column view :: 
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; Set default column view headings: Task Effort Clock_Summary
    (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
    #+end_src
    - makes column view show estimated task effort and clocked times side-by-side
    - property ==Effort== records the estimated amount of time a given task will take to complete. Estimate times used by bh are one of: 10mins, 30mins, 1hour, 2hours, ..., 8hours
    - these estimate times are stored for easy use in ==column mode== in the global property ==Effort_ALL== ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; creating task estimates (column mode, in global property 'Effort_ALL')
    ; global Effort estimate values : 15 minutes, 30', 45', 1hour, etc.
    ; global STYLE property values for completion
    (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                        ("STYLE_ALL" . "habit"))))
    #+end_src
  + to create an estimate for a task or subtree ::
    1. start column mode :: ==C-c C-x C-c==
    2. collapse the tree :: ==c==
       - shows a table overlayed on top of the headlines with :: the task name, effort estimate, and clocked time in columns
    3. with the cursor in the ==Effort== column for a task, can easily set the estimated effort value with the quick keys ==1== through ==9==
    4. when done, exit ==column mode== with ==q==

***** Saving estimates
  + usecase example :: working for client on a fixed price job basis => need to save and provide estimate to the client
  + howto save estimate :: create a dynamic clock report table at the top of the estimated project subtree
    - ==C-c C-x i RET== to insert a clock table report with estimated values and any clocked time to date
    - eg of generated clock report with estimates ::
      #+begin_src org :exports src
      Original Estimate
      ,#+BEGIN: columnview :hlines 1 :id local
      | Task                        | Estimated Effort | CLOCKSUM |
      |-----------------------------+------------------+----------|
      | ** TODO Project to estimate |             5:40 |          |
      | *** TODO Step 1             |             0:10 |          |
      | *** TODO Step 2             |             0:10 |          |
      | *** TODO Step 3             |             5:10 |          |
      | **** TODO Step 3.1          |             2:00 |          |
      | **** TODO Step 3.2          |             3:00 |          |
      | **** TODO Step 3.3          |             0:10 |          |
      | *** TODO Step 4             |             0:10 |          |
      ,#+END:
      #+end_src
    - better to delete ==#+BEGIN:== and ==#+END:== lines from the original table after providing the estimate to the client
      + to ensure don't accidentally update the table by hitting ==C-c C-c== on the ==#+BEGIN:== line
    - saving the original estimate data makes it possible to refine the project tasks into subtasks on the go without losing the original estimate data

***** Reviewing estimates
  + ==Column view== is great for reviewing estimates, it shows estimated time value and total clock time for the project side-by-side
  + creating a dynamic clock table with ==C-c C-x i RET== is a great way to save a project review if needed to be made available to other applications
  + ==C-c C-x C-d== provides a quick summary of clocked time for the current org file

***** Providing progress reports to others
  + to provide latest details on ongoing work, simply generate a log report in the agenda with completed tasks and state changes combined with a clock report for the appropriate time period
  + settings to show closed tasks and state changes in the agenda. Combined with the agenda clock report (==R==), it's possible to quickly generate all of the details required ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; Agenda log mode items to display (show closed and state changes by default)
    (setq org-agenda-log-mode-items (quote (closed state)))
    #+end_src
  + to generate the report ::
    1. pull up the agenda for the appropriate time frame (today, yesterday, this week, or last week)
    2. hit ==l R== to add the log report (without clocking data lines) and the agenda clock report at the end
    3. export the resulting agenda in some useful format to provide to other people ::
       - eg :: ==C-x C-w /tmp/agenda.html RET== exports to HTML, ==C-x C-w /tmp/agenda.txt RET== exports to plain text (possible to export in other formats)
       - can combine export with tag filters and ==C-u R== to limit the report to exactly the tags that people are interested in

** Tags
:PROPERTIES:
:CUSTOM_ID: OrgTagAlist
:END:

  + notes :: 
    - main use ::
      + *filtering* todo lists and agenda views
      + providing *context* for tasks
      + tagging notes, phone calls, meetings
      + tagging tasks *to be refiled*
      + tagging tasks in a ==WAITING== state *because a parent* task is ==WAITING==
      + tagging cancelled tasks *because a parent* task is CANCELLED
      + *preventing* export of some subtrees when publishing
    - can make tags mutually exclusive :: defined in a group so that only one of the tags can be applied to a task at a time (disregarding tag inheritance)
      + can be used for example to apply context to a task (eg: ==@office== for work, ==@us.es== for sevilla, that needs to be done when at home)
    - can reuse a modified version of a tag to higlight that they are related ::
      + eg ::
	- two tags ==FARM== and ==@farm==
	- ==FARM== being set for eg by a ==FILETAGS== entry and gives a way to filter anything farm related
	- ==@farm== tag to mean that the task has to be done at the farm
	- if need to call someone about something with a FARM tag, no need to be physically at the farm to make the call
    - tasks are grouped together in org-files and a ==#+FILETAGS:== entry applies a tag to *all tasks in the file*
    - ==:startgroup== - ==:endgroup== (which bh chosed to note as ==@XXX==) tags are mutually exclusive
      + not to be confused with ==:startgrouptag== which creates hierarchies of tags (see section group tags in [[#match_tags_props][Matching tags and properties]])
      + editing a mutually exclusive tag automagically removes the old one, cannot cohabitate
    - ==#+FILETAGS== :: convenient way to apply one or more tags to all of the headings in a file, eg: ==#+FILETAGS: NORANG @office==
    - tags ==WAITING== and ==CANCELLED== are automatically added or removed by todo state triggers described in [[todo_state_triggers][previous section]]
  + kbd ::
    - add or remove tag or apply the tag for filtering on the agenda :: ==C-c C-q==
  + set up ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; Tags with fast selection keys, eg: type O to select tag ORG
    (setq org-tag-alist (quote ((:startgroup)
                                ("@errand" . ?e)
                                ("@office" . ?o)
                                ("@home" . ?H)
                                ("@farm" . ?f)
                                (:endgroup)
				(:startgrouptag)
				("US.ES" . ?u)
				(:grouptags)
				("LineProg")
				("GeneAlgos")
				(:endgrouptag)
                                ("WAITING" . ?w)
                                ("HOLD" . ?h)
                                ("PERSONAL" . ?P)
                                ("WORK" . ?W)
                                ("FARM" . ?F)
                                ("ORG" . ?O)
				("CPP" . ?c)
                                ("crypt" . ?E)
                                ("NOTE" . ?n)
                                ("CANCELLED" . ?C)
                                ("FLAGGED" . ??))))

    ; Allow setting single tags without the menu, so no longer have to press RET to exit fast tag selection, it exits after the first change
    (setq org-fast-tag-selection-single-key (quote expert))
    
    ; For tag searches ignore tasks with scheduled and deadline dates
    (setq org-agenda-tags-todo-honor-ignore-options t)

    #+end_src
  + tags organisation per file ::
    #+INCLUDE: "./organisation_org_files.org::Tags by files and context"

** Agenda and notes
  + reminder, quick process to create notes ::
    1. create a note using note capture templates :: ==C-c c n==
    2. type a heading for the note
    3. save it :: ==C-c C-c==
    4. remember to refile it later when have time
    5. if there is no specific task to refile the note into, then it belongs to it goes to the catchall ==* Notes== task
    6. tips ::
       + have a catchall ==notes== task in every project file
       + in bh configs, notes are created with a ==NOTE== tag already applied by the capture template, so it's easy to refile the note anywhere
       + as long as the note is in a project file that contributes to the agenda (ie. org-agenda-files) then easy to find the note back with notes agenda view ==F12 N==
       + can limit the agenda view of notes using standard agenda tag filtering
       + project related notes are not generally useful off project, and can be archived with the project and removed from the agenda when the project is removed
  + kbd ::
    - notes agenda view :: ==F12 N==

** Handling phone calls
  + notes ::
    - phone calls are interruptions, so treated with capture as all interruptions
    - with bh configs ::
      + most of phone calls is handled by capture mode
      + can use special capture template for phone calls combined with a custom function that replaces text with information from ==bbdb3== (bbdb3 is just bbdb version 3.XXX)
        #+header: :tangle yes
        #+begin_src emacs-lisp
        ;; phone calls configs
        ;; (require 'bbdb) // commented since causing issues, is it deprecated ?
        ;; (require 'bbdb-com) // same
        #+end_src
      + the phone call capture template starts the clock as soon as the phone rings, then one is free to lookup and replace the caller in ==bbdb== anytime during or after the call
	- capture mode starts the clock using the ==:clock-in t== setting in the template
  + process ::
    1. start capture task (==C-c c p==) and enter notes from the call in the template ::
       + cursor starts in the template normally where the name of the caller would be inserted
	 - can use a ==bbdb== lookup function to insert the name :: ==f9-b==
	 - if a ==bbdb== entry needs to be created for the caller, then can do that first and replace the caller details with ==f9-p== anytime that is convenient afterward
    2. when phone call ends, do ==C-c C-c== to close the capture buffer and stop the clock
  + set-up ::
    - see "Phone call" section in org-capture-templates
    - see kbd "<f9> p" for 'bh/phone-call
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; Phone capture template handling with BBDB lookup
    ;; Adapted from code by Gregory J. Grubbs
    (defun bh/phone-call ()
      "Return name and company info for caller from bbdb lookup"
      (interactive)
      (let* (name rec caller)
        (setq name (completing-read "Who is calling? "
                                    (bbdb-hashtable)
                                    'bbdb-completion-predicate
                                    'confirm))
        (when (> (length name) 0)
          ; Something was supplied - look it up in bbdb
          (setq rec
                (or (first
                     (or (bbdb-search (bbdb-records) name nil nil)
                         (bbdb-search (bbdb-records) nil name nil)))
                    name)))
    
        ; Build the bbdb link if we have a bbdb record, otherwise just return the name
        (setq caller (cond ((and rec (vectorp rec))
                            (let ((name (bbdb-record-name rec))
                                  (company (bbdb-record-company rec)))
                              (concat "[[bbdb:"
                                      name "]["
                                      name "]]"
                                      (when company
                                        (concat " - " company)))))
    			(rec)
    			(t "NameOfCaller")))
        (insert caller)))
    
    #+end_src

** GTD and org mode (weekly review, project definition, etc.)
  + kbd ::

*** Weekly Review
  + once a week, do a review (monday/friday)
  + keep a list to remind yourself what needs to be done for the coming week
  + set-up for weekly review ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; to make org-agenda fast
    ;; show only today's date by default, no need to know much details
    ;; weekly view is called explicitly
    (setq org-agenda-span 'day)
    #+end_src
  + keep recurring task which keeps weekly review checklist is very handy, for eg ::
    #+begin_src org :exports src
    ,* NEXT Weekly Review [0/6]
      SCHEDULED: <2009-05-18 Mon ++1w> 
      :LOGBOOK:...
      :PROPERTIES:...
    
      What to review:
    
       - [ ] Check follow-up folder (physical or virtual place/folder to keep documents/files/letters to read and process (stuff that needs to be taken care of, but in no particular hurry to deal with))
       - [ ] Review weekly agenda =F12 a w //=
       - [ ] Check clocking data for past week =v c=
       - [ ] Review clock report for past week =R=
         - Check where we spent time (too much or too little) and rectify this week
       - [ ] Look at entire agenda for today  =F12 SPC=
       - [ ] Review projects =F12 SPC //= and =V= repeatedly to view each project
    
       - start work
         - daily agenda first - knock off items
         - then work on NEXT tasks
    #+end_src

*** Project definition and finding stuck projects
  + /project/ definition :: *any task with a subtask using a todo keyword*
  + :: 
  + projects are /stuck/ :: if they have *no subtask with a ==NEXT== todo keyword* task defined
    - hence, org-mode stuck projects *agenda view* lists projects that have *no ==NEXT== task defined*
    - so, *always* try to assign a ==NEXT== task in the stuck projects agenda view so the list *remains empty* in order to keep projects moving forward
    - projects can have subprojects - and these subprojects can also be stuck :: hence, all of the stuck projects and subprojects show up in the stuck projects list
      + so, same, add ==NEXT== to unblock the project
    - only when tasks/subtasks are in ==WAITING== for something that the project stays in the stuck list, until the condition is satisfied
      + in that case, leave it on the stuck project list and work on something else
      + the 'waiting' stuck project will bug the block agenda regularly, which will prompt the user to follow up on the waiting thing until it is done
  + eg ::
    - given ::
      #+begin_src org :exports src
      ,* Category
      ,** TODO Stuck Project A
      ,*** TODO Task B
      ,** TODO Project C
      ,*** TODO Stuck Sub Project D
      ,**** TODO SubTask E
      ,*** TODO Sub Project F
      ,**** NEXT SubTask G
      ,**** TODO SubTask H
      ,*** NEXT Task I
      ,*** TODO Task J
      #+end_src
    - result in stuck project view :: 
      + Project A stuck because it has no subtask in ==NEXT== ::
      + Project C is not stuck because it has ==NEXT== tasks :: SubTask G and Task I
      + Sub Project D is stuck because SubTask E is not ==NEXT== and there are no other tasks available in this project :: 
  + set-ups ::
    - disable the default org-mode stuck projects agenda view ::
      + prevents org-mode from trying to show incorrect data if select the default stuck project view with ==F12 #== from the agenda menu
      + customization for stuck projects view is part of bh block agenda, displayed with ==F12 SPC==
      + set-up for disabling default ::
        #+header: :tangle yes
        #+begin_src emacs-lisp
        ; disable the default org-mode stuck projects agenda view
        (setq org-stuck-projects (quote ("" nil nil "")))
        #+end_src
    - helper functions defined for projects which are used by agenda views ::          
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ;; helper functions for projects used by agenda views
      (defun bh/is-project-p ()
        "Any task with a todo keyword subtask"
        (save-restriction
          (widen)
          (let ((has-subtask)
                (subtree-end (save-excursion (org-end-of-subtree t)))
                (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
            (save-excursion
              (forward-line 1)
              (while (and (not has-subtask)
                          (< (point) subtree-end)
                          (re-search-forward "^\*+ " subtree-end t))
                (when (member (org-get-todo-state) org-todo-keywords-1)
                  (setq has-subtask t))))
            (and is-a-task has-subtask))))
      
      (defun bh/is-project-subtree-p ()
        "Any task with a todo keyword that is in a project subtree.
      Callers of this function already widen the buffer view."
        (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                    (point))))
          (save-excursion
            (bh/find-project-task)
            (if (equal (point) task)
                nil
              t))))
      
      (defun bh/is-task-p ()
        "Any task with a todo keyword and no subtask"
        (save-restriction
          (widen)
          (let ((has-subtask)
                (subtree-end (save-excursion (org-end-of-subtree t)))
                (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
            (save-excursion
              (forward-line 1)
              (while (and (not has-subtask)
                          (< (point) subtree-end)
                          (re-search-forward "^\*+ " subtree-end t))
                (when (member (org-get-todo-state) org-todo-keywords-1)
                  (setq has-subtask t))))
            (and is-a-task (not has-subtask)))))
      
      (defun bh/is-subproject-p ()
        "Any task which is a subtask of another project"
        (let ((is-subproject)
              (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
          (save-excursion
            (while (and (not is-subproject) (org-up-heading-safe))
              (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                (setq is-subproject t))))
          (and is-a-task is-subproject)))
      
      (defun bh/list-sublevels-for-projects-indented ()
        "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
        (if (marker-buffer org-agenda-restrict-begin)
            (setq org-tags-match-list-sublevels 'indented)
          (setq org-tags-match-list-sublevels nil))
        nil)
      
      (defun bh/list-sublevels-for-projects ()
        "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
        (if (marker-buffer org-agenda-restrict-begin)
            (setq org-tags-match-list-sublevels t)
          (setq org-tags-match-list-sublevels nil))
        nil)
      
      (defvar bh/hide-scheduled-and-waiting-next-tasks t)
      
      (defun bh/toggle-next-task-display ()
        (interactive)
        (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
        (when  (equal major-mode 'org-agenda-mode)
          (org-agenda-redo))
        (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))
      
      (defun bh/skip-stuck-projects ()
        "Skip trees that are not stuck projects"
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (if (bh/is-project-p)
                (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                       (has-next ))
                  (save-excursion
                    (forward-line 1)
                    (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                      (unless (member "WAITING" (org-get-tags-at))
                        (setq has-next t))))
                  (if has-next
                      nil
                    next-headline)) ; a stuck project, has subtasks but no next task
              nil))))
      
      (defun bh/skip-non-stuck-projects ()
        "Skip trees that are not stuck projects"
        ;; (bh/list-sublevels-for-projects-indented)
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (if (bh/is-project-p)
                (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                       (has-next ))
                  (save-excursion
                    (forward-line 1)
                    (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                      (unless (member "WAITING" (org-get-tags-at))
                        (setq has-next t))))
                  (if has-next
                      next-headline
                    nil)) ; a stuck project, has subtasks but no next task
              next-headline))))
      
      (defun bh/skip-non-projects ()
        "Skip trees that are not projects"
        ;; (bh/list-sublevels-for-projects-indented)
        (if (save-excursion (bh/skip-non-stuck-projects))
            (save-restriction
              (widen)
              (let ((subtree-end (save-excursion (org-end-of-subtree t))))
                (cond
                 ((bh/is-project-p)
                  nil)
                 ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
                  nil)
                 (t
                  subtree-end))))
          (save-excursion (org-end-of-subtree t))))
      
      (defun bh/skip-non-tasks ()
        "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
      	((bh/is-task-p)
              nil)
      	(t
              next-headline)))))
      
      (defun bh/skip-project-trees-and-habits ()
        "Skip trees that are projects"
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
      	((bh/is-project-p)
              subtree-end)
      	((org-is-habit-p)
              subtree-end)
      	(t
              nil)))))
      
      (defun bh/skip-projects-and-habits-and-single-tasks ()
        "Skip trees that are projects, tasks that are habits, single non-project tasks"
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
      	((org-is-habit-p)
              next-headline)
      	((and bh/hide-scheduled-and-waiting-next-tasks
                   (member "WAITING" (org-get-tags-at)))
              next-headline)
      	((bh/is-project-p)
              next-headline)
      	((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
              next-headline)
      	(t
              nil)))))
      
      (defun bh/skip-project-tasks-maybe ()
        "Show tasks related to the current restriction.
      When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
      When not restricted, skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (next-headline (save-excursion (or (outline-next-heading) (point-max))))
                 (limit-to-project (marker-buffer org-agenda-restrict-begin)))
            (cond
      	((bh/is-project-p)
              next-headline)
      	((org-is-habit-p)
              subtree-end)
      	((and (not limit-to-project)
                   (bh/is-project-subtree-p))
              subtree-end)
      	((and limit-to-project
                   (bh/is-project-subtree-p)
                   (member (org-get-todo-state) (list "NEXT")))
              subtree-end)
      	(t
              nil)))))
      
      (defun bh/skip-project-tasks ()
        "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
      	((bh/is-project-p)
              subtree-end)
      	((org-is-habit-p)
              subtree-end)
      	((bh/is-project-subtree-p)
              subtree-end)
      	(t
              nil)))))
      
      (defun bh/skip-non-project-tasks ()
        "Show project tasks.
      Skip project and sub-project tasks, habits, and loose non-project tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
      	((bh/is-project-p)
              next-headline)
      	((org-is-habit-p)
              subtree-end)
      	((and (bh/is-project-subtree-p)
                   (member (org-get-todo-state) (list "NEXT")))
              subtree-end)
      	((not (bh/is-project-subtree-p))
              subtree-end)
      	(t
              nil)))))
      
      (defun bh/skip-projects-and-habits ()
        "Skip trees that are projects and tasks that are habits"
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
      	((bh/is-project-p)
              subtree-end)
      	((org-is-habit-p)
              subtree-end)
      	(t
              nil)))))
      
      (defun bh/skip-non-subprojects ()
        "Skip trees that are not projects"
        (let ((next-headline (save-excursion (outline-next-heading))))
          (if (bh/is-subproject-p)
              nil
            next-headline)))
      #+end_src

** Archiving
  + kbd ::
    - move subtree to archive :: ==a y==
  + notes ::
    - archive a task in file ==[file_name].org== to ==[file_name].org_archive==
    - from bh config ::
      + if a ==done== task is old enough, then archive it
      + archivable tasks show up in the last section of block agenda when a new month starts
      + any tasks ==done==, but with no timestamps the current month or previous month (ie. over 30 days old) are available to archive
	- timestamps include :: closed dates, notes, clock data, etc - any active or inactive timestamp in the task
      + the archived tasks get extra property data created during the archive procedure so that it is possible to reconstruct exactly where the archived entry came from in the rare case where you want to unarchive something
      + no need for an ==ARCHIVE== property in subtrees, tasks can just archive normally to the ==Archived Tasks== heading in the archive file (default setting)
      + bh setup made sure that task states are untouched when they are archived
	- this makes it possible to archive tasks that are not marked ==DONE==
      + exception to using ==ARCHIVE== tag ::
	- the only time one would need to use the tag ==ARCHIVE== on a task with bh config, is when for example one wants to prevent the task from opening by default because it has tons of information that are not needed to be looked at on a regular basis
	- still possible to open the task with ==C-TAB== if needs to see the gory details (like a huge table of data related to the task). But, usually, these information are not needed to be displayed by default
  + procedure ::
    - mark all of the entries in the last section of block agenda using ==m== and then archive them all to the appropriate place with ==B $==
  + set up ::
    - archiving function ::
      + archiving function does not keep the project trees intact, it archives done state tasks when they are old enough and are removed from the main org file
      + theoretically, it should be possible to reconstruct the original tree from the archive detail properties, but bh never tried, so if you would ever need it, you'll need to sort it out yourself
      + archiving function setup ::
        #+header: :tangle yes
        #+begin_src emacs-lisp
        ;; archiving set up
        (setq org-archive-mark-done nil)
        (setq org-archive-location "%s_archive::* Archived Tasks") ;; will archive in [name_of_org_file]_archive
        
        (defun bh/skip-non-archivable-tasks ()
          "Skip trees that are not available for archiving"
          (save-restriction
            (widen)
            ;; Consider only tasks with done todo headings as archivable candidates
            (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
                  (subtree-end (save-excursion (org-end-of-subtree t))))
              (if (member (org-get-todo-state) org-todo-keywords-1)
                  (if (member (org-get-todo-state) org-done-keywords)
                      (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                             (a-month-ago (* 60 60 24 (+ daynr 1)))
                             (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                             (this-month (format-time-string "%Y-%m-" (current-time)))
                             (subtree-is-current (save-excursion
                                                   (forward-line 1)
                                                   (and (< (point) subtree-end)
                                                        (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                        (if subtree-is-current
                            subtree-end ; Has a date in this month or last month, skip it
                          nil))  ; available to archive
                    (or subtree-end (point-max)))
                next-headline))))
        #+end_src

*** when to archive
  + archiving *monthly* works well, as with procedure given previously
  + it keeps current clocking information for the last 30 days out of the archives :: keeps files that contribute to the agenda fairly current (this month, last month, and anything that is unfinished)
  + archiving keeps main working files clutter-free
  + if ever need the detail for the archived tasks, they are still available in the appropriate archive file

** Publishing and Exporting
  + org-mode can export to a variety of publishing formats including (but not limited to) ::
    - Latex, ASCII (plain text - but not the original org-mode file), HTML, LaTeX, Docbook (enables getting to lots of other formats like ODF, XML, etc), PDF (via LaTeX or Docbook), iCal (iCalendar), etc.
  + /new/ exporter basic configs :: /new/ as it is an additional layer on top of default org-mode exporters
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; for using letters as delimiters on list of items
    (setq org-alphabetical-lists t)
    
    ;; explicitly load required exporters
    (require 'ox-html)
    (require 'ox-latex)
    (require 'ox-ascii)
    #+end_src
  + eg of conversion variables and functions from old exporter to new ::
    - Explicitly require exporters ::
      + Add =ox-html=
      + Add =ox-latex=
      + Add =ox-ascii=
    - Rename variables ::
      + =org-export-html-style-extra= to =org-html-head-extra=
      + =org-export-html-validation-link= to =org-html-validation-link=
      + =org-export-html-inline-images= to =org-html-inline-images=
      + =org-export-html-style-include-default= to =org-html-head-include-default-style=
      + =org-export-html-xml-declaration= to =org-html-xml-declaration=
      + =org-export-latex-listings= to =org-latex-listings=
      + =org-export-html-style-include-scripts= to =org-html-head-include-scripts=
    - Publishing changes
      + Rename =:publishing-function=
	- =org-publish-org-to-html= to =org-html-publish-to-html=
	- =org-publish-org-to-org= to =org-org-publish-to-org=
      + Change =:style= to =:html-head=
    - Changed =bh/is-late-deadline= to handle modified deadline string in agenda

*** Org babel
  + org-babel :: makes it easy to generate decent graphics using external packages like ditaa, graphviz, PlantUML, and others
  + prerequisites :: ==graphviz== and ==PlantUML== packages are need on the system
  + org-babel setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; org-babel setups :: makes it easy to generate decent graphics using external packages like ditaa, graphviz, PlantUML, and others
    (setq org-ditaa-jar-path "~/Documents/repos/opt/service/web/lib/ditaa0_10.jar")
    ;;(org-babel-do-load-languages 'org-babel-load-languages '((ditaa . t))) ;; might be a previous config where used ditaa as an pre-installed package
    (setq org-plantuml-jar-path "~/Documents/repos/opt/plantuml/plantuml-1.2022.2.jar")

    ;; to automatically enable plantuml-mode for files with extension .plantuml (https://github.com/skuro/plantuml-mode#installation)
    (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))

    (add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)
    
    ; Make babel results blocks lowercase
    (setq org-babel-results-keyword "results")
    
    (defun bh/display-inline-images ()
      (condition-case nil
          (org-display-inline-images)
        (error nil)))
    
    ; activates ditaa and does its configs
    (org-babel-do-load-languages
     (quote org-babel-load-languages)
     (quote ((emacs-lisp . t)
             (dot . t)
             (ditaa . t)
             (R . t)
             (python . t)
             (ruby . t)
             (gnuplot . t)
             (clojure . t)
             (shell . t)
             (ledger . t)
             (org . t)
             (plantuml . t)
             (latex . t))))
    
    ;; Do not prompt to confirm evaluation
    ;; This may be dangerous - make sure you understand the consequences
    ;; of setting this -- see the docstring for details
    ;(setq org-confirm-babel-evaluate nil)
    
    ; Use fundamental mode when editing plantuml blocks with C-c '
    (add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))
    #+end_src
  + use ::
    1. insert ==begin-src== block for the appropriate tool
    2. edit the text
    3. build the pictures :: ==C-c C-c==
    4. can toggle display of inline images with :: ==C-c C-x C-v==
  + better to disable default startup with inline images since when accessing org-files from an SSH session with no X (X window system, eg: Android phone) it fails to display the images and breaks ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; Don't enable this because it breaks access to emacs from my Android phone
    (setq org-startup-with-inline-images nil)
    #+end_src
**** ditaa
  + great for quickly generating graphics to convey ideas
  + generated by org-mode using plain text source
  + ditaa is distributed with org-mode
  + artist mode makes it easy to create boxes and lines for ditaa graphics
  + template of a ditaa graphic block ::
    #+begin_src org :exports src
    ,#+begin_src ditaa :file some_filename.png :cmdline -r -s 0.8
      <context of ditaa source goes here>
    ,#+end_src
    #+end_src
  + eg ::
    #+begin_src ditaa :file communication.png :cmdline -r -s 0.8 :exports both :cache yes
        +-----------+        +---------+  
        |    PLC    |        |         |                
        |  Network  +<------>+   PLC   +<---=---------+ 
        |    cRED   |        |  c707   |              | 
        +-----------+        +----+----+              | 
                                  ^                   | 
                                  |                   | 
                                  |  +----------------|-----------------+
                                  |  |                |                 |
                                  v  v                v                 v
          +----------+       +----+--+--+      +-------+---+      +-----+-----+       Windows clients
          |          |       |          |      |           |      |           |      +----+      +----+
          | Database +<----->+  Shared  +<---->+ Executive +<-=-->+ Operator  +<---->|cYEL| . . .|cYEL|
          |   c707   |       |  Memory  |      |   c707    |      | Server    |      |    |      |    |
          +--+----+--+       |{d} cGRE  |      +------+----+      |   c707    |      +----+      +----+
             ^    ^          +----------+             ^           +-------+---+
             |    |                                   |                        
             |    +--------=--------------------------+                    
             v                                                             
    +--------+--------+                                                         
    |                 |                                                         
    | Millwide System |            -------- Data ---------                      
    | cBLU            |            --=----- Signals ---=--                      
    +-----------------+                                                         
    #+end_src
    
    #+results[b72ce84b1be00db6721081a8353a0c879f187fdd]:
    [[file:images/communication.png]]

**** graphViz
  + same as ditaa :: 
  + template of a ditaa graphic block ::
    #+begin_src org :exports src
    ,#+begin_src dot :file some_filename.png :cmdline -Kdot -Tpng
      <context of graphViz source goes here>
    ,#+end_src
    #+end_src
  + ==-Kdot== is optional (defaults to dot) and can be substituted with other graphviz types instead (ie. twopi, neato, circo, etc) :: 
  + eg ::
    #+begin_src dot :file gv01.png :cmdline -Kdot -Tpng :exports both :cache yes
    digraph G {
      size="8,6"
      ratio=expand
      edge [dir=both]
      plcnet [shape=box, label="PLC Network"]
      subgraph cluster_wrapline {
        label="Wrapline Control System"
        color=purple
        subgraph {
        rank=same
        exec
        sharedmem [style=filled, fillcolor=lightgrey, shape=box]
        }
        edge[style=dotted, dir=none]
        exec -> opserver
        exec -> db
        plc -> exec
        edge [style=line, dir=both]
        exec -> sharedmem
        sharedmem -> db
        plc -> sharedmem
        sharedmem -> opserver
      }
      plcnet -> plc [constraint=false]
      millwide [shape=box, label="Millwide System"]
      db -> millwide
    
      subgraph cluster_opclients {
        color=blue
        label="Operator Clients"
        rankdir=LR
        labelloc=b
        node[label=client]
        opserver -> client1
        opserver -> client2
        opserver -> client3
      }
    }
    #+end_src
    
    #+results[296ce064f7aab7f79ba32a4e903ed7a31b01ca73]:
    [[file:images/gv01.png]]

**** plantUML
  + build on top of graphviz ::
  + eg of usecase :: todo states change diagrams
  + template of a ditaa graphic block ::
    #+begin_src org :exports src
    ,#+begin_src plantuml :file some_filename.png
      <context of plantuml source goes here>
    ,#+end_src
    #+end_src
***** Sequence diagram
  + example ::
    #+begin_src plantuml :file sequence.png :exports both :cache yes
    title Example Sequence Diagram
    activate Client
    Client -> Server: Session Initiation
    note right: Client requests new session
    activate Server
    Client <-- Server: Authorization Request
    note left: Server requires authentication
    Client -> Server: Authorization Response
    note right: Client provides authentication details
    Server --> Client: Session Token
    note left: Session established
    deactivate Server
    Client -> Client: Saves token
    deactivate Client
    #+end_src

    #+results[9b612e0e68cd747fc032d949b739f4c5b06dee21]:
    [[file:images/sequence.png]]

***** Activity diagram
  + example ::
    #+begin_src plantuml :file activity.png :exports both :cache yes
    title Example Activity Diagram
    note right: Example Function
    (*)--> "Step 1"
    --> "Step 2"
    -> "Step 3"
    --> "Step 4"
    --> === STARTLOOP ===
    note top: For each element in the array
    if "Are we done?" then
      -> [no] "Do this"
      -> "Do that"
      note bottom: Important note\ngoes here
      -up-> "Increment counters"
      --> === STARTLOOP ===
    else
      --> [yes] === ENDLOOP ===
    endif
    --> "Last Step"
    --> (*)
    #+end_src
    
    #+results[d5646e42c69b25b55eb1699a43c5d9547c019c5e]:
    [[file:images/activity.png]]

***** Usecase diagram
  + example ::
    #+begin_src plantuml :file usecase.png :exports both :cache yes
    LabUser --> (Runs Simulation)
    LabUser --> (Analyses Results)
    #+end_src
    
    #+results[b7079ee21eb099b19ca524bf62e84edb7c317890]:
    [[file:images/usecase.png]]

***** Object diagram
  + example ::
    #+begin_src plantuml :file object.png :exports both :cache yes
    Object1 <|-- Object2
    Object1: someVar
    Object1: execute()
    Object2: getState()
    Object2: setState()
    Object2: state
    #+end_src
    
    #+results[12eb2caa1043195361ca1953b474932e796e80f5]:
    [[file:object.png]]

***** State diagram
  + example ::
    #+begin_src plantuml :file plantuml_example_states.png :exports both :cache yes
    [*] --> Start
    Start -> State2
    State2 -> State3
    note right of State3: Notes can be\nattached to states
    State2 --> State4
    State4 -> Finish
    State3 --> Finish
    Finish --> [*]
    #+end_src
    
    #+results[5faa6c28383266f9e8b76f4a8c70012f7ab70753]:
    [[file:images/plantuml_example_states.png]]

*** Publishing single file/project
  + kbd ::
    - publish single file ::
      + export current buffer to type given by key :: ==C-c C-e + [key_of_type_export]==
    - publishing project :: after modifying, then ==C-S-F12==
**** Publishing project
  + with org-mode projects :: no need to remember where the created export files need to move to
  + bh config :: lazy setup: no need to remember the name of the project to publish when a file part of a project is modified
    - function ==bh/save-then-publish== saves the file, and publishes the project that includes this file ::
      + function bound to ==C-S-F12==, so just need to edit and hit :: ==C-S-F12== when done, and can then just move on to the next thing
  + in bh configs for example :: main projects are ==norang, doc, doc-private, org-mode-doc==, and ==tmp==
    - these projects publish directly *to the webserver directory on a remote web server* that serves the site
    - publishing one of these projects exports all modified pages, generates images, and copies the resulting files to the webserver so that they are immediately available for viewing
    - for example, http://doc.norang.ca/ site contains subdirectories with client and private documentation that are restricted by using *Apache Basic authentication*
    - *no need to create links to these sites* from the publicly viewable pages ::
    - http://doc.norang.ca/someclient/ would show the index for any org files under ~/git/doc.norang.ca/someclient/ if that is set up as a viewable website
    - bh uses most of the information for himself but give access to clients if they are interested in the information/notes that are kept about their systems
  + in bh config, can use emporary publishing site for testing exports and validation :: see ==tmp== site which takes files from ==/tmp/publish== and exports them to a website publishing directory
    - makes it easy to try new throw-away things on a live server ::
  + setup for publishing project ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; experimenting with docbook exports - not finished
    (setq org-export-docbook-xsl-fo-proc-command "fop %s %s")
    (setq org-export-docbook-xslt-proc-command "xsltproc --output %s /usr/share/xml/docbook/stylesheet/nwalsh/fo/docbook.xsl %s")
    ;
    ; Inline images in HTML instead of producing links to the image
    (setq org-html-inline-images t)
    ; Do not use sub or superscripts - I currently don't need this functionality in my documents
    (setq org-export-with-sub-superscripts nil)
    ; Use org.css from the norang website for export document stylesheets
    ; note to me: are you not ashamed of yourself ? using work that's not yours without asking ?
    (setq org-html-head-extra "<link rel=\"stylesheet\" href=\"http://doc.norang.ca/org.css\" type=\"text/css\" />")
    (setq org-html-head-include-default-style nil)
    ; Do not generate internal css formatting for HTML exports
    (setq org-export-htmlize-output-type (quote css))
    ; Export with LaTeX fragments
    (setq org-export-with-LaTeX-fragments t)
    ; Increase default number of headings to export
    (setq org-export-headline-levels 6)
    
    ; List of projects
    ; norang       - http://www.norang.ca/
    ; doc          - http://doc.norang.ca/
    ; org-mode-doc - http://doc.norang.ca/org-mode.html and associated files
    ; org          - miscellaneous todo lists for publishing
    (setq org-publish-project-alist
          ;
          ; mine + bh configs [TO MODIFY]
          ; http://www.norang.ca/  (norang website)
          ; norang-org are the org-files that generate the content
          ; norang-extra are images and css files that need to be included
          ; norang is the top-level project that gets published
          (quote (("learnings-notes"
                   ; components root directory
                   :base-directory "~/Documents/repos/org/memacs/learnings"
    	       ; base extension files without the dot
                   :base-extension "org"
    	       ; base directory where files will be published
                   :publishing-directory "~/public_html/learnings"
    	       ; if 't', include subdirectories, subdirectories in:publishing-directory created if don't exist
                   :recursive t
    	       ; if and how org process files in component, here: convert org files to HTML
                   :publishing-function org-html-publish-to-html
                   ; :headline-levels 4 ; level of display in table of content, but not needed, default already set with 'org-export-headline-levels' to 6
                   :auto-preamble t
                   ; :auto-sitemap t ; Generate sitemap.org automagically
                   ; :sitemap-filename "sitemap.org" ; set sitemap name to sitemap.org, it's the default anyway
                   ; :sitemap-title "Sitemap" ; set title of sitemap to 'Sitemap', lol
    	       ; Don't include section numbers
                   :section-numbers nil
                   :style-include-default nil
    	       ; Don't include time stamp in file
                   :time-stamp-file nil
                   :html-head "<link rel=\"stylesheet\" href=\"norang.css\" type=\"text/css\" />"
                   :table-of-contents nil
                   :author-info nil
                   :creator-info nil)
                  ("learnings-static"
                   :base-directory "~/Documents/repos/org/memacs/learnings"
                   :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
                   :publishing-directory "~/public_html/"
                   :recursive t
                   :publishing-function org-publish-attachment)
                  ("learnings-project"
    	       :components ("learnings-notes" "learnings-static"))
                  ("norang-org"
                   :base-directory "~/git/www.norang.ca"
                   :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs"
                   :recursive t
                   :table-of-contents nil
                   :base-extension "org"
                   :publishing-function org-html-publish-to-html
                   :style-include-default nil
                   :section-numbers nil
                   :table-of-contents nil
                   :html-head "<link rel=\"stylesheet\" href=\"norang.css\" type=\"text/css\" />"
                   :author-info nil
                   :creator-info nil)
                  ("norang-extra"
                   :base-directory "~/git/www.norang.ca/"
                   :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs"
                   :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
                   :publishing-function org-publish-attachment
                   :recursive t
                   :author nil)
                  ("norang"
                   :components ("norang-org" "norang-extra"))
                  ; http://doc.norang.ca/  (norang website)
                  ; doc-org are the org-files that generate the content
                  ; doc-extra are images and css files that need to be included
                  ; doc is the top-level project that gets published
                  ("doc-org"
                   :base-directory "~/git/doc.norang.ca/"
                   :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
                   :recursive nil
                   :section-numbers nil
                   :table-of-contents nil
                   :base-extension "org"
                   :publishing-function (org-html-publish-to-html org-org-publish-to-org)
                   :style-include-default nil
                   :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
                   :author-info nil
                   :creator-info nil)
                  ("doc-extra"
                   :base-directory "~/git/doc.norang.ca/"
                   :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
                   :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
                   :publishing-function org-publish-attachment
                   :recursive nil
                   :author nil)
                  ("doc"
                   :components ("doc-org" "doc-extra"))
                  ("doc-private-org"
                   :base-directory "~/git/doc.norang.ca/private"
                   :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs/private"
                   :recursive nil
                   :section-numbers nil
                   :table-of-contents nil
                   :base-extension "org"
                   :publishing-function (org-html-publish-to-html org-org-publish-to-org)
                   :style-include-default nil
                   :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
                   :auto-sitemap t
                   :sitemap-filename "index.html"
                   :sitemap-title "Norang Private Documents"
                   :sitemap-style "tree"
                   :author-info nil
                   :creator-info nil)
                  ("doc-private-extra"
                   :base-directory "~/git/doc.norang.ca/private"
                   :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs/private"
                   :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
                   :publishing-function org-publish-attachment
                   :recursive nil
                   :author nil)
                  ("doc-private"
                   :components ("doc-private-org" "doc-private-extra"))
                  ;
                  ; Miscellaneous pages for other websites
                  ; org are the org-files that generate the content
                  ("org-org"
                   :base-directory "~/git/org/"
                   :publishing-directory "/ssh:www-data@www:~/org"
                   :recursive t
                   :section-numbers nil
                   :table-of-contents nil
                   :base-extension "org"
                   :publishing-function org-html-publish-to-html
                   :style-include-default nil
                   :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
                   :author-info nil
                   :creator-info nil)
                  ;
                  ; http://doc.norang.ca/  (norang website)
                  ; org-mode-doc-org this document
                  ; org-mode-doc-extra are images and css files that need to be included
                  ; org-mode-doc is the top-level project that gets published
                  ; This uses the same target directory as the 'doc' project
                  ("org-mode-doc-org"
                   :base-directory "~/git/org-mode-doc/"
                   :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
                   :recursive t
                   :section-numbers nil
                   :table-of-contents nil
                   :base-extension "org"
                   :publishing-function (org-html-publish-to-html)
                   :plain-source t
                   :htmlized-source t
                   :style-include-default nil
                   :html-head "<link rel=\"stylesheet\" href=\"/org.css\" type=\"text/css\" />"
                   :author-info nil
                   :creator-info nil)
                  ("org-mode-doc-extra"
                   :base-directory "~/git/org-mode-doc/"
                   :publishing-directory "/ssh:www-data@www:~/doc.norang.ca/htdocs"
                   :base-extension "css\\|pdf\\|png\\|jpg\\|gif\\|org"
                   :publishing-function org-publish-attachment
                   :recursive t
                   :author nil)
                  ("org-mode-doc"
                   :components ("org-mode-doc-org" "org-mode-doc-extra"))
                  ;
                  ; http://doc.norang.ca/  (norang website)
                  ; org-mode-doc-org this document
                  ; org-mode-doc-extra are images and css files that need to be included
                  ; org-mode-doc is the top-level project that gets published
                  ; This uses the same target directory as the 'doc' project
                  ("tmp-org"
                   :base-directory "/tmp/publish/"
                   :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs/tmp"
                   :recursive t
                   :section-numbers nil
                   :table-of-contents nil
                   :base-extension "org"
                   :publishing-function (org-html-publish-to-html org-org-publish-to-org)
                   :html-head "<link rel=\"stylesheet\" href=\"http://doc.norang.ca/org.css\" type=\"text/css\" />"
                   :plain-source t
                   :htmlized-source t
                   :style-include-default nil
                   :auto-sitemap t
                   :sitemap-filename "index.html"
                   :sitemap-title "Test Publishing Area"
                   :sitemap-style "tree"
                   :author-info t
                   :creator-info t)
                  ("tmp-extra"
                   :base-directory "/tmp/publish/"
                   :publishing-directory "/ssh:www-data@www:~/www.norang.ca/htdocs/tmp"
                   :base-extension "css\\|pdf\\|png\\|jpg\\|gif"
                   :publishing-function org-publish-attachment
                   :recursive t
                   :author nil)
                  ("tmp"
                   :components ("tmp-org" "tmp-extra")))))
    
    ; I'm lazy and don't want to remember the name of the project to publish when I modify
    ; a file that is part of a project.  So this function saves the file, and publishes
    ; the project that includes this file
    ;
    ; It's bound to C-S-F12 so I just edit and hit C-S-F12 when I'm done and move on to the next thing
    (defun bh/save-then-publish (&optional force)
      (interactive "P")
      (save-buffer)
      (org-save-all-org-buffers)
      (let ((org-html-head-extra)
            (org-html-validation-link "<a href=\"http://validator.w3.org/check?uri=referer\">Validate XHTML 1.0</a>"))
        (org-publish-current-project force)))
    
    (global-set-key (kbd "C-s-<f12>") 'bh/save-then-publish)
    #+end_src

*** Miscellaneous Export Settings
  + collection of export and publishing related settings for latex,  HTML without XML header, and others
**** HTML without XML header
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; remove xml header line for HTML exports
    ; the xml line confuses Open Office when opening the HTML to convert to ODT
    (setq org-html-xml-declaration (quote (("html" . "")
                                           ("was-html" . "<?xml version=\"1.0\" encoding=\"%s\"?>")
                                           ("php" . "<?php echo \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\"; ?>"))))
    #+end_src
**** Latex
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; for fontified listings from source blocks
    (setq org-latex-listings t)
    #+end_src
**** Allow binding variables on export without confirmation
  + setting to allows #+BIND: variables to be set on export without confirmation ::
    - rare usecase :: where needed to override some org-mode variable for export, the settings allows exporting the document without a prompt
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; to allow #+BIND: variables to be set on export without confirmation
    (setq org-export-allow-BIND t)
    #+end_src

** Setting reminders and appointments
  + use of appt for reminders
  + bh configs :: put pending appointments in the status bar and beeping as 12, 9, 6, 3, and 0 minutes before the appointment is due
  + everytime the agenda is displayed (try to do it as most as possible) :: the appointment list is erased and rebuilt from the current agenda details for today
    - hence :: everytime something that is time related is rescheduled (tasks is added or removed), the *appointment list is automatically updated* the next time the agenda is looked up
  + reminder setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; Erase all reminders and rebuilt reminders for today from the agenda
    (defun bh/org-agenda-to-appt ()
      (interactive)
      (setq appt-time-msg-list nil)
      (org-agenda-to-appt))
    
    ; Rebuild the reminders everytime the agenda is displayed
    (add-hook 'org-agenda-finalize-hook 'bh/org-agenda-to-appt 'append)
    
    ; This is at the end of my .emacs - so appointments are set up when Emacs starts
    (bh/org-agenda-to-appt)
    
    ; Activate appointments so we get notifications
    (appt-activate t)
    
    ; If we leave Emacs running overnight - reset the appointments one minute after midnight
    (run-at-time "24:01" nil 'bh/org-agenda-to-appt)
    #+end_src

** Productivity Tools
  + miscellaneous emacs tools for more productivity
*** Expand abbreviations into function template (with ==abbrev-mode== and ==skeletons==)
:PROPERTIES:
:CUSTOM_ID: abbr_func_templates
:END:
  + skeletons + abbrev-mode :: to quickly add preconfigured blocks to emacs edit buffers
  + eg blocks for creation ::
    - creating *generic blocks* in org-mode
    - creating *plantuml* blocks in org-mode
    - creating plantuml *activity* diagram block in org-mode
    - creating plantuml *sequence* diagram block in org-mode
    - creating *graphviz* dot blocks in org-mode
    - creating *ditaa* blocks in org-mode
    - creating *elisp* source blocks in org-mode
  + kbd and process ::
    - creating example blocks and simple shell script blocks that need no further parameters :: ==< e TAB== and ==< s TAB==
    - create plantuml bloc :: ==splantumlRET==
      + prompts for the filename (without extension) for the generated image file
    - create an abbreviation (for the mode currently in) :: ==[new_abbrev_short_form] C-x a i l== (type in the short form followed by ==C-x a i l==)
      + *careful* though, try not to use a common word for your abbreviation, since abbrev-mode will try to expand it everytime it is entered
	- eg with ==plantuml== that will expand when trying to use it as abbreviation
	- because of that, bh added the ==s== (src) prefix on the plantuml shortcut to prevent abbrev-mode from trying to expand PlantUML when typing it in
  + can even use skeletons and abbrev-mode on code source files to create custom blocks :: eg with c++ source files
  + with bh config, one can add a ==:tangle== header to the skeleton and explicitly include the ==@startuml== and ==@enduml== marker lines in the skeleton so one can tangle the source file and share it ::
    - this can for example make the tangled source useable in Notepad and the PlantUML jar file running standalone
  + for convenience, in activity diagrams, bh added ==sif== and ==sfor== and just change the labels for the synchronization bars:: 
  + can also use abbrev-mode when taking notes ::
    - for example, with bh configs, when using abbrev-mode in notes, when typing ==i== followed by the initials of people, it gets expanded to their complete name in notes
      + so, when writing ==imm==, it gets automatically expanded to ==Mickey Mouse== as being typed
  + setup :: 
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; Enable abbrev-mode
    (add-hook 'org-mode-hook (lambda () (abbrev-mode 1)))

    ;; Skeletons
    ;;
    ;; sblk - Generic block #+begin_FOO .. #+end_FOO
    (define-skeleton skel-org-block
      "Insert an org block, querying for type."
      "Type: "
      "#+begin_" str "\n"
      _ - \n
      "#+end_" str "\n")

    (define-abbrev org-mode-abbrev-table "sblk" "" 'skel-org-block)

    ;; splantuml - PlantUML Source block
    (define-skeleton skel-org-block-plantuml
      "Insert a org plantuml block, querying for filename."
      "File (no extension): "
      "#+begin_src plantuml :file " str ".png :cache yes\n"
      _ - \n
      "#+end_src\n")

    (define-abbrev org-mode-abbrev-table "splantuml" "" 'skel-org-block-plantuml)

    (define-skeleton skel-org-block-plantuml-activity
      "Insert a org plantuml block, querying for filename."
      "File (no extension): "
      "#+begin_src plantuml :file " str "-act.png :cache yes :tangle " str "-act.txt\n"
      (bh/plantuml-reset-counters)
      "@startuml\n"
      "skinparam activity {\n"
      "BackgroundColor<<New>> Cyan\n"
      "}\n\n"
      "title " str " - \n"
      "note left: " str "\n"
      "(*) --> \"" str "\"\n"
      "--> (*)\n"
      _ - \n
      "@enduml\n"
      "#+end_src\n")

    (defvar bh/plantuml-if-count 0)

    (defun bh/plantuml-if () 
      (incf bh/plantuml-if-count)
      (number-to-string bh/plantuml-if-count))

    (defvar bh/plantuml-loop-count 0)

    (defun bh/plantuml-loop () 
      (incf bh/plantuml-loop-count)
      (number-to-string bh/plantuml-loop-count))

    (defun bh/plantuml-reset-counters ()
      (setq bh/plantuml-if-count 0
            bh/plantuml-loop-count 0)
      "")

    (define-abbrev org-mode-abbrev-table "sact" "" 'skel-org-block-plantuml-activity)

    (define-skeleton skel-org-block-plantuml-activity-if
      "Insert a org plantuml block activity if statement"
      "" 
      "if \"\" then\n"
      "  -> [condition] ==IF" (setq ifn (bh/plantuml-if)) "==\n"
      "  --> ==IF" ifn "M1==\n"
      "  -left-> ==IF" ifn "M2==\n"
      "else\n"
      "end if\n"
      "--> ==IF" ifn "M2==")

    (define-abbrev org-mode-abbrev-table "sif" "" 'skel-org-block-plantuml-activity-if)

    (define-skeleton skel-org-block-plantuml-activity-for
      "Insert a org plantuml block activity for statement"
      "Loop for each: " 
      "--> ==LOOP" (setq loopn (bh/plantuml-loop)) "==\n"
      "note left: Loop" loopn ": For each " str "\n"
      "--> ==ENDLOOP" loopn "==\n"
      "note left: Loop" loopn ": End for each " str "\n" )

    (define-abbrev org-mode-abbrev-table "sfor" "" 'skel-org-block-plantuml-activity-for)

    (define-skeleton skel-org-block-plantuml-sequence
      "Insert a org plantuml activity diagram block, querying for filename."
      "File appends (no extension): "
      "#+begin_src plantuml :file " str "-seq.png :cache yes :tangle " str "-seq.txt\n"
      "@startuml\n"
      "title " str " - \n"
      "actor CSR as \"Customer Service Representative\"\n"
      "participant CSMO as \"CSM Online\"\n"
      "participant CSMU as \"CSM Unix\"\n"
      "participant NRIS\n"
      "actor Customer"
      _ - \n
      "@enduml\n"
      "#+end_src\n")

    (define-abbrev org-mode-abbrev-table "sseq" "" 'skel-org-block-plantuml-sequence)

    ;; sdot - Graphviz DOT block
    (define-skeleton skel-org-block-dot
      "Insert a org graphviz dot block, querying for filename."
      "File (no extension): "
      "#+begin_src dot :file " str ".png :cache yes :cmdline -Kdot -Tpng\n"
      "graph G {\n"
      _ - \n
      "}\n"
      "#+end_src\n")

    (define-abbrev org-mode-abbrev-table "sdot" "" 'skel-org-block-dot)

    ;; sditaa - Ditaa source block
    (define-skeleton skel-org-block-ditaa
      "Insert a org ditaa block, querying for filename."
      "File (no extension): "
      "#+begin_src ditaa :file " str ".png :cache yes\n"
      _ - \n
      "#+end_src\n")

    (define-abbrev org-mode-abbrev-table "sditaa" "" 'skel-org-block-ditaa)

    ;; selisp - Emacs Lisp source block
    (define-skeleton skel-org-block-elisp
      "Insert a org emacs-lisp block"
      ""
      "#+header: :tangle yes"
      "#+begin_src emacs-lisp\n"
      _ - \n
      "#+end_src\n")

    (define-abbrev org-mode-abbrev-table "selisp" "" 'skel-org-block-elisp)
    #+end_src

**** Example :: PlantUml Activity Diagram Generation
  + as said previously, when creating activity diagrams, one can use ==sif== and ==sfor== to add IF and FOR blocks to the diagram with unique numbering automatically generated
  + scenario :: create a new diagram and enter 2 IFs and 2 FOR blocks
  + process ::
    - create diagram :: ==sact RET test RET==
      + will generate ::
	#+begin_src plantuml :file test-act.png :cache yes :tangle test-act.txt :exports both
	@startuml
	skinparam activity {
	BackgroundColor<<New>> Cyan
	}
	
	title test - 
	note left: test
	(*) --> "test"
	--> (*)
	
	@enduml
	#+end_src
	
	#+results[941b135a91506a3806dcb1dcc07c18b23c0cd608]:
	[[file:images/test-act.png]]

      + when the cursor is put on --> (*) and one enters ==sif RET==, it will add the if condition and give ::
	#+begin_src plantuml :file test-act2.png :cache yes :tangle test-act2.txt :exports both
	@startuml
	skinparam activity {
	BackgroundColor<<New>> Cyan
	}
	
	title test - 
	note left: test
	(*) --> "test"
	if "" then
	  -> [condition] ==IF1==
	  --> ==IF1M1==
	  -left-> ==IF1M2==
	else
	end if
	--> ==IF1M2==
	--> (*)
	
	@enduml
	#+end_src
	
	#+results[0b3365856895b29376087110b72d8cd127d3b4f7]:
	[[file:images/test-act2.png]]

      + repeat on --> (*) line, will produce ::
	#+begin_src plantuml :file test-act3.png :cache yes :tangle test-act3.txt :exports both
	@startuml
	skinparam activity {
	BackgroundColor<<New>> Cyan
	}
	
	title test - 
	note left: test
	(*) --> "test"
	if "" then
	  -> [condition] ==IF1==
	  --> ==IF1M1==
	  -left-> ==IF1M2==
	else
	end if
	--> ==IF1M2==
	if "" then
	  -> [condition] ==IF2==
	  --> ==IF2M1==
	  -left-> ==IF2M2==
	else
	end if
	--> ==IF2M2==
	--> (*)
	
	@enduml
	#+end_src
	
	#+results[f1e8e6dfcb6cfc183b56196edb5769e53b7ad127]:
	[[file:images/test-act3.png]]

      + now, adding two for loops at the end with ==sfor RET line in file RET== and ==sfor RET address in addressbook RET== :: 
	#+begin_src plantuml :file test-act4.png :cache yes :tangle test-act4.txt :exports both
	@startuml
	skinparam activity {
	BackgroundColor<<New>> Cyan
	}
	
	title test - 
	note left: test
	(*) --> "test"
	if "" then
	  -> [condition] ==IF1==
	  --> ==IF1M1==
	  -left-> ==IF1M2==
	else
	end if
	--> ==IF1M2==
	if "" then
	  -> [condition] ==IF2==
	  --> ==IF2M1==
	  -left-> ==IF2M2==
	else
	end if
	--> ==IF2M2==
	--> ==LOOP1==
	note left: Loop1: For each line in file
	--> ==ENDLOOP1==
	note left: Loop1: End for each line in file
	--> ==LOOP2==
	note left: Loop2: For each address in addressbook
	--> ==ENDLOOP2==
	note left: Loop2: End for each address in addressbook
	
	--> (*)
	
	@enduml
	#+end_src

	#+results[dffc80c1690d0ffc945596218c6264aa99f52ec5]:
	[[file:images/test-act4.png]]

*** Focusing On Current Work (narrowing, filtering, and structuring agenda and agenda view)
**** Narrowing to a subtree with bh's ==bh/org-todo==
   + kbd ::
     - ==f5== and ==S-f5== (respectively) :: *narrowing* and *widening* the emacs buffer as defined below
       + ==T== (tasks) for ==C-c / t== on the current buffer
       + ==N== (narrow) narrows to this task subtree
       + ==U== (up) narrows to the immediate parent task subtree without moving
       + ==P== (project) narrows to the parent project subtree without moving
       + ==F== (file) narrows to the current file or file of the existing restriction
   + pros ::
     - makes it easy to hide all the other details in org-file temporarily by limiting view to this task subtree.
     - tasks are folded and highlighted so that only tasks which are incomplete are shown
   + tips ::
     - ==f5== (or the ==T== speed key) basically does a ==org-narrow-to-subtree== and ==C-c / t== combination leaving the buffer in a narrowed state
     - ==f5== (or some other widening speed key like ==U==, ==W==, ==F==) widens back to normal view
     - use of ==org-show-entry-below== to force showing the next headline, and prevent too many headlines from being folded together when working with collapsed trees ::
       #+header: :tangle yes
       #+begin_src emacs-lisp
       ; force showing the next headline, and prevent too many headlines from being folded together when working with collapsed trees (see section 'Focusing On Current Work')
       (setq org-show-entry-below (quote ((default))))
       #+end_src
   + setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; setups for 'Focusing On Current Work'
     ; (global-set-key (kbd "<f5>") 'bh/org-todo) ;; already set above
    
     (defun bh/org-todo (arg)
       (interactive "p")
       (if (equal arg 4)
           (save-restriction
             (bh/narrow-to-org-subtree)
             (org-show-todo-tree nil))
         (bh/narrow-to-org-subtree)
         (org-show-todo-tree nil)))
    
     ; (global-set-key (kbd "<S-f5>") 'bh/widen) ;; also already set above
    
     (defun bh/widen ()
       (interactive)
       (if (equal major-mode 'org-agenda-mode)
           (progn
             (org-agenda-remove-restriction-lock)
             (when org-agenda-sticky
               (org-agenda-redo)))
         (widen)))
    
     (add-hook 'org-agenda-mode-hook
               '(lambda () (org-defkey org-agenda-mode-map "W" (lambda () (interactive) (setq bh/hide-scheduled-and-waiting-next-tasks t) (bh/widen))))
               'append)
    
     (defun bh/restrict-to-file-or-follow (arg)
       "Set agenda restriction to 'file or with argument invoke follow mode.
     I don't use follow mode very often but I restrict to file all the time
     so change the default 'F' binding in the agenda to allow both"
       (interactive "p")
       (if (equal arg 4)
           (org-agenda-follow-mode)
         (widen)
         (bh/set-agenda-restriction-lock 4)
         (org-agenda-redo)
         (beginning-of-buffer)))
    
     (add-hook 'org-agenda-mode-hook
               '(lambda () (org-defkey org-agenda-mode-map "F" 'bh/restrict-to-file-or-follow))
               'append)
    
     (defun bh/narrow-to-org-subtree ()
       (widen)
       (org-narrow-to-subtree)
       (save-restriction
         (org-agenda-set-restriction-lock)))
    
     (defun bh/narrow-to-subtree ()
       (interactive)
       (if (equal major-mode 'org-agenda-mode)
           (progn
             (org-with-point-at (org-get-at-bol 'org-hd-marker)
               (bh/narrow-to-org-subtree))
             (when org-agenda-sticky
               (org-agenda-redo)))
         (bh/narrow-to-org-subtree)))
    
     (add-hook 'org-agenda-mode-hook
               '(lambda () (org-defkey org-agenda-mode-map "N" 'bh/narrow-to-subtree))
               'append)
    
     (defun bh/narrow-up-one-org-level ()
       (widen)
       (save-excursion
         (outline-up-heading 1 'invisible-ok)
         (bh/narrow-to-org-subtree)))
    
     (defun bh/get-pom-from-agenda-restriction-or-point ()
       (or (and (marker-position org-agenda-restrict-begin) org-agenda-restrict-begin)
           (org-get-at-bol 'org-hd-marker)
           (and (equal major-mode 'org-mode) (point))
           org-clock-marker))
    
     (defun bh/narrow-up-one-level ()
       (interactive)
       (if (equal major-mode 'org-agenda-mode)
           (progn
             (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
               (bh/narrow-up-one-org-level))
             (org-agenda-redo))
         (bh/narrow-up-one-org-level)))
    
     (add-hook 'org-agenda-mode-hook
               '(lambda () (org-defkey org-agenda-mode-map "U" 'bh/narrow-up-one-level))
               'append)
    
     (defun bh/narrow-to-org-project ()
       (widen)
       (save-excursion
         (bh/find-project-task)
         (bh/narrow-to-org-subtree)))
    
     (defun bh/narrow-to-project ()
       (interactive)
       (if (equal major-mode 'org-agenda-mode)
           (progn
             (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
               (bh/narrow-to-org-project)
               (save-excursion
                 (bh/find-project-task)
                 (org-agenda-set-restriction-lock)))
             (org-agenda-redo)
             (beginning-of-buffer))
         (bh/narrow-to-org-project)
         (save-restriction
           (org-agenda-set-restriction-lock))))
    
     (add-hook 'org-agenda-mode-hook
               '(lambda () (org-defkey org-agenda-mode-map "P" 'bh/narrow-to-project))
               'append)
    
     (defvar bh/project-list nil)
    
     (defun bh/view-next-project ()
       (interactive)
       (let (num-project-left current-project)
         (unless (marker-position org-agenda-restrict-begin)
           (goto-char (point-min))
           ; Clear all of the existing markers on the list
           (while bh/project-list
             (set-marker (pop bh/project-list) nil))
           (re-search-forward "Tasks to Refile")
           (forward-visible-line 1))
    
         ; Build a new project marker list
         (unless bh/project-list
           (while (< (point) (point-max))
             (while (and (< (point) (point-max))
                         (or (not (org-get-at-bol 'org-hd-marker))
                             (org-with-point-at (org-get-at-bol 'org-hd-marker)
                               (or (not (bh/is-project-p))
                                   (bh/is-project-subtree-p)))))
               (forward-visible-line 1))
             (when (< (point) (point-max))
               (add-to-list 'bh/project-list (copy-marker (org-get-at-bol 'org-hd-marker)) 'append))
             (forward-visible-line 1)))
    
         ; Pop off the first marker on the list and display
         (setq current-project (pop bh/project-list))
         (when current-project
           (org-with-point-at current-project
             (setq bh/hide-scheduled-and-waiting-next-tasks nil)
             (bh/narrow-to-project))
           ; Remove the marker
           (setq current-project nil)
           (org-agenda-redo)
           (beginning-of-buffer)
           (setq num-projects-left (length bh/project-list))
           (if (> num-projects-left 0)
               (message "%s projects left to view" num-projects-left)
             (beginning-of-buffer)
             (setq bh/hide-scheduled-and-waiting-next-tasks t)
             (error "All projects viewed.")))))
    
     (add-hook 'org-agenda-mode-hook
               '(lambda () (org-defkey org-agenda-mode-map "V" 'bh/view-next-project))
               'append)
     #+end_src

**** Limiting the agenda to a subtree
   + kbd ::
     - ==C-c C-x <== to turn on the agenda restriction lock on the current subtree :: keeps agenda focused on only current subtree
       + alarms and notifications are still active outside the agenda restriction ::
     - ==C-c C-x >== to turn off the agenda restriction lock, and return agenda view back to normal ::
     - ==N== narrows to the current task subtree :: this is the same as same as ==C-c C-x <==
     - ==U== narrows to the parent subtree of this task :: goes up one level and narrows to that subtree
     - ==P== narrows to the entire project containing this task :: goes up the tree to the top-level ==TODO== keyword and selects that as the subtree to narrow to
     - ==W== removes the restriction :: widens the buffer
   + notes ::
     - limiting allows to set the restriction lock from agenda *to task directly* (instead of automatically moving up the tree to the project level task)
     - can easily move the *restriction lock up a level* by visiting the task in the org file *and going up and resetting the lock* (in case one wants to see how the project is moving)
     - since sometimes an entire *project can have too many tasks* in it, and one wants to *limit the view* to part of the subtree, it's possible to use ==N== and ==U== key bindings to adjust the narrowed region
     - the keybinds set by bh (see 'kbd' next) can be used to restrict the *agenda*, and *org-buffer* to *subtree, parent task, and project task*, as well as *remove the restriction*
       + hence, these *keys work both* in the *agenda* and as speed commands *on a headline* in the org-file
     - restriction kbds ::
       + ==N== narrows to the current task subtree :: this is the same as same as ==C-c C-x <==
       + ==U== narrows to the parent subtree of this task :: goes up one level and narrows to that subtree
       + ==P== narrows to the entire project containing this task :: goes up the tree to the top-level ==TODO== keyword and selects that as the subtree to narrow to
       + ==W== removes the restriction :: widens the buffer
   + bh added key bindings for the agenda to allow using ==C-c C-x <== in the agenda to set the restriction lock to the current task directly ::
     - that is done with the following setup ::
       #+header: :tangle yes
       #+begin_src emacs-lisp
       ; setups for 'Limiting the agenda to a subtree'
       (add-hook 'org-agenda-mode-hook
                 '(lambda () (org-defkey org-agenda-mode-map "\C-c\C-x<" 'bh/set-agenda-restriction-lock))
                 'append)
      
       (defun bh/set-agenda-restriction-lock (arg)
         "Set restriction lock to current task subtree or file if prefix is specified"
         (interactive "p")
         (let* ((pom (bh/get-pom-from-agenda-restriction-or-point))
		(tags (org-with-point-at pom (org-get-tags-at))))
           (let ((restriction-type (if (equal arg 4) 'file 'subtree)))
             (save-restriction
               (cond
		((and (equal major-mode 'org-agenda-mode) pom)
                 (org-with-point-at pom
                   (org-agenda-set-restriction-lock restriction-type))
                 (org-agenda-redo))
		((and (equal major-mode 'org-mode) (org-before-first-heading-p))
                 (org-agenda-set-restriction-lock 'file))
		(pom
                 (org-with-point-at pom
                   (org-agenda-set-restriction-lock restriction-type))))))))
       #+end_src
   + set restrictions highlighting to only affect the headline (headings) and not the entire body of the agenda restriction ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ;; Limit restriction lock highlighting to the headline only
     (setq org-agenda-restriction-lock-highlight-subtree nil)
     #+end_src

**** Limiting the agenda to a file
   + limit agenda view to one file ::
     - use the agenda restriction lock to set the agenda restriction lock to this file only ::
       + on any line /before the first heading/ :: ==C-c C-x <==
       + from anywhere in the file, using prefix ==C-u== :: ==C-u C-c C-x <==
       + lock stays in effect until removed with :: ==C-c C-x >==
     - same, lock to file, but from the agenda :: ==C-u C-c c-x <==
     - by visiting org-file, and invoking agenda with :: ==F12 < a==
       + can be used, to view in the agenda, a file not in ==org-agenda-files==

*** Tuning further the Agenda Views
**** Highlight the current agenda line
   + keeping the current agenda line highlighted helps to know what task will be affected by commands issued in the agenda, and avoid acting on the wrong task by mistake
   + settings also make clock modeline time shown with a reverse background
   + setups ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ;; Always highlight the current agenda line
     (add-hook 'org-agenda-mode-hook
               '(lambda () (hl-line-mode 1))
               'append)
    
    
     ;; The following custom-set-faces create the highlights
     (custom-set-faces
       ;; custom-set-faces was added by Custom.
       ;; If you edit it by hand, you could mess it up, so be careful.
       ;; Your init file should contain only one such instance.
       ;; If there is more than one, they won't work right.
      '(org-mode-line-clock ((t (:background "grey75" :foreground "red" :box (:line-width -1 :style released-button)))) t))
     #+end_src

**** Keep tasks with timestamps visible on the global todo lists
   + context ::
     - Tasks with dates (==SCHEDULED:==, ==DEADLINE:==, or active dates) show up in the agenda when appropriate. The block agenda view (==F12 a==) tries to keep tasks showing up only in one location (either in the calendar or other todo lists in later sections of the block agenda.)
     - one needs to use global todo list search in org-mode (==F12 t==, ==F12 m==) if he is looking for a specific task
     - with bh configs, the todo lists include _everything_ so one can just search for a needed item and move on
   + the block agenda prevents display of tasks with deadlines or scheduled dates in the future, so those can safely be ignored until appropriate time
   + setup :: 
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ;; Keep tasks with dates on the global todo lists
     (setq org-agenda-todo-ignore-with-date nil)
    
     ;; Keep tasks with deadlines on the global todo lists
     (setq org-agenda-todo-ignore-deadlines nil)
    
     ;; Keep tasks with scheduled dates on the global todo lists
     (setq org-agenda-todo-ignore-scheduled nil)
    
     ;; Keep tasks with timestamps on the global todo lists
     (setq org-agenda-todo-ignore-timestamp nil)
    
     ;; Remove completed deadline tasks from the agenda view
     (setq org-agenda-skip-deadline-if-done t)
    
     ;; Remove completed scheduled tasks from the agenda view
     (setq org-agenda-skip-scheduled-if-done t)
    
     ;; Remove completed items from search results
     (setq org-agenda-skip-timestamp-if-done t)
     #+end_src

**** Use the Diary for Holidays and Appointments
   + remove use of emacs diary (can unset it if need of a diary), and set a 'diary' file that really contains important dates (holidays, appointments, etc.) ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; setups for 'Use the Diary for Holidays and Appointments'
     (setq org-agenda-include-diary nil)
     (setq org-agenda-diary-file "~/Documents/repos/org/memacs/GTD/diary.org")
     #+end_src
   + this diary file keeps ==date-tree== entries created by the capture mode 'appointment' template ::
     - can also be used for miscellaneous tasks needed to be clocked during interruptions
   + instead of emacs diary, bh uses org-mode's /diary functions/ ::
     - inserting entries with ==i== in the emacs agenda creates date entries in ~/Documents/repos/org/memacs/GTD/diary.org
     - eg ::
       + include holidays from the calendar in todo.org file ::
	 #+begin_src org :exports src
	 ,#+FILETAGS: PERSONAL
	 ,* Appointments
           :PROPERTIES:
           :CATEGORY: Appt
           :ARCHIVE:  %s_archive::* Appointments
           :END:      
	 ,** Holidays
            :PROPERTIES:
            :Category: Holiday
            :END:
            %%(org-calendar-holiday)
	 ,** Some other Appointment
            ...
	 #+end_src
   + setting for any time strings in the heading to be showned in the agenda ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; for any time strings in the heading to be showned in the agenda
     (setq org-agenda-insert-diary-extract-time t)
     #+end_src

**** Set searches to include archive files
   + tip : keep a single archive file for each org-mode project files :: allows searching the current file and the archive when need to dig up old information from the archives
   + setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ;; Include agenda archive files when searching for things
     (setq org-agenda-text-search-extra-files (quote (agenda-archives)))
     #+end_src

**** Agenda view tweaks
   + tweaks for agenda customizations to control ::
     - display of repeating tasks
     - display of empty dates on the agenda
     - task sort order
     - start the agenda weekly view with Sunday
     - display of the grid
     - habits at the bottom
   + bh customized a sorting function so that the daily agenda lists tasks in order of importance, with the following order ::
     1. tasks with times at the top so they are hard to miss
     2. entries for today (active timestamp headlines that are not scheduled or deadline tasks)
     3. deadlines due today
     4. late deadline tasks
     5. scheduled items for today
     6. pending deadlines (due soon)
     7. late scheduled items
     8. habits
   + setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ;; Show all future entries for repeating tasks
     (setq org-agenda-repeating-timestamp-show-all t)
    
     ;; Show all agenda dates - even if they are empty
     (setq org-agenda-show-all-dates t)
    
     ;; Sorting order for tasks on the agenda
     (setq org-agenda-sorting-strategy
           (quote ((agenda habit-down time-up user-defined-up effort-up category-keep)
                   (todo category-up effort-up)
                   (tags category-up effort-up)
                   (search category-up))))
    
     ;; Start the weekly agenda on Monday
     (setq org-agenda-start-on-weekday 1)
    
     ;; Enable display of the time grid so we can see the marker for the current time
     (setq org-agenda-time-grid (quote ((daily today remove-match)
					#("----------------" 0 16 (org-heading t))
					(0900 1100 1300 1500 1700))))
    
     ;; Display tags farther right
     (setq org-agenda-tags-column -102)
    
     ;;
     ;; Agenda sorting functions
     ;;
     (setq org-agenda-cmp-user-defined 'bh/agenda-sort)
    
     (defun bh/agenda-sort (a b)
       "Sorting strategy for agenda items.
     Late deadlines first, then scheduled, then non-late deadlines"
       (let (result num-a num-b)
         (cond
          ; time specific items are already sorted first by org-agenda-sorting-strategy
    
          ; non-deadline and non-scheduled items next
          ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))
    
          ; deadlines for today next
          ((bh/agenda-sort-test 'bh/is-due-deadline a b))
    
          ; late deadlines next
          ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))
    
          ; scheduled items for today next
          ((bh/agenda-sort-test 'bh/is-scheduled-today a b))
    
          ; late scheduled items next
          ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))
    
          ; pending deadlines last
          ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))
    
          ; finally default to unsorted
          (t (setq result nil)))
         result))
    
     (defmacro bh/agenda-sort-test (fn a b)
       "Test for agenda sort"
       `(cond
         ; if both match leave them unsorted
         ((and (apply ,fn (list ,a))
               (apply ,fn (list ,b)))
          (setq result nil))
         ; if a matches put a first
         ((apply ,fn (list ,a))
          (setq result -1))
         ; otherwise if b matches put b first
         ((apply ,fn (list ,b))
          (setq result 1))
         ; if none match leave them unsorted
         (t nil)))
    
     (defmacro bh/agenda-sort-test-num (fn compfn a b)
       `(cond
         ((apply ,fn (list ,a))
          (setq num-a (string-to-number (match-string 1 ,a)))
          (if (apply ,fn (list ,b))
              (progn
		(setq num-b (string-to-number (match-string 1 ,b)))
		(setq result (if (apply ,compfn (list num-a num-b))
                                 -1
                               1)))
            (setq result -1)))
         ((apply ,fn (list ,b))
          (setq result 1))
         (t nil)))
    
     (defun bh/is-not-scheduled-or-deadline (date-str)
       (and (not (bh/is-deadline date-str))
            (not (bh/is-scheduled date-str))))
    
     (defun bh/is-due-deadline (date-str)
       (string-match "Deadline:" date-str))
    
     (defun bh/is-late-deadline (date-str)
       (string-match "\\([0-9]*\\) d\. ago:" date-str))
    
     (defun bh/is-pending-deadline (date-str)
       (string-match "In \\([^-]*\\)d\.:" date-str))
    
     (defun bh/is-deadline (date-str)
       (or (bh/is-due-deadline date-str)
           (bh/is-late-deadline date-str)
           (bh/is-pending-deadline date-str)))
    
     (defun bh/is-scheduled (date-str)
       (or (bh/is-scheduled-today date-str)
           (bh/is-scheduled-late date-str)))
    
     (defun bh/is-scheduled-today (date-str)
       (string-match "Scheduled:" date-str))
    
     (defun bh/is-scheduled-late (date-str)
       (string-match "Sched\.\\(.*\\)x:" date-str))
     #+end_src

**** Sticky Agendas
   + Sticky agendas :: allows someone to have more than one agenda view created simultaneously
     - can quickly switch to the other view without incurring an agenda rebuild by invoking the agenda custom command key that normally generates the agenda
     - if it already exists it will display the existing view
     - can force the regeneration of the agenda view with ==g==
   + eg, and kbd :: can display two views :
     - ==F12 a==  for the daily/weekly agenda ::
     - ==F12 SPC== for a project management view ::
   + setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ;; Use sticky agenda's so they persist
     (setq org-agenda-sticky t)
     #+end_src

*** Handling checklists
   + checklists :: great for repeated tasks with lots of things that need to be done
     - for repeating tasks, instead of manually resetting the checklists when the task is ==DONE==, ==org-checklist== can automatically uncheck the boxes when the task is marked done ::
   + setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; setup for handling checklists
     ; load org-checklist.el from org-contrib
     (add-to-list 'load-path (expand-file-name "~/Documents/repos/opt/org-mode/org-contrib/lisp"))
    
     (require 'org-checklist)
     #+end_src
   + use in a task :: simply set the property ==RESET_CHECK_BOXES== to ==t== :
     #+begin_src org :exports src
     ,* TODO Invoicing and Archive Tasks [0/7]
       DEADLINE: <2009-07-01 Wed +1m -0d> 
       :PROPERTIES:
       :RESET_CHECK_BOXES: t
       :END:
    
       - [ ] Do task 1
       - [ ] Do task 2
       ...
       - [ ] Do task 7
     #+end_src

*** Dealing with blocked tasks
   + reminder: blocked tasks :: tasks that have subtasks which are not in a done todo state
     - with bh config :: blocked tasks show up in a grayed font by default in the agenda
   + to enforce entries to not get ==DONE== while some tasks are in blocked state ::
     - plus, if an entry has a property ==ORDERED==, each of its TODO children is *blocked* until *all earlier siblings* are marked as done
   + enable tasks blocking ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; enable tasks blocking
     (setq org-enforce-todo-dependencies t)
     #+end_src
   + enable tasks blocking with ==ORDERED== property on subtasks, eg ::
     #+begin_src org :exports src
     ,* TODO Some Task
       :PROPERTIES:
       :ORDERED: t
       :END:
     ,** TODO Step 1
     ,** TODO Step 2, needs to wait for Step 1
     ,** TODO Step 3, needs to wait for Step 1 and Step 2  
     #+end_src
   + enable tasks blocking for repeating tasks ::
     - does not work well for repeating tasks where not all of the subtasks need to be complete before the next repeat cycle
       + workaround :: set a permanent property on repeating tasks by overriding the blocking setting :
	 #+begin_src org :exports src
	 ,* TODO New Repeating Task
	   SCHEDULED: <2009-06-16 Tue +1w>
	   :PROPERTIES:
	   :NOBLOCKING: t
	   :END:
	   ...
	 ,** TODO Subtask  
	 #+end_src
       + the property above prevents ==New Repeating Task== from being blocked if some of the items under it are not complete :: 

*** Org Task structure and presentation (to control how tasks are displayed while working on org-mode files)
**** org-indent mode
   + org-indent removes indentation in org-file on lines that are not headlines, and displays prefixed them with virtual space as if they were indented to vertically align with the headline text
   + turn on ==org-indent== at startup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; turn on ==org-indent== at startup
     (setq org-startup-indented t)
     #+end_src

**** Handling blank lines
   + automatically *hide* blank lines between headlines while (un)folding ((un)collapse) headlines (with ==TAB==) ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; automatically *hide* blank lines between headlines while (un)folding ((un)collapse) headlines (with ==TAB==)
     (setq org-cycle-separator-lines 0)
     #+end_src
   + prevent creating blank lines before headings, but allow list items to adapt to existing blank lines around the items ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; prevent creating blank lines before headings, but allow list items to adapt to existing blank lines around the items
     (setq org-blank-before-new-entry (quote ((heading)
                                              (plain-list-item . auto))))
     #+end_src

**** Adding new tasks quickly without disturbing the current task content
   + fast insertion of new headings in a project (possibly with a ==TODO== keyword) with :: ==C-RET==, ==C-S-RET==, ==M-RET==, and ==M-S-RET== :
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; fast insertion of new headings in a project (possibly with a ==TODO== keyword) with :: ==C-RET==, ==C-S-RET==, ==M-RET==, and ==M-S-RET==
     (setq org-insert-heading-respect-content nil)
     #+end_src
   + ==C-== vs ==M-== ::
     + for the ==C-== version :: org respects the content (adds the new heading after the content of the current item)
       - when entering ==C-S-RET== in the middle of an entry :: the new heading is added after the body of the current entry
     + for the ==M-== version :: org inserts the heading at point
       - with ==M-S-RET== :: can split an entry in the middle

**** Notes at the top
   + kbd ::
     - entering notes :: ==C-c C-z==
       + entering notes *in the agenda* :: ==z==
   + changing tasks states can also prompt for a note (e.g. moving to ==WAITING== prompts for a note, then enter reason why task is waiting) ::
     - these notes are saved at the top of the task so *unfolding the task shows the note first* :: 
   + setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; so that unfolding the task shows the notes first
     (setq org-reverse-note-order nil)
     #+end_src

**** Showing results of searches
   + reminder ::
     - regex search on current file of *all* matching results in a collapsed view :: ==C-c / /==
   + with bh settings ::
     - org-mode show the hierarchy of tasks above the matched entries and also the immediately following sibling task (but not all siblings) ::
       + advantage :: compact display, and mitigates accidental errors by cutting too much data from org file with ==C-k== for example (cutting folded data (including the …) cuts text, including following hidden uncollapsed subtrees)
     - setup ::
       #+header: :tangle yes
       #+begin_src emacs-lisp
       (setq org-show-following-heading t)
       (setq org-show-hierarchy-above t)
       (setq org-show-siblings (quote ((default))))
       #+end_src

**** Editing and Special key handling
   + notes ::
     - org-mode allows special handling of the ==C-a==, ==C-e==, and ==C-k== keys when editing headlines
     - plus, can also use the setting that yanks (pastes) subtrees and adjusts the levels to match the task where pasting to (see the docstring (==C-h v org-yank-adjust-subtrees==) for more details on each variable and what it does).
     - settings ::
       + ==org-special-ctrl-a/e== :: to enable special easy access to the beginning and end of headlines
	 - can use ==M-m== or ==C-a C-a== to get to the beginning of the line so the speed commands work
	 - and ==C-a== to give easy access to the beginning of the heading text when needed
       + setups ::
         #+header: :tangle yes
         #+begin_src emacs-lisp
         (setq org-special-ctrl-a/e t)
         (setq org-special-ctrl-k t)
         (setq org-yank-adjusted-subtrees t)
         #+end_src

*** Deadlines and Agenda Visibility
   + set as default to see deadlines and due dates in the agenda 30 days before the due date :: to prepare for the task so that it is completed on or before the due date
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq org-deadline-warning-days 30)
     #+end_src
   + can also use deadlines for repeating tasks ::
     - if the task repeats more often than once per month, could always keep bugging on the agenda view
     - can adapt to repeating tasks more often by setting directly on the property an explicit deadline warning date ::
       + setup ::
	 #+begin_src org :exports src
	 ,* TODO Pay Wages
	   DEADLINE: <2009-07-01 Wed +1m -0d>   
	 #+end_src
       + in example :: the task repeats monthly and shows up in the agenda on the day it is due (with no prior warning)
     - can set any number of lead days on ==DEADLINES== using ==-Nd== where N is the number of days in advance the task should show up in the agenda
     - if no value is specified the default ==org-deadline-warning-days== is used

*** Logging
   + logging setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ;; my version
     ;; keep track of when a todo item was done => when toggled to done, a line ‘CLOSED: [timestamp]’ is inserted just after the headline
     (setq org-log-done (quote ((time)
				(note))))  ;; to record a note along with the timestamp
     ;; bh version
     ;; (setq org-log-done (quote time))
     (setq org-log-into-drawer t)
     (setq org-log-state-notes-insert-after-drawers nil)
     #+end_src
   + from ==org-todo-keywords== (configs in section [[#ToDokeywords][Org Mode TODO states, triggers, and project definition]]), with logging settings, a log entry is added whenever a task moves to any of the following states ::
     - to or out of ==DONE== status
     - to ==WAITING== status (with a note) or out of ==WAITING== status
     - to ==HOLD== status
     - to ==CANCELLED== status (with a note) or out of ==CANCELLED== status
   + clock times and states are kept in the ==LOGBOOK== drawer to keep tasks uncluttered ::
     - eg ::
       + if a task is ==WAITING== then the reason why is near the top of the ==LOGBOOK==, and unfolding the ==LOGBOOK== drawer provides that information
       + from the agenda, simply hitting ==SPC== on the task will reveal the ==LOGBOOK== drawer

*** Limiting time spent on tasks
   + notes ::
     - org-mode has this great feature for signalling alarms *when the estimated time for a task is reached*
     - can be used to limit the amount of time spent on a task (during the day for example)
   + eg ::
     - suppose clocked on a task estimated at 1h ::
       #+begin_src org :exports src
       ,* NEXT Document my use of org-mode
         :LOGBOOK:...
         :PROPERTIES:
         :CLOCK_MODELINE_TOTAL: today
         :Effort:   1:00
         :END:  
       #+end_src
     - when clocked in, the task shows the total in the mode-line as follows :: (35 minutes out of estimated 1 hour so far)
       : --:**  org-mode.org   91% (2348,73) Git:master  (Org Fly yas Font)-----[0:35/1:00 (Document my use of org-mode)]-------
     - alarm sets off + message stating to be done working on this task :: 
   + if one switches task, and try to clock in on clock limited task again, the sound goes off each and every time the task is clocked on :: incentive to work on something else :-)
   + set up alarm for when effort limit is passed (will show a message too) ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq org-clock-sound "/usr/local/lib/mechanicus-Children_of_the_Omnissiah.mp3")
     #+end_src
   + similar setups for repeated tasks ::
     - by default the last repeat time is recorded as a property when a repeating task is marked done
     - for repeating tasks, the mode-line clock total counts since the last repeat time by default. This lets one accumulate time over multiple days and counts towards estimated effort limit

*** Habits and org-mode
**** Habit Tracking
   + notes ::
     - try to develop habits, good for health
     - logging of ==DONE== states habits need to be enabled for habit tracking
     - a habit is just like a regular task except it has a special ==PROPERTY== value setting and a special ==SCHEDULED== date entry for example like this ::
       + example ::
	 #+begin_src org :exports src
	 ,* TODO Update Org Mode Doc
	   SCHEDULED: <2009-11-21 Sat .+7d/30d>
	   [2009-11-14 Sat 11:45]
	   :PROPERTIES:
	   :STYLE: habit
	   :END:  
	 #+end_src
       + the property marks the task as a habit and separates it from the regular task display on the agenda
       + can use the special ==SCHEDULED== entry to state that one wants to do this every day, but at least every 2 days
	 - if 3 days go without marking it ==DONE==, it shows up RED on the agenda indicating that the habit has been neglected
       + when a habit is ==DONE==, it shows up on the daily agenda the next time based on the first interval in the ==SCHEDULED== entry (==.+7d== in previous example)
	 - the period (==.xd==), indicates that the task will reschedule the item x days after it is completed
       + in case of delay, one can hide and display habits quickly using the ==K== key on the agenda
   + kbd ::
     - hide/display habits on the agenda :: ==K==
   + settings for habit tracking :: 
     #+header: :tangle yes
     #+begin_src emacs-lisp
     ; Enable habit tracking (and a bunch of other modules)
     (setq org-modules (quote (org-bbdb
                               org-bibtex
                               org-crypt
                               org-gnus
                               org-id
                               org-info
                               org-jsinfo
                               org-habit
                               org-inlinetask
                               org-irc
                               org-mew
                               org-mhe
                               org-protocol
                               org-rmail
                               org-vm
                               org-wl
                               org-w3m)))
    
     ; position the habit graph on the agenda to the right of the default
     (setq org-habit-graph-column 50)
     #+end_src
   + recommended process ::
     - during the day and when not needed, turn off the habit display in the agenda with ==K==
       + and if kept Emacs running for days at a time, habits display don't come back
     - but, to make sure that habits are displayed daily, one can have settings to redisplay the habits in the agenda each day
     - eg, the following turns the habit display on again at 6AM each morning ::
       #+header: :tangle yes
       #+begin_src emacs-lisp
       (run-at-time "06:00" 86400 '(lambda () (setq org-habit-show-habits t)))
       #+end_src

**** Habits: only log ==DONE== state changes
   + tips ::
     - keep habits under a level 1 task ==* Habits== with a special logging property that only logs changes to ==DONE== state
       + this allows cancelling a habit and not record a timestamp for it and mess up the habit graph
	 - cancelling a habit just to get it off the agenda since for example it's undoable (like get up before 6AM) should not mark the habit as done today
	 - should only cancel habits that repeat every day
     - prefer having one habit heading in every org file that can have habits defined
   + example :: 
     #+begin_src org :exports src
     ,* Habits
       :PROPERTIES:
       :LOGGING:  DONE(!)
       :ARCHIVE:  %s_archive::* Habits
       :END:  
     #+end_src

*** Minimizing number of Emacs Frames
   + goal :: minimize the number of frames opened when opening links
     - or in order words, to replace the current window with the new content
   + setup to open link into the same window ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq org-link-frame-setup (quote ((vm . vm-visit-folder)
                                    (gnus . org-gnus-no-new-news)
                                    (file . find-file))))

     ; Use the current window for C-c ' source editing
     (setq org-src-window-setup 'current-window)
     #+end_src
   + process for when working on multiple files ::
     - manually create the second frame :: ==C-x 5 2==
       + or split the window :: ==C-x 4 2== or ==C-X 4 3==

*** Auto revert mode
   + notes ::
     - need :: when for example one needs to synchronize org-mode files between different machines (eg: laptop and workstation)
       + not easy scenario with git ::
	 1. save all latest changes
	 2. push to a bare repo
	 3. fetch on the other system
	 4. revert all org-mode files to get the updated information
     - easier alternative with ==global-auto-revert-mode== ::
       + this automatically reverts the buffer when its visited file changes on disk
       + ==global-auto-revert-mode== does that for all file buffers
     - with the setting :: any files that change on disk, where there are no changes in the buffer, automatically revert to the on-disk version
       + great for synchronizing org-mode files between systems
       + saves step 4. above
       + auto revert will not revert a buffer if it has unsaved changes, or if its file on disk is deleted or renamed
   + activate setup :: 
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (global-auto-revert-mode t)
     #+end_src

*** org-mode and encryption
**** Handling encryption
   + notes ::
     - instead of using encryption wallets to store passwords, one can keep them in org-mode files with special tags
     - encrypted data will be kept in the org-mode file associated with the raw file
   + ==org-crypt== allows tag headings with a special tag ==crypt==, and org-mode can keep data in these headings encrypted when saved to disk
     - can decrypt the heading temporarily when need access to the data and org-mode re-encrypts the heading as soon as you save the file
     - any text below a headline that has a ==crypt== tag is automatically encrypted when the file is saved
       + to use a different tag, can customize the ==org-crypt-tag-matcher== setting
   + setups ::
     - source :: official org-mode documentation (https://orgmode.org/manual/Org-Crypt.html)
       #+header: :tangle yes
       #+begin_src emacs-lisp
       (require 'org-crypt)
       (org-crypt-use-before-save-magic)
       (setq org-tags-exclude-from-inheritance '("crypt"))
      
       ;(setq org-crypt-key nil)
       ;; GPG key to use for encryption.
       ;; nil means  use symmetric encryption unconditionally.
       ;; "" means use symmetric encryption unless heading sets CRYPTKEY property.
      
       (setq auto-save-default nil)
       ;; Auto-saving does not cooperate with org-crypt.el: so you need to
       ;; turn it off if you plan to use org-crypt.el quite often.  Otherwise,
       ;; you'll get an (annoying) message each time you start Org.
      
       ;; To turn it off only locally, you can insert this:
       ;;
       ;; # -*- buffer-auto-save-file-name: nil; -*-
       #+end_src
     - bh config ::
       #+header: :tangle yes
       #+begin_src emacs-lisp
       ; (require 'org-crypt)
      
       ; Encrypt all entries before saving
       ; (org-crypt-use-before-save-magic)
       ; (setq org-tags-exclude-from-inheritance (quote ("crypt")))
      
       ; GPG key to use for encryption
       (setq org-crypt-key "F0B66B40")
       #+end_src
   + process ::
     - ==M-x org-decrypt-entry== prompts for the passphrase associated with the encryption key and replace the encrypted data where the point is with the plaintext details for your encrypted entry ::
     - as soon as the file is saved, the data is re-encrypted for the key ::
     - encrypting does not require prompting for the passphrase - that's only for looking at the plain text version of the data :: 
   + tips ::
     - prefer having a single level 1 encrypted entry per file (like ==* Passwords==)
     - prevent the ==crypt== tag from using inheritance so not to have encrypted data inside encrypted data
     - ==M-x org-decrypt-entries== prompting for the passphrase to decrypt data over and over again (once per entry to decrypt) can be too inconvenient
       + so, try to leave entries encrypted unless need to look up data - decrypt on demand and then save the file again to re-encrypt the data, this keeps the data in plain text as short as possible
   + possible to use different keys for different headings by specifying the respective key as property ==CRYPTKEY== ::
     - e.g. ::
       #+begin_src org :exports src
       ,* Totally secret :crypt:
         :PROPERTIES:
         :CRYPTKEY: 0x0123456789012345678901234567890123456789
         :END:  
       #+end_src
     - note that ==CRYPTKEY== property is only effective when ==org-crypt-key== is set to ==non-nil==
       + ==nil== value of ==org-crypt-key== makes org-mode use symmetric encryption unconditionally
   + excluding the ‘crypt’ tag from inheritance prevents already encrypted text from being encrypted again :: 

**** Auto Save Files and encryption
   + notes ::
     - autosave feature is pretty great
     - emacs temporarily saves buffers in an autosave file while one is editing their org buffer and a sufficient number of changes have accumulated
     - if one has decrypted subtrees in their buffers, these will be written to disk *in plain text* which possibly leaks sensitive information
     - to prevent this, org-mode now asks if one wants to disable the autosave functionality in the current buffer
       + hence the utility seen previously of keep decrypted entries as minimal as possible, so that when autosaving the temporary file is also encrypted
       + when need a clear encrypted entry lookup, do it and directly save it so that it is encrypted again
   + setup to disable ==org-crypt-disable-auto-save== :: but *careful*, autosave will still be active
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq org-crypt-disable-auto-save nil)
     #+end_src

*** Speed Commands with ==org-speed-commands==
   + kbd (default speed command keys) ::
     - ==I== and ==O== for clocking in and out
     - ==J== to jump to current or last clocking task
     - ==t== to change todo state
   + speed commands :: allow access to frequently used commands when on the beginning of a headline (similar to one-key agenda commands)
     - speed commands are user configurable and org-mode provides a good set of default commands
   + tips ::
     - can override the default settings for the 1, 2, and 3 keys if one doesn't use priorities
     - disable cycling with ==c==, and add ==q== as a quick way to get back to the agenda and update the current view
   + default org-speed ==org-speed-commands-default== already sets plenty of useful speed keys ::
     - eg ::
       + ==I== and ==O== :: for clocking in and out
       + ==J== :: jump to current or last clocking task
       + ==t== :: change todo state
       + ==TAB== and ==S-TAB== :: for cycling
       + ==c== and ==C== :: are disabled by bh so they do not accidentally self insert when not intended to
     - example setup ::
     #+begin_src org :exports src
     ,(("Outline Navigation")
      ("n" org-speed-move-safe 'outline-next-visible-heading)
      ("p" org-speed-move-safe 'outline-previous-visible-heading)
      ...
      ("g" org-refile t)
      ("Outline Visibility")
      ("c" . org-cycle)
      ("C" . org-shifttab)
      ...
      ("Outline Structure Editing")
      ("U" . org-shiftmetaup)
      ("D" . org-shiftmetadown)
      ...
      ("#" . org-toggle-comment)
      ("Clock Commands")
      ("I" . org-clock-in)
      ("O" . org-clock-out)
      ("Meta Data Editing")
      ("t" . org-todo)
      ("," org-priority)
      ("0" org-priority 32)
      ("1" org-priority 65)
      ("2" org-priority 66)
      ...
      ("W" lambda
       (m)
       (interactive "sMinutes before warning: ")
       (org-entry-put
	(point)
	"APPT_WARNTIME" m))
      ("Agenda Views etc")
      ("v" . org-agenda)
      ("/" . org-sparse-tree)
      ("Misc")
      ("o" . org-open-at-point)
      ("?" . org-speed-command-help)
      ("<" org-agenda-set-restriction-lock 'subtree)
      (">" org-agenda-remove-restriction-lock))
     #+end_src
   + setup ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq org-use-speed-commands t)
     (setq org-speed-commands-user (quote (("0" . ignore)
                                           ("1" . ignore)
                                           ("2" . ignore)
                                           ("3" . ignore)
                                           ("4" . ignore)
                                           ("5" . ignore)
                                           ("6" . ignore)
                                           ("7" . ignore)
                                           ("8" . ignore)
                                           ("9" . ignore)
    
                                           ("a" . ignore)
                                           ("d" . ignore)
                                           ("h" . bh/hide-other)
                                           ("i" progn
                                            (forward-char 1)
                                            (call-interactively 'org-insert-heading-respect-content))
                                           ("k" . org-kill-note-or-show-branches)
                                           ("l" . ignore)
                                           ("m" . ignore)
                                           ("q" . bh/show-org-agenda)
                                           ("r" . ignore)
                                           ("s" . org-save-all-org-buffers)
                                           ("w" . org-refile)
                                           ("x" . ignore)
                                           ("y" . ignore)
                                           ("z" . org-add-note)
    
                                           ("A" . ignore)
                                           ("B" . ignore)
                                           ("E" . ignore)
                                           ("F" . bh/restrict-to-file-or-follow)
                                           ("G" . ignore)
                                           ("H" . ignore)
                                           ("J" . org-clock-goto)
                                           ("K" . ignore)
                                           ("L" . ignore)
                                           ("M" . ignore)
                                           ("N" . bh/narrow-to-org-subtree)
                                           ("P" . bh/narrow-to-org-project)
                                           ("Q" . ignore)
                                           ("R" . ignore)
                                           ("S" . ignore)
                                           ("T" . bh/org-todo)
                                           ("U" . bh/narrow-up-one-org-level)
                                           ("V" . ignore)
                                           ("W" . bh/widen)
                                           ("X" . ignore)
                                           ("Y" . ignore)
                                           ("Z" . ignore))))
    
     (defun bh/show-org-agenda ()
       (interactive)
       (if org-agenda-sticky
           (switch-to-buffer "*Org Agenda( )*")
         (switch-to-buffer "*Org Agenda*"))
       (delete-other-windows))
     #+end_src
*** Org Protocol (create capture notes in org-mode from other applications)
   + utility ::  great way to create capture notes in org-mode from other applications
     - for example, it's great way to create tasks to review interesting web pages visited from Firefox
   + can have a special capture template set up for org-protocol to use (set up with ==w== key) :: 
   + need to set bulk of the setup in the target application (Firefox in this case), so that ==C-c c== on a page in Firefox triggers the org-protocol capture template with details of the page currently being viewed (in firefox) ::
     - can set up ==org-protocol== in firefox as described in  [[http://orgmode.org/worg/org-contrib/org-protocol.php#sec-9][Keybindings for Firefox]]
   + org-mode setup for org-protocol is simple, it enables org-protocol and creates a single org-protocol capture template as described in [[#CaptureTemplates][Capture Templates]] ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (require 'org-protocol)
     #+end_src

*** Add (require) a final newline when saving files
   + utility :: mainly for editing yasnippets (template system for Emacs, allows to type an abbreviation and automatically expand it into function templates, see [[#abbr_func_templates][abbreviations into function template]])
     - great for anything: programming autocomplete, orgmode, etc.
     - settings helps to expand a snippet but stay on the same line
     - perfect way to for replacing short strings or initials with full names for people during meeting notes
   + thanks to ==abbrev-mode-==, no longer need to fuss :: when saving a file in Emacs, add a final newline that fits better with the source code projects that is usually worked on ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq require-final-newline t)
     #+end_src

*** Insert inactive timestamps (for later references and remembering) and exclude from export
   + notes ::
     - inserting inactive timestamps when working on org-mode files is possible in order for example to remember when a task/something was created/done/blocked
     - for ==remember== tasks, the timestamp is in the remember template, but for regular structure editing, one can want the timestamp automatically added when the headline is created
     - bh made a function that is run by an org-mode hook to automatically insert the inactive timestamp whenever a headline is created
       + adding the timestamp can be controlled with ==f9 T== which toggles the creation of the timestamp *on and off* for new headlines
   + example ::
     - when creating a heading (with ==M-RET== or ==M-S-RET==), the hook invokes bh's function and it inserts an inactive timestamp like this ::
       #+begin_src org :exports src
       ,* <point here>
         [2009-11-22 Sun 18:45]  
       #+end_src
     - this keeps an automatic record of when tasks was created, which can be very useful ::
   + kbd ::
     - invoke insert inactive timestamp function on demand and anywhere :: ==f9 T==
   + setup for timestamp hook insertion ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (defvar bh/insert-inactive-timestamp t)
    
     (defun bh/toggle-insert-inactive-timestamp ()
       (interactive)
       (setq bh/insert-inactive-timestamp (not bh/insert-inactive-timestamp))
       (message "Heading timestamps are %s" (if bh/insert-inactive-timestamp "ON" "OFF")))
    
     (defun bh/insert-inactive-timestamp ()
       (interactive)
       (org-insert-time-stamp nil t t nil nil nil))
    
     (defun bh/insert-heading-inactive-timestamp ()
       (save-excursion
         (when bh/insert-inactive-timestamp
           (org-return)
           (org-cycle)
           (bh/insert-inactive-timestamp))))
    
     (add-hook 'org-insert-heading-hook 'bh/insert-heading-inactive-timestamp 'append)
     #+end_src
   + setup for hotkeys ::
     - invoke insert inactive timestamp function on demand and anywhere :: ==f9 T==
       #+header: :tangle yes
       #+begin_src emacs-lisp
       (global-set-key (kbd "<f9> t") 'bh/insert-inactive-timestamp)
       #+end_src
   + setup to prevent the timestamps from being exported in documents ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq org-export-with-timestamps nil)
     #+end_src

*** Highlight clock when running overtime
  + current clocking task is displayed on the ==modeline== (which appears at the bottom of every Emacs internal window, and displays as much infos about the buffer as possible, such as buffer name being used, it's major/minor mode, the current cursor line, etc., see [[https://www.emacswiki.org/emacs/ModeLine][modeline]] for more details)
  + if current task has an estimated time and it is run over the limit, make this stand out on the modeline by changing the background to red as follows ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (custom-set-faces
      ;; custom-set-faces was added by Custom.
      ;; If you edit it by hand, you could mess it up, so be careful.
      ;; Your init file should contain only one such instance.
      ;; If there is more than one, they won't work right.
     '(org-mode-line-clock ((t (:foreground "red" :box (:line-width -1 :style released-button)))) t))
    #+end_src

*** Register 'Meeting Notes'
  + meeting ::
    - is a task and it is complete when the meeting is over
    - can record meeting conversations in point-form using org-mode lists
    - if action items are decided on in the meeting, can denote them with a bullet and a ==TODO:== or ==DONE:== flag
    - the body of the task records all of the interesting meeting details
    - if ==TODO== items are created in the meeting, one can make separate ==TODO== tasks from those
    - can use ==abbrev-mode== to change people's initials to full names quickly during the meeting, this speeds up note taking and avoids mistyping people's names in meeting notes
    - bh made the function ==bh/prepare-meeting-notes== to prepare the meeting notes for emailing to the participants (in a fixed-width font like "Courier New") ::
      + then, as soon as the meeting is over, the notes are basically ready for distribution – no need to waste time rewriting the minutes before they go out
  + eg ::
    #+begin_src org :exports src
    ,* TODO Sample Meeting
      - Attendees
        - [ ] Joe
        - [X] Larry
        - [X] Mary
        - [X] Fred
      - Joe is on vacation this week
      - Status Updates
        + Larry
          - did this
          - and that
          - TODO: Needs to follow up on this
        + Mary
          - got a promotion for her recent efforts
        + Fred
          - completed all his tasks 2 days early
          - needs more work
          - DONE: everything  
    #+end_src
    
    #+begin_src org :exports src
    ,* TODO Sample Meeting
       - Attendees
         - [ ] Joe
         - [X] Larry
         - [X] Mary
         - [X] Fred
       - Joe is on vacation this week
       - Status Updates
         + Larry
           - did this
           - and that
    >>>>>>>> TODO: Needs to follow up on this
         + Mary
           - got a promotion for her recent efforts
         + Fred
           - completed all his tasks 2 days early
           - needs more work
    >>>>>>>> DONE: everything  
    #+end_src
  + setup for the formatting function ::
    - notes :: 
      + just highlighting the region for the notes will turn tabs into spaces and highlights todo items
      + the resulting notes are in the kill buffer ready to paste to another application
    - setup ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      (defun bh/prepare-meeting-notes ()
        "Prepare meeting notes for email
         Take selected region and convert tabs to spaces, mark TODOs with leading >>>, and copy to kill ring for pasting"
        (interactive)
        (let (prefix)
          (save-excursion
            (save-restriction
              (narrow-to-region (region-beginning) (region-end))
              (untabify (point-min) (point-max))
              (goto-char (point-min))
              (while (re-search-forward "^\\( *-\\\) \\(TODO\\|DONE\\): " (point-max) t)
                (replace-match (concat (make-string (length (match-string 1)) ?>) " " (match-string 2) ": ")))
              (goto-char (point-min))
              (kill-ring-save (point-min) (point-max))))))
      #+end_src

*** Remove Highlights after changes
  + notes ::
    - ==org-occur== (==C-c / r==, or ==C-c / /==) ::
      + prompts for a regexp, and shows a sparse tree with all matches ::
	- useful to find details in org-files
	- if the match is in a headline, the headline is made visible
	- if the match is in the body of an entry, headline and body are made visible
	- in order to provide minimal context, also the full hierarchy of headlines above the match is shown, as well as the headline following the match
	- each match is also highlighted
	- the highlights disappear when the buffer is changed by an editing command, or with ==C-c C-c==
	- when called with a ==C-u== prefix argument, previous highlights are kept, so several calls to this command can be stacked
  + setups ::
    - setting to keep the highlighted results of the search even after modifying the text ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ; setting this variable to t (default config) will automatically remove the yellow highlights as soon as the buffer is modified
      ;(setq org-remove-highlights-with-change nil)
      #+end_src
  + kbd ::
    - ==C-c / r==, or ==C-c / /== :: regexp search, and show a sparse tree with all matches
    - ==C-u C-c / r==, or ==C-u C-c / /== (previous org-occur, but with prefix ==C-u==) :: as previous, but also keep previous highlights, meaning that ==org-occur== calls can be stacked
    - ==C-c C-c== :: "unhighlight" matches (remove highlights)

*** Getting up-to-date org-mode info documentation
  + get up-to-date documentation from git before the regular (out of date) system versions ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (add-to-list 'Info-default-directory-list "~/Documents/repos/opt/org-mode/doc")
    #+end_src

*** Prefer future dates or not? (set default year to look up into when searching incomplete date: 'Month Day', without the year)
  + notes ::
    - by default org-mode prefers dates in the future :: when today's date is May 2 and you enter April 30th (2 days ago), org-mode will jump to April 30th of next year
    - can be annoying when one wants to look at what happened days before, since one needs to specify the year
    - can use ==b== to go back relatively in the agenda
    - one could make org-mode prefer the current year when entering dates with ==(setq org-read-date-prefer-future nil)==, but better to use =='time== so times before now (with no date specified) will default to tomorrow
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-read-date-prefer-future 'time)
    #+end_src
  + kbd ::
    - ==b== :: go back relatively in the agenda when searching for what happened in past days

*** Remove indentation on agenda tags view
  + it's great to see all matching tasks (including sublevels) when one is doing an agenda tag search (==F12 m==)
  + to make all of the matched headings for a tag show at the same level in the agenda, set the following variable ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-tags-match-list-sublevels t)
    #+end_src

*** Agenda persistent filters (remembers agenda filter until changed)
  + great feature!, making an agenda filters persistent means if one limits a search with ==/ TAB <SomeTag>==, the agenda remembers the filter until it is specifically changed
  + the current filter is displayed in the modeline as =={+SomeTag}== so one can easily see what filter currently applies to the agenda view
  + can use the feature for example with ==FILETAGS== to limit the displayed results to a single client or context
  + enable persistent filters ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-agenda-persistent-filter t)
    #+end_src

*** Add tags for flagged entries (and know that you are able to find something important in the future when needed: for these types of notes and tasks, add a special ==:FLAGGED:== tag)
  + to find something special anytime needed :: tag it as ==:FLAGGED:==
  + the tag gets a special fast-key ==?== :: which matches the search key in the agenda for flagged items
  + see [[#OrgTagAlist][Tags]] for the setup of ==org-tag-alist== for the =FLAGGED= entry
  + finding flag entries is simple :: just ==F12 ?==, and you get them all
  + kbd ::
    - finding *all* flag entries :: ==F12 ?==

*** Mail links open compose-mail
  + make org-mode open ==mailto:== links using compose-mail ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-link-mailto-program (quote (compose-mail "%a" "%s")))
    #+end_src

**** Compose mail from org mode subtrees
  + it's possible to create mail from an org-mode subtree ::
    - ==C-c M-o== :: start an email message with the details filled in from the current subtree
    - can be used for repeating reminder tasks where needs to send an email to another recipient
    - email contents are already contained in the org-mode subtree, all needed to do is ==C-c M-o== and any minor edits before sending it off
  + kbd ::
    - ==C-c M-o== :: start an email message with the details filled in from the current subtree

*** Use Smex for M-x ido-completion
  + Smex is a ==M-x== enhancement for Emacs built on top of IDO (Interactive Do) that hand crafts the completion experience for files and buffers
  + smex provides a convenient interface to recently, most frequently used commands, and to all the other commands too
  + commands are displayed in an Ido completion buffer, ordered by relevance
  + the 7 most recently executed commands come first, the rest are sorted by frequency of use, command length, and in alphabetical order
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (add-to-list 'load-path (expand-file-name "~/Documents/repos/opt/org-mode/smex/"))
    ; auto-start Smex every time one opens Emacs
    (require 'smex)
    (smex-initialize)
    
    (global-set-key (kbd "M-x") 'smex)
    (global-set-key (kbd "C-x x") 'smex)
    (global-set-key (kbd "M-X") 'smex-major-mode-commands)
    #+end_src
  + kbd ::
    - ==M-x==, or ==C-x x== :: call smex
    - ==M-X== :: runs Smex, limited to commands that are relevant to the active major mode (can be tried with Dired or Magit for example)
    - ==C-h f== :: while Smex is active, runs ==describe-function== on the currently selected command
    - ==M-.== :: jumps to the definition of the selected command
    - ==C-h w== :: shows the key bindings for the selected command (Via ==where-is==)

*** Emacs bookmarks
  + Emacs bookmarks can be used for fast navigation to save (bookmark) a location, and easily retrieve it
    - usecase :: when working on a long checklist, it's convenient to set a bookmark on the next item to check, then work on it, and return to the checkbox to mark it done
  + setups ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; Bookmark handling
    (global-set-key (kbd "<C-f6>") '(lambda () (interactive) (bookmark-set "SAVED")))
    (global-set-key (kbd "<f6>") '(lambda () (interactive) (bookmark-jump "SAVED")))
    #+end_src
  + kbds ::
    - ==C-f6== :: save/bookmark current location
    - ==f11== :: go back to current clocked task
    - ==f6== :: go to bookmarked location (the same bookmark is overwritten each time a new position is set)

*** Org-mime for emails (useful for sending tables, fontified source code, and inline images in email)
  + org-mime :: approximates a WYSiWYG HTML mail editor from within Emacs, and can be useful for sending tables, fontified source code, and inline images in email
  + bh added keybinding ==C-c M-o== in ==org-mode-hook== to generate mail from an org-mode subtree (see ==bh/mail-subtree==)
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; org-mime configs
    (add-to-list 'load-path (expand-file-name "~/Documents/repos/opt/org-mode/org-mime/"))
    (require 'org-mime)
    #+end_src
  + kbd ::
    - ==C-c M-o== :: generate mail from an org-mode subtree

*** Remove multiple state change log details from the agenda (skip multiple timestamps for the same entry in the agenda view)
  + skip multiple timestamps for the same entry in the agenda view ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-agenda-skip-additional-timestamps-same-entry t)
    #+end_src
  + the setting removes the clutter of extra state change log details when multiple timestamps exist in a single entry 

*** Drop use of old style field references in tables (for spreadsheet operations)
  + Notes ::
    - can do A LOT with emacs tables, even spreadsheet operations as an excel file
    - source :: https://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html
    - suppose the following table ::
      | One | Two | Three |
      |-----+-----+-------|
      |   1 |   1 |     2 |
      |   3 |   6 |     5 |
      |   3 |   4 |     2 |
    - let's try to get to the following result ::
      | One | Two | Three | Mean           |
      |-----+-----+-------+----------------|
      |   1 |   1 |     2 | [formula]      |
      |   3 |   6 |     5 |                |
      |   3 |   4 |     2 |                |
    - when entering ==C-c ?== in [formula], you get : ==line @2, col $4, ref @2$4 or D2==, which means :: you are on the second row (or line) of the fourth column, and the reference for this field is either ==@2$4== or ==D2==
      + ==D2== is for reference visualization grid (4th column D, 2nd line)
      + when want to be sure, can turn on/off the reference visualization grid with ==C-c }==
    - formulas ::
      + can enter formula in [formula] by typing ==:=vmean($2..$3)== (find mean of fields 2nd to 3rd _in this row_) in field
	- can also use ==:=vmean(B&..C&)==, where the & character stands for "in this row", which is implicit in previous notation
      + hit ==C-c C-c== in row ::
	1. the formula has been replaced by the result of the calculation
	2. a new line starting with ==#+TBLFM== has been inserted at the bottom of the table
      + result ::
	| One     | Two | Three | Mean |
	|---------+-----+-------+------|
	| a thing |   1 |     2 |  1.5 |
	| another |   6 |     5 |      |
	| a third |   4 |     2 |      |
	#+TBLFM: @2$4=vmean($2..$3)
      + ==#+TBLFM== contains all the formulas for the table above
	- be careful while editing it manually
      + to compute same formula for all fields (column formula, instead of field formula) ::
	1. go in same field
	2. type =='=vmean($2..$3)'== ('​=' instead of ':​=')
	3. ==C-c C-c==
	   - prompts to :: whether you want to replace the formula with a column formula (yes)
	4. reapply all formulas with ==C-u C-c *==
	   - or ==C-c C-c== on the #+TBLFM line (which should then be ==#+TBLFM: $4=vmean($2..$3)==, and applied to $4 column)
      + same steps, but on a row formula :: (2 field formulas: each one calculating the mean for the fields above in the same column)
      + final result ::
	| One      |       Two | Three | Mean |
	|----------+-----------+-------+------|
	| a thing  |         1 |     2 |  1.5 |
	| another  |         6 |     5 |  5.5 |
	| a third  |         4 |     2 |    3 |
	| Mean row | 3.6666667 |     3 |      |
	#+TBLFM: $2=vmean(@2$2..@4$2)::$3=vmean(@2$3..@4$3)::$4=vmean($2..$3)
    - interactive formulas ::
      + instead of inserting formulas directly in the table cells ::
	- typing ==​=== in a field :: starts the definition for a column formula
	- typing ==:​=== :: starts a definition for a field formula
      + can also use minibuffer ::
	- ==C-c ​=== :: for editing column formulas
	- ==C-u C-c ​=== :: for field formulas
      + can also edit formulas more interactively in a dedicated buffer using :: ==C-c '==
	- new buffer lists all the formulas for the table at point and provides facilities to edit the references
	- when the cursor is above a reference, the corresponding field in the table gets highlighted
	- can select the reference with ==S-<left/right/up/down>==
    - even more (Calc and Elisp formulas, debugging formulas, etc.) in :: https://orgmode.org/worg/org-tutorials/org-spreadsheet-intro.html
  + bh config ::
    - drop the old A3/B4 style references from tables when editing ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      (setq org-table-use-standard-references (quote from))
      #+end_src
  + kbds ::
    - ==C-c ?== in table field :: you get : ==line @2, col $4, ref @2$4 or D2==, which means: second row (or line) of fourth column, and the reference for this field is either ==@2$4== or ==D2== (reference visualization grid: 4th column D, 2nd line
    - ==C-c }== :: turn on/off the reference visualization grid
    - formulas ::
      + in field ::
	- ==:=vmean($2..$3)== :: finds mean of fields 2nd to 3rd _in this row_
	- ==:=vmean(B&..C&)== :: same as above, (& character stands for "in this row", implicit in previous notation)
      + =='=vmean($2..$3)'== ('​=' instead of ':​=') :: formula on column
    - ==C-c C-c== in row :: eval formula
    - ==C-u C-c *== :: reapply all formulas
      + or ==C-c C-c== on #+TBLFM line
    - interactive formulas ::
      + ==​=== in a field :: start the definition for a column formula
      + ==:​=== :: starts a definition for a field formula
      + in minibuffer ::
	- ==C-c ​=== :: for editing column formulas
	- ==C-u C-c ​=== :: for field formulas
      + in a dedicated buffer, using :: ==C-c '==
	- new buffer lists all the formulas for the table at point and provides facilities to edit the references
	- when the cursor is above a reference, the corresponding field in the table gets highlighted
	- can select the reference with ==S-<left/right/up/down>==

*** Use system settings for file-application selection (set system as the one opening some applications, eg: pdf, html, etc.)
  + set consistent applications for opening tasks by setting the ==org-file-apps== variable ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-file-apps (quote ((auto-mode . emacs)
                                ("\\.mm\\'" . system)
                                ("\\.x?html?\\'" . system)
                                ("\\.pdf\\'" . system))))
    #+end_src
  + this uses the entries defined in the system ==mailcap== settings when opening file extensions
  + gives consistent behaviour when opening an link to some HTML file for example with ==C-c C-o== or when previewing an export

*** Use current window for the agenda
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; Overwrite the current window with the agenda
    (setq org-agenda-window-setup 'current-window)
    #+end_src

*** Cycling plain lists (allow folding completed list entries and focus on what is remaining easily)
  + allow org-mode to fold (cycle) plain lists ::
    - useful when one has repeating tasks with lots of sublists with checkboxes
    - can then fold the completed list entries and focus on what is remaining easily
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-cycle-include-plain-lists t)
    #+end_src

*** Showing source block syntax highlighting
  + possible to display org-mode source blocks fontified in their native mode ::
    - allows colourization of keywords for C, shell script source, etc.
  + to edit the source, use ==C-c '== to bring up the source window ::
    - source window rendered with syntax highlighting in the native mode
    - setting also shows the syntax highlighting when viewing in the org-mode buffer
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-src-fontify-natively t)
    #+end_src

*** Inserting Structure Template Blocks (shortcuts to native add code blocks ==C-c C-,==)
  + use shortcut key sequence in org-mode to insert structure templates quickly into org files
  + eg ::
    | Key Sequence | Expands to                        |
    |--------------+-----------------------------------|
    | ==< s TAB==  | #+begin_src ... #+end_src         |
    | ==< e TAB==  | #+begin_example ... #+end_example |
  + can even add a block for saving email text which are copied from MS Outlook in order to have context associated with my org-mode tasks
  + setup (makes the blocks lowercase instead of the default upper case in org-mode) ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; old way, changed with newer version of org-mode
    ;; (setq org-structure-template-alist
    ;;       (quote (("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
    ;;               ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
    ;;               ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
    ;;               ("v" "#+begin_verse\n?\n#+end_verse" "<verse>\n?\n</verse>")
    ;;               ("c" "#+begin_center\n?\n#+end_center" "<center>\n?\n</center>")
    ;;               ("l" "#+begin_latex\n?\n#+end_latex" "<literal style=\"latex\">\n?\n</literal>")
    ;;               ("L" "#+latex: " "<literal style=\"latex\">?</literal>")
    ;;               ("h" "#+begin_html\n?\n#+end_html" "<literal style=\"html\">\n?\n</literal>")
    ;;               ("H" "#+html: " "<literal style=\"html\">?</literal>")
    ;;               ("a" "#+begin_ascii\n?\n#+end_ascii")
    ;;               ("A" "#+ascii: ")
    ;;               ("i" "#+index: ?" "#+index: ?")
    ;;               ("I" "#+include %file ?" "<include file=%file markup=\"?\">"))))

    (setq org-structure-template-alist
      (quote (("s" . "src")
              ("e" . "example")
              ("q" . "quote")
              ("v" . "verse")
              ("c" . "center")
              ("l" . "latex")
              ;; ("L" "latex: " "<literal style=\"latex\">?</literal>")
              ("h" . "html")
              ;; ("H" "html: " "<literal style=\"html\">?</literal>")
              ("a" . "ascii")
              ("A" . "ascii: "))))
              ;; ("i" "index: ?")
              ;;("I" "include %file ?" "<include file=%file markup=\"?\">"))))

    #+end_src

*** '==NEXT==' is for tasks (turn parent tasks of ==NEXT== task to ==TODO==)
  + notes ::
    - ==NEXT== keywords are for tasks and *not projects* ::
      + bh config ::
	- add function to todo state change hook and clock in hook :: so that any parent tasks marked ==NEXT== turn from ==NEXT== to ==TODO== since they are now projects and not tasks
	- setup ::
          #+header: :tangle yes
          #+begin_src emacs-lisp
          (defun bh/mark-next-parent-tasks-todo ()
            "Visit each parent task and change NEXT states to TODO"
            (let ((mystate (or (and (fboundp 'org-state)
                                    state)
                               (nth 2 (org-heading-components)))))
              (when mystate
                (save-excursion
                  (while (org-up-heading-safe)
                    (when (member (nth 2 (org-heading-components)) (list "NEXT"))
                      (org-todo "TODO")))))))
          
          (add-hook 'org-after-todo-state-change-hook 'bh/mark-next-parent-tasks-todo 'append)
          (add-hook 'org-clock-in-hook 'bh/mark-next-parent-tasks-todo 'append)
          #+end_src

*** Using orgstruct mode for mail (to aid in creating structured email messages)
  + ==orgstruct++-mode== is enabled in Gnus message buffers to aid in creating structured email messages
    - // orgstruct seems to no longer be supported, check following sources and look for alternatives ::
      + https://emacs.stackexchange.com/questions/47003/the-orgstruct-mode-seems-to-be-gone-from-the-org-plus-contrib
      + https://orgmode.org/worg/org-tutorials/org-outside-org.html (One possibility to enjoy Org-mode's structure-editing and list-formatting facilities outside Org-mode buffers is *Orgstruct minor mode?*)
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (add-hook 'message-mode-hook 'orgstruct++-mode 'append)
    (add-hook 'message-mode-hook 'turn-on-auto-fill 'append)
    (add-hook 'message-mode-hook 'bbdb-define-all-aliases 'append)
    (add-hook 'message-mode-hook 'orgtbl-mode 'append)
    (add-hook 'message-mode-hook 'turn-on-flyspell 'append)
    (add-hook 'message-mode-hook
              '(lambda () (setq fill-column 72))
              'append)
    #+end_src

*** Reduce spelling errors with flyspell mode
  + ==flyspell-mode== is enabled for almost everything to help prevent creating documents with spelling errors
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ;; flyspell mode for spell checking everywhere
    (add-hook 'org-mode-hook 'turn-on-flyspell 'append)
    
    ;; Disable keys in org-mode
    ;;    C-c [ 
    ;;    C-c ]
    ;;    C-c ;
    ;;    C-c C-x C-q  cancelling the clock (we never want this)
    (add-hook 'org-mode-hook
              '(lambda ()
                 ;; Undefine C-c [ and C-c ] since this breaks my
                 ;; org-agenda files when directories are include It
                 ;; expands the files in the directories individually
                 (org-defkey org-mode-map "\C-c[" 'undefined)
                 (org-defkey org-mode-map "\C-c]" 'undefined)
                 (org-defkey org-mode-map "\C-c;" 'undefined)
                 (org-defkey org-mode-map "\C-c\C-x\C-q" 'undefined))
              'append)
    
    (add-hook 'org-mode-hook
              (lambda ()
                (local-set-key (kbd "C-c M-o") 'bh/mail-subtree))
              'append)
    
    (defun bh/mail-subtree ()
      (interactive)
      (org-mark-subtree)
      (org-mime-subtree))
    #+end_src

*** Preserving source block indentation (manage indentation in source blocks vs in org-files)
  + notes ::
    - preserving indentation for source blocks can be be messy with indented org-files
    - one of the reason that makes preserving indentation is when TABs in files need to be preserved (e.g. Makefiles)
      + if you normally do not edit these files much in org-mode, better to leave this setting turned off
  + setup ::
    - change the default block indentation so that it is not indented from the text in the org file ::
      + this allows editing source blocks in place without requiring use of ==C-c '== so that code lines up correctly
    - setup ::
      #+header: :tangle yes
      #+begin_src emacs-lisp
      ;; Preserving source block indentation
      (setq org-src-preserve-indentation nil)
      (setq org-edit-src-content-indentation 0)
      #+end_src
  + kbd ::
    - ==C-c '== :: make code lines up correctly

*** Prevent editing invisible text (prevent accidental editing hidden text when the point is inside a folded region)
  + used to prevent accidentally editing hidden text when the point is inside a folded region (can happen if one is in the body of a heading and globally fold the org-file with ==S-TAB==)
  + invisible edits (and undo's) can be hard to deal with, so can set invisible text to not be edited
    - ==C-c C-r== (==org-reveal==) will display where the point is if it is buried in invisible text to allow editing again
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-catch-invisible-edits 'error)
    #+end_src
  + kbd ::
    - ==C-c C-r== :: display where the point is if it is buried in invisible text to allow editing again

*** Keep clock durations in hours (instead of default 'days', which can be relative to one's need)
  + notes ::
    - default for clock durations has changed to include days which is 24 hours
    - one could need to change the settings, for example, at work one can think of a day as 6 hours of work (the rest of the time is lost in meetings and other overhead on average)
    - so displaying clock durations in days would not make sense to many
  + setup to display clock durations in hours and minutes (with ==C-c C-x C-d==) ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-time-clocksum-format
          '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))
    #+end_src
  + kbd ::
    - ==C-c C-x C-d== :: display clock durations in hours and minutes

*** Create unique IDs for tasks when linking (with ==PROPERTY== drawer, will keep unique ID and you will be able to move heading as wanted and the link will still work)
  + setup to create a unique task ID for the heading in the ==PROPERTY== drawer (with ==C-c l==)
    - allows to move the task around arbitrarily in org files and the link to it will still work
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
    #+end_src

** Using Git for Automatic History, Backups, and Synchronization
  + Need :: when editing folded regions of org-mode files and change(s) corrupt the files
  + Fix :: add org files in a Git repository
  + Process ::
    - setup saves org-files periodically and creates a commit with changes automatically
      + this allow to go back in time and view the state of org files for any given moment over the lifetime of the document

*** Automatic periodic Commits
  + emacs setup for saving org buffers every 6 hours ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (run-at-time "00:59" 21600 'org-save-all-org-buffers)
    #+end_src
  + understand setup (can get more details with calling help on function ==run-at-time==: ==C-h f 'run-at-time' -RET-==) ::
    - format :: (run-at-time TIME REPEAT FUNCTION &rest ARGS)
    - ==run-at-time== :: performs an action at time TIME, Repeat the action every REPEAT seconds if REPEAT is non-nil
    - TIME can be ::
      + a string giving: today’s time (eg: "11:23pm"), a relative time ("90" or "2 hours 35 minutes", the acceptable forms are a number of seconds without units or some combination of values using units in ‘timer-duration-words’)
      + nil, meaning now
      + a number of seconds from now
      + a value from ‘encode-time’
      + t (with non-nil REPEAT) meaning the next integral multiple of REPEAT
    - the action is to call FUNCTION with arguments ARGS
    - the function returns a timer object which can be used in ==cancel-timer== 
  + a ==cron== job will run at the top of the 6 hours to commit any changes just saved by the call to ==org-save-all-org-buffers==
  + bh is using a script to create the commits so that it can run on demand to easily commit all modified work when moving from one machine to another for example
  + ==crontab== details ::
    #+begin_example 
    0 * * * * ~/bin/org-git-sync.sh >/dev/null
    #+end_example

**** Script : ~/bin/org-git-sync.sh (to create commits for org-repositories)
  + what does :: loops through multiple repositories and commits any modified files
  + so far, has following org-mode repositories ::
    - ==memacs== :: contains most org files and is about GTD, learnings, TODOs, etc.
    - ==ntwado.com== :: to be built website/blog
  + content ::
    #+begin_example
    #!/bin/sh
    # Add org file changes to the repository
    REPOS="memacs ntwado.com"
    
    for REPO in $REPOS
    do
        echo "Repository: $REPO"
        cd ~/git/$REPO
        # Remove deleted files
        git ls-files --deleted -z | xargs -0 git rm >/dev/null 2>&1
        # Add new files
        git add . >/dev/null 2>&1
        git commit -m "$(date)"
    done
    #+end_example

**** Git Repository synchronization (synchronize all git repositories in one run of a script)
  + process ::
    - use script (==git-sync.sh==) to synchronize all changes in current local and commit-push latest changes, and then on the other machine run the same script to update local repositories
  + ==git-sync.sh== :: for each repository on the current system:
    - fetch objects from the remote
    - for each branch that tracks a remote branch ::
      + check if the ref can be moved
      + fast-forwards if behind the remote repository and is fast-forwardable
      + does nothing if ref is up to date
      + pushes ref to remote repository if ref is ahead of remote repository and fast-forwardable
      + fails if ref and remote have diverged
  + all done automatically, only scenario where manual update is needed :: when a change on any PC and another one needs to be done at the same time: then, a manual merge is required
  + content ::
    #+begin_example
    #!/bin/sh
    #
    
    # Local bare repository name
    syncrepo=norang
    reporoot=~/git
    
    # Display repository name only once
    log_repo() {
      [ "x$lastrepo" == "x$repo" ] || {
        printf "\nREPO: ${repo}\n"
        lastrepo="$repo"
      }
    }
    
    # Log a message for a repository
    log_msg() {
      log_repo
      printf "  $1\n"
    }
    
    # fast-forward reference $1 to $syncrepo/$1
    fast_forward_ref() {
      log_msg "fast-forwarding ref $1"
      current_ref=$(cat .git/HEAD)
      if [ "x$current_ref" = "xref: refs/heads/$1" ]
      then
        # Check for dirty index
        files=$(git diff-index --name-only HEAD --)
        git merge refs/remotes/$syncrepo/$1
      else
        git branch -f $1 refs/remotes/$syncrepo/$1
      fi
    }
    
    # Push reference $1 to $syncrepo
    push_ref() {
      log_msg "Pushing ref $1"
      if ! git push --tags $syncrepo $1
      then
        exit 1
      fi
    }
    
    # Check if a ref can be moved
    #   - fast-forwards if behind the sync repo and is fast-forwardable
    #   - Does nothing if ref is up to date
    #   - Pushes ref to $syncrepo if ref is ahead of syncrepo and fastforwardable
    #   - Fails if ref and $syncrop/ref have diverged
    check_ref() {
      revlist1=$(git rev-list refs/remotes/$syncrepo/$1..$1)
      revlist2=$(git rev-list $1..refs/remotes/$syncrepo/$1)
      if [ "x$revlist1" = "x" -a "x$revlist2" = "x" ]
      then
        # Ref $1 is up to date.
        :
      elif [ "x$revlist1" = "x" ]
      then
        # Ref $1 is behind $syncrepo/$1 and can be fast-forwarded.
        fast_forward_ref $1 || exit 1
      elif [ "x$revlist2" = "x" ]
      then
        # Ref $1 is ahead of $syncrepo/$1 and can be pushed.
        push_ref $1 || exit 1
      else
        log_msg "Ref $1 and $syncrepo/$1 have diverged."
        exit 1
      fi
    }
    
    # Check all local refs with matching refs in the $syncrepo
    check_refs () {
      git for-each-ref refs/heads/* | while read sha1 commit ref
      do
        ref=${ref/refs\/heads\//}
        git for-each-ref refs/remotes/$syncrepo/$ref | while read sha2 commit ref2
        do
          if [ "x$sha2" != "x" -a "x$sha2" != "x" ]
          then
            check_ref $ref || exit 1
          fi
        done
      done
    }
    
    # For all repositories under $reporoot
    #   Check all refs matching $syncrepo and fast-forward, or push as necessary
    #   to synchronize the ref with $syncrepo
    #   Bail out if ref is not fastforwardable so user can fix and rerun
    time {
      retval=0
      if find $reporoot -type d -name '*.git' | { 
          while read repo
          do
            repo=${repo/\/.git/}
            cd ${repo}
            upd=$(git remote update $syncrepo 2>&1 || retval=1)
            [ "x$upd" = "xFetching $syncrepo" ] || {
              log_repo
              printf "$upd\n"
            }
            check_refs || retval=1
          done
          exit $retval
        }
      then
        printf "\nAll done.\n"
      else
        printf "\nFix and redo.\n"
      fi
    }
    
    exit $retval 
    #+end_example

** Miscellaneous
*** Use utf-8 as default coding system
  + use utf-8 as the default coding system for all of org files ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; use utf-8 as the default coding system for all of org files
    (setq org-export-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (set-charset-priority 'unicode)
    (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
    #+end_src

*** Attachments
   + notes ::
     - great for getting *large amounts* of data related to the project out of the org-mode files
     - set up org-mode to generate unique attachment IDs with ==org-id-method== ::
       #+header: :tangle yes
       #+begin_src emacs-lisp
       (setq org-id-method (quote uuidgen))
       #+end_src
     - process ::
       - let's say you want to attach file ==x.sql== to current buffer :: create it in ==/tmp/x.sql==, and save it
       - attach the file with ==C-c C-a a==, and enter the filename: ==x.sql== ::
	 + this generates a unique ID for the task and adds the file in the attachment directory ::
	 + The attached file is saved for example in :: ==folderx/f1/d38e9a-ff70-4cc4-ab50-e8b58b2aaa7b/==
	   - where it goes exactly isn't really important as long as it is saved and retrievable easily
	   - org-mode copies the original file ==/tmp/x.sql== into the appropriate attachment directory
	 + example of result ::
	   #+begin_src org :exports src
	   ,* Attachments                                                        :ATTACH:
	     :PROPERTIES:
	     :Attachments: x.sql
	     :ID:       f1d38e9a-ff70-4cc4-ab50-e8b58b2aaa7b
	     :END:  
	   #+end_src
     - further notes ::
       + the ==ID== changes for every task header when a new ==ID== is generated
       + tasks with attachments automatically get an ==ATTACH== tag
	 - so, easy to find tasks with attachments with a *tag search*
       + to open the attachment for a task : ==C-c C-a o==
	 - prompts for the attachment to open, and ==TAB== completion works here
       + possible to use named directories for attachments, but need to test it yourself
   + kbd ::
     - attach a file to current buffer :: ==C-c C-a a==
     - to open the attachment for a task :: ==C-c C-a o==

*** Exporting Tables to CSV (comma delimited values)
   + create csv by exporting org-mode tables as comma delimited values (can also export as TAB delimited values)
   + set default value to csv ::
     #+header: :tangle yes
     #+begin_src emacs-lisp
     (setq org-table-export-default-format "orgtbl-to-csv")
     #+end_src
   + process ::
     - put cursor inside table ::
     - hit ==M-x org-table-export== :: prompts for a filename and the format which defaults to orgtbl-to-csv from setting above

*** Refrain from Opening a link, and insert a new line instead ("Return follows links")
  + following setting makes ==RET== insert a new line instead of opening links ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; bh config for links : he prefers to follow link instead of adding new line
    ; but personally, so far, prefer to still open link with old ==C-c C-o==
    ; (setq org-return-follows-link t)
    #+end_src

*** Automatically change list bullets
  + using a different bullet for a sub-list than that used for the current list-level does improve readability, so, customize ==org-list-demote-modify-bullet== and every time a sublist is started, then it will have different bullets than the current one
  + the setting will use the following bullets when moving to a sub-list ::
    | Current List Bullet | Next indented list bullet |
    |---------------------+---------------------------|
    | +                   | -                         |
    | *                   | -                         |
    | 1.                  | -                         |
    | 1)                  | -                         |
    | A)                  | -                         |
    | B)                  | -                         |
    | a)                  | -                         |
    | b)                  | -                         |
    | A.                  | -                         |
    | B.                  | -                         |
    | a.                  | -                         |
    | b.                  | -                         |
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-list-demote-modify-bullet (quote (("+" . "-")
                                                ("*" . "-")
                                                ("1." . "-")
                                                ("1)" . "-")
                                                ("A)" . "-")
                                                ("B)" . "-")
                                                ("a)" . "-")
                                                ("b)" . "-")
                                                ("A." . "-")
                                                ("B." . "-")
                                                ("a." . "-")
                                                ("b." . "-"))))
    #+end_src

*** Startup in folded view
  + open org files in folded view by default
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; startup org-mode files in folded view
    (setq org-startup-folded t)
    #+end_src

*** Allow alphabetical list entries
  + allow character letters as bullets in item lists
  + eg ::
    #+begin_src org :exports src
    a. item one
    b. item two
    #+end_src
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; allow character letters as bullet in item lists
    (setq org-alphabetical-lists t)
    #+end_src
  + in order for filling to work correctly this needs to be set *before the exporters are loaded*

*** Delete IDs when cloning
  + setup ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    ; delete IDs when cloning
    (setq org-clone-delete-id t)
    #+end_src

** Deprecated use (things no longer used anymore by bh)
  + partial, ==org-mode== is huge with features, some features are not know about yet by bh, or haven't be explored, so list likely to not be complete
*** Archive Sibling
  + can be tempting, but archiving entire complete subtrees is more tempting, no worries to have bunch of tasks marked ==DONE== (but not archived) 

*** Strike-through emphasis
  + strike-through emphasis can be unreadable and tends to only show up when pasting data from other files into org-mode
  + setup to remove the strike-through completely which can be a lot nicer ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-emphasis-alist (quote (("*" bold "<b>" "</b>")
                                     ("/" italic "<i>" "</i>")
                                     ("_" underline "<span style=\"text-decoration:underline;\">" "</span>")
                                     ("=" org-code "<code>" "</code>" verbatim)
                                     ("~" org-verbatim "<code>" "</code>" verbatim))))
    #+end_src

*** Subscripts and Superscripts
  + if you don't need document that need subscripts and superscript support, you can disable handling of ==_== and ==^== for subscript and superscripts ::
    #+header: :tangle yes
    #+begin_src emacs-lisp
    (setq org-use-sub-superscripts nil)
    #+end_src
  + an alternative to cancelling sub/super-scripts by default is including a setup file with common property to every org files not needing those (following setup not evaluated) ::
    #+begin_src org :exports src
    , #+options: ^:nil _:nil
    #+end_src
* Keybindings
- my kbd ::
  #+header: :tangle yes
  #+begin_src emacs-lisp
  ;; my kbd
  ;; By default Org mode buffers need Font Lock to be turned on. So, for a better experience, these three Org commands ought to be accessible anywhere in Emacs
  ;; , not just in Org buffers => need to bind them to globally available keys, like ones reserved for users (see (elisp)Key Binding Conventions).
  (global-set-key (kbd "C-c l") #'org-store-link) ;; for handling links
  (global-set-key (kbd "C-c a") #'org-agenda) ;; org-agenda :)
  (global-set-key (kbd "C-c c") #'org-capture) ;; previously known as 'remember' (notes taking)
  
  ;; undo tree mode (for more popular undo-redo using C-z C-S-z)
  ;;turn on everywhere
  (global-undo-tree-mode 1)
  ;; make ctrl-z undo
  (global-set-key (kbd "C-z") 'undo)
  ;; make ctrl-Z redo
  (defalias 'redo 'undo-tree-redo)
  (global-set-key (kbd "C-S-z") 'redo)
  
  ;; define special key to capture particular template without going through interactive template selection
  (define-key global-map (kbd "C-c t")
    (lambda () (interactive) (org-capture nil "t")))
  
  ;; auto fill in text modes (NOT word completion, but auto-fill: lines are broken automatically at spaces/RET when line too long.)
  ;; to turn on auto-fill mode for every buffer in a certain mode, you must use the hook for that mode, here for example: text-mode to turn on auto fill mode on all text buffers
  ; (add-hook 'text-mode-hook 'turn-on-auto-fill)
  ;; to turn on auto-fill mode on all major modes
  ; (setq-default auto-fill-function 'do-auto-fill)
  ;;; to activate auto fill just in current buffer
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
  
  ;; allow C-c d keybinding for line duplication (its defining function included too)
  (defun duplicate-line()
    (interactive)
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (open-line 1)
    (next-line 1)
    (yank)
  )
  (global-set-key (kbd "C-c d") 'duplicate-line)  
  
  #+end_src
- bh's kbds ::
  #+header: :tangle yes
  #+begin_src emacs-lisp
  ;; bh Custom Key Bindings
  ;; ======================
  ;; bh is from source Bernt Hansen : http://doc.norang.ca/org-mode.html
  ;; main reason for special key bindings (like F11, and F12) is to have keys work in any mode. If for ex the Gnus summary buffer then C-u C-c C-x C-i doesn't work, but the C-F11 key combination does and this saves time since don't have to visit an org-mode buffer first just to clock in a recent task.

  (global-set-key (kbd "<f9> p") 'bh/phone-call)
  (global-set-key (kbd "<f12>") 'org-agenda)
  (global-set-key (kbd "<f5>") 'bh/org-todo)
  (global-set-key (kbd "<S-f5>") 'bh/widen)
  (global-set-key (kbd "<f7>") 'bh/set-truncate-lines)
  (global-set-key (kbd "<f8>") 'org-cycle-agenda-files) ;; Cycle through agenda file list, visiting one file after the other.
  (global-set-key (kbd "<f9> <f9>") 'bh/show-org-agenda)
  ;; (global-set-key (kbd "<f9> b") 'bbdb)
  (global-set-key (kbd "<f9> c") 'calendar)
  (global-set-key (kbd "<f9> f") 'boxquote-insert-file)
  ;; (global-set-key (kbd "<f9> g") 'gnus)
  (global-set-key (kbd "<f9> h") 'bh/hide-other)
  (global-set-key (kbd "<f9> n") 'bh/toggle-next-task-display)
  
  (global-set-key (kbd "<f9> I") 'bh/punch-in)
  (global-set-key (kbd "<f9> O") 'bh/punch-out)
  
  (global-set-key (kbd "<f9> o") 'bh/make-org-scratch)
  
  (global-set-key (kbd "<f9> r") 'boxquote-region)
  (global-set-key (kbd "<f9> s") 'bh/switch-to-scratch)
  
  (global-set-key (kbd "<f9> t") 'bh/insert-inactive-timestamp)
  (global-set-key (kbd "<f9> T") 'bh/toggle-insert-inactive-timestamp)
  
  (global-set-key (kbd "<f9> v") 'visible-mode)
  (global-set-key (kbd "<f9> l") 'org-toggle-link-display)
  (global-set-key (kbd "<f9> SPC") 'bh/clock-in-last-task) ;; not needed much anymore thanks to punch-in/out (see http://doc.norang.ca/org-mode.html#ClockSetup) 
  (global-set-key (kbd "C-<f9>") 'previous-buffer)
  (global-set-key (kbd "M-<f9>") 'org-toggle-inline-images)
  (global-set-key (kbd "C-x n r") 'narrow-to-region)
  (global-set-key (kbd "C-<f10>") 'next-buffer)
  (global-set-key (kbd "<f11>") 'org-clock-goto)
  (global-set-key (kbd "C-<f11>") 'org-clock-in)
  (global-set-key (kbd "C-s-<f12>") 'bh/save-then-publish) ;; needs first configs for publishing multiple files/project
  #+end_src
* Programming language specific
** C++
 - notes ::
   + different sources, but mainly ::
     - c++ mode from official documentation :: https://www.emacswiki.org/emacs/CPlusPlusMode
 - basic configs ::
   #+header: :tangle yes
   #+begin_src emacs-lisp
   ;; M-x c++-mode :: to activate c++-mode on .h files that won't be opened as c++ files by default (otherwise, will be opened as c file)
   (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
   #+end_src

* Miscellaneous (good to know)
  + emacs windows vs frames ::
    - windows :: view of buffer(s), each buffer is viewed into a 'window' and/or inside a same 'frame'
    - frame :: what's usually called "window", can contain different 'windows', that are view of buffers
  + ==use-package== vs ==require== :: interchangeable, *but*:
    - require :: tries to load an installed feature
    - use-package :: installs it if it has not already been loaded, but not loaded, which is the main difference with ==require==
  + ==major== vs ==minor== mode ::
    - major mode ::
      + provides specialized facilities for working on a particular file type (eg: a C source file), or a particular type of non-file buffer (eg: shell buffer)
      + major modes are mutually exclusive; each buffer has one and only one major mode at any time
    - minor mode ::
      + are optional features which can be turned on/off, not necessarily specific to a type of file or buffer (eg: Auto Fill mode is a minor mode in which ==SPC== breaks lines between words as typeed)
      + minor modes are independent one another, and of the selected major mode.
  + ==CATEGORY== vs ==TAG== drawers ::
    - Categories :: method for assigning single classifications, each heading is part of exactly one category, not many
      + from https://karl-voit.at/2019/09/25/categories-versus-tags/ ::
        - characteristics, three different ways of assigning categories ::
          + One per file
          + Category per project within a file
          + Multi-file
        - eg of multi-file categories ::
          + Multi-file :: when several Org files share a category
            - eg :: using category ==company== for files 'company.org' (miscellaneous general todos), 'company_projectX.org' (related to one specific project), company_projectY.org (related to a different project), etc.
            - if one does not manually tamper with assigning categories, Org mode is uses the file name of the current file as category by default, eg : company.org results in the category "company" for all of its headings
            - in case one needs finer grained categories, one has the possibility to assign a category for any given sub-hierarchy, eg for file 'company.org'
            - eg ::
              #+begin_src org :exports src
              ,* Project X
              ,** TODO Contact Bill Gates
              ,** TODO Make business
              ,* Project Y
              ,  :PROPERTIES:
              ,  :CATEGORY: ProjectY
              ,  :END:
              ,** TODO Find a business plan
              ,** SOMEDAY Follow the business plan
              ,** SOMEDAY Get rich
              #+end_src
            - notes ::
              + the todos of Project X do have the default category ==company==, derived from the file 'company.org'
              + all todos within the Project Y hierarchy do share the category "ProjectY" instead because this is defined via the ==CATEGORY== property in the drawer
                - when being on a line whose task is categorised with ==ProjectY==, the agenda now only shows tasks of this category, hiding everything else
    - Tags :: allow for multi-classification. A heading is able to have a set of assigned tags
      + a heading is able to inherit the combined set of all tags assigned to its parent headings, if activated
    - tag vs categories :: limit categories to a minimum, mostly by using the default: one category per Org mode file

* Raw (to be refiled)
 - setting excluding tags (check if doesn't conflict with bh's configs) ::
   #+header: :tangle yes
   #+begin_src emacs-lisp
   
   ;; ;; 'GTD' : TODO state triggers (TODOs, DONE, STARTED, etc. can tune as prefer)
   ;; (eval-after-load "org"
   ;;   '(progn
   ;;      (define-prefix-command 'org-todo-state-map)
   ;; 
   ;;      (define-key org-mode-map "\C-cx" 'org-todo-state-map)
   ;; 
   ;;      (define-key org-todo-state-map "x"
   ;; 	#'(lambda nil (interactive) (org-todo "CANCELLED")))
   ;;      (define-key org-todo-state-map "d"
   ;; 	#'(lambda nil (interactive) (org-todo "DONE")))
   ;;      (define-key org-todo-state-map "f"
   ;; 	#'(lambda nil (interactive) (org-todo "DEFERRED")))
   ;;      (define-key org-todo-state-map "l"
   ;; 	#'(lambda nil (interactive) (org-todo "DELEGATED")))
   ;;      (define-key org-todo-state-map "s"
   ;; 	#'(lambda nil (interactive) (org-todo "STARTED")))
   ;;      (define-key org-todo-state-map "w"
   ;; 	#'(lambda nil (interactive) (org-todo "WAITING")))))
   
   ;;     (define-key org-agenda-mode-map "\C-n" 'next-line)
   ;;     (define-key org-agenda-keymap "\C-n" 'next-line)
   ;;     (define-key org-agenda-mode-map "\C-p" 'previous-line)
   ;;     (define-key org-agenda-keymap "\C-p" 'previous-line)))
   
   #+end_src

* 


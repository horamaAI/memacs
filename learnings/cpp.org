# -*- mode: org -*-
#+title: cpp and modern cpp notes
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+TAGS: Cpp C++

* foreword, UML, and general notes
  + UML notation ::
    - visibility :: + Public - Private # Protected ~ Package
    - relations ::
      + associations :: two objects are linked (directly, or indirectely), chose one which will implement a public function, and the other linked to it will contain the object as private and 'friend' the former.
      + realisation/implementation :: when interface is implement
      + dependency :: indicates that a change to one class, the supplier, might cause a change in the other class, the consumer. The supplier is independent because a change in the consumer does not affect the supplier.
	- 
      + aggregation :: special case of an association meaning “consists of”:
	- eg :: student has many teachers
	- if container dies, content doesn't die with it :: eg : if
          teachers leaves, his students stay
	- implementation :: 'super object' (professor here) has a list of reference to 'sub' object (class)
      + generalisation :: process of extracting shared characteristics from two or more classes, and combining them into a generalized superclass.
	- whereas *specialization* :: creating new subclasses from an existing class, eg : in inheriting subclasses, add more characteristics from superclasses
      + composition :: special case of association, xstrong aggregation,  represents a whole–part relationship and is a form of aggregation. A composition association relationship specifies that the lifetime of the part classifier is dependent on the lifetime of the whole classifier.
	- in a composition association relationship, data usually flows in only one direction (that is, from the whole classifier to the part classifier).
	- eg : composition association relationship connects a Student class with a Schedule class, which means that if you remove the student, the schedule is also removed.

* Topics
- operator overloading (c++98) ::
- call operator (c++98) ::
- braced initialization (c++11) ::
- direct initialization of member functions (c++98) ::
- initializer_list (c++11) :: 
- "compiler magic" ::
- compilation model :: 
- reference members (c++98) ::
- 'auto' return type deduction (c++14) ::
- constexpr (c++11) ::
- lambdas (c++11) ::
  + immediately invoked lambdas (c++11) ::
  + recursive lambdas (c++23) :: 
- attributes on parameters (c++11) ::
- pass by value vs by reference (c++98) ::
- implicit conversion (c++98) ::
- function pointers (c++98) ::
- static member functions (c++98) ::
- non-const member functions (c++98) ::
- deducing 'this' (c++23) :: 
- using aliases (c++11) ::
- efficiency when chaining functions ::
- preprocessor :: 
- templates (c++98) ::
- template argument type deduction (c++98) ::
- alias templates (c++11) ::
- variable templates :: 
- templates instantiations (c++98) ::
- 'noexcept' (c++11) ::
- 'noexcept' in the type system (c++17) ::
- functions attributes (c++11) ::
- variadic templates (c++11) ::
- variadic lambdas (c++14) ::
- integer sequences (c++11) ::
- variadic 'sizeof...()' operator (c++11) :: 
- fold expressions (c++17) ::
- variadic 'using' declarations (c++17) :: 
- non type template parameters (c++98) ::
- template parameter pattern matching (c++11) ::
- explicit lambda templates (c++17) ::
- class template argument deduction (c++17/c++20) ::
- deduction guides (c++17) :: 
- algorithms and stl (c++11) ::
- ranges (c++20) ::
- '<functional>' (c++11) ::
- type_traits :: 
- 'mutable' keyword (c++98) ::
- members copies (c++98) ::
- trivially copiable types (c++98) :: 
- return value optimization (c++98) ::
- guaranteed return value optimization (c++17) ::
- object layouts (c++98) ::
- member padding (c++98) ::
- order of construction/destruction (c++98) ::
- scoping/lookup rules (c++98) ::
- higher order functions ::
- function hiding (c++98) :: 
- concepts, custom concepts (c++20) ::
- tuples and unpacking of tuples (c++11) :: 
- virtual member functions (c++98) ::
- member function pointers (c++98) :: 
- special member functions (c++98/11) :: 
- member function call syntax (c++98) ::
- type erasure (c++98) ::
- three-way comparison operator (operator '<=>') :: 
- dynamic vs automatic storage (c++98) ::
- project structure and layout (design part ??) :: 
- coroutines (design ??) ::
- modules (design ??) :: 
- ODR violations ::

* Assembler
** Sources
- cheatsheet :: https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
- cppcon2021, "Just Enough Assembly for Compiler Explorer" :: https://www.youtube.com/watch?v=_sSFtJwgVYQ
** Notes
*** keywords
- "byte" refers to a one-byte integer
- "word" refers to a two-byte integer
- "doubleword" refers to a four-byte integer
- "quadword" refers to an eight-byte value
* Best practices
* Glossary
  - programming :: writing program that creates, transforms, filters, aggregates and otherwise manipulates data.
  - Metaprogramming :: writing a program that creates, transforms, filters, aggregates and otherwise manipulates *programs*.
  - Generic programming :: writing a program that creates, transforms, filters, aggregates and otherwise manipulates data, but makes only the minimum assumptions about the structure of the data, thus maximizing reuse across a wide range of datatypes.
  - Note on difference between metaprogramming and generic programming ::
    + generic Programming and (static/compile time) metaprogramming are both done with Templates
    + plus, generic programming uses Metaprogramming to be efficient, i.e. Template Specialization generates specialized (fast) programs from generic ones.
* CMAKE
* Unit testing

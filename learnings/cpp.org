# -*- mode: org -*-
#+title: cpp and modern cpp notes
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+TAGS: Cpp C++

* UML, and engineering design
  + UML notation ::
    - visibility :: + Public - Private # Protected ~ Package
    - relations ::
      + associations :: two objects are linked (directly, or indirectely), chose one which will implement a public function, and the other linked to it will contain the object as private and 'friend' the former.
      + realisation/implementation :: when interface is implement
      + dependency :: indicates that a change to one class, the supplier, might cause a change in the other class, the consumer. The supplier is independent because a change in the consumer does not affect the supplier.
	- 
      + aggregation :: special case of an association meaning “consists of”:
	- eg :: student has many teachers
	- if container dies, content doesn't die with it :: eg : if
          teachers leaves, his students stay
	- implementation :: 'super object' (professor here) has a list of reference to 'sub' object (class)
      + generalisation :: process of extracting shared characteristics from two or more classes, and combining them into a generalized superclass.
	- whereas *specialization* :: creating new subclasses from an existing class, eg : in inheriting subclasses, add more characteristics from superclasses
      + composition :: special case of association, xstrong aggregation,  represents a whole–part relationship and is a form of aggregation. A composition association relationship specifies that the lifetime of the part classifier is dependent on the lifetime of the whole classifier.
	- in a composition association relationship, data usually flows in only one direction (that is, from the whole classifier to the part classifier).
	- eg : composition association relationship connects a Student class with a Schedule class, which means that if you remove the student, the schedule is also removed.

* Notes
[2024-03-02 Sat 02:37]
- vtables :: virtual method tables
  + whenever a class defines a virtual function/method, most compilers add a hidden member variable to the class that points to an array of pointers to (virtual) functions called the ==virtual method table==. These pointers are used at runtime to invoke the appropriate function implementations, because at compile time it may not yet be known if the base function is to be called or a derived one implemented by a class that inherits from the base class. 
  + vtables are the most common implementation of polymorphism in C++
  + when vtables are used, every polymorphic class has a vtable somewhere in the program; you can think of it as a (hidden) *static* data member of the class. Every object of a polymorphic class is associated with the vtable for its most-derived class. By checking this association, the program can work its polymorphic magic.
    - a vtable is an implementation detail, it is not mandated by the C++ standard, but most (all?) C++ compilers use vtables to implement polymorphic behaviour. Compilers are allowed to deviate from this however.
* Topics
- operator overloading (c++98) ::
- call operator (c++98) ::
- braced initialization (c++11) ::
- direct initialization of member functions (c++98) ::
- initializer_list (c++11) :: 
- "compiler magic" ::
- compilation model :: 
- reference members (c++98) ::
- 'auto' return type deduction (c++14) ::
- constexpr (c++11) ::
- lambdas (c++11) ::
  + immediately invoked lambdas (c++11) ::
  + recursive lambdas (c++23) :: 
- attributes on parameters (c++11) ::
- pass by value vs by reference (c++98) ::
- implicit conversion (c++98) ::
- function pointers (c++98) ::
- static member functions (c++98) ::
- non-const member functions (c++98) ::
- deducing 'this' (c++23) :: 
- using aliases (c++11) ::
- efficiency when chaining functions ::
- preprocessor :: 
- templates (c++98) ::
- template argument type deduction (c++98) ::
- alias templates (c++11) ::
- variable templates :: 
- templates instantiations (c++98) ::
- 'noexcept' (c++11) ::
- 'noexcept' in the type system (c++17) ::
- functions attributes (c++11) ::
- variadic templates (c++11) ::
- variadic lambdas (c++14) ::
- integer sequences (c++11) ::
- variadic 'sizeof...()' operator (c++11) :: 
- fold expressions (c++17) ::
- variadic 'using' declarations (c++17) :: 
- non type template parameters (c++98) ::
- template parameter pattern matching (c++11) ::
- explicit lambda templates (c++17) ::
- class template argument deduction (c++17/c++20) ::
- deduction guides (c++17) :: 
- algorithms and stl (c++11) ::
- ranges (c++20) ::
- '<functional>' (c++11) ::
- type_traits :: 
- 'mutable' keyword (c++98) ::
- members copies (c++98) ::
- trivially copiable types (c++98) :: 
- return value optimization (c++98) ::
- guaranteed return value optimization (c++17) ::
- object layouts (c++98) ::
- member padding (c++98) ::
- order of construction/destruction (c++98) ::
- scoping/lookup rules (c++98) ::
- higher order functions ::
- function hiding (c++98) :: 
- concepts, custom concepts (c++20) ::
- tuples and unpacking of tuples (c++11) :: 
- virtual member functions (c++98) ::
- member function pointers (c++98) :: 
- special member functions (c++98/11) :: 
- member function call syntax (c++98) ::
- type erasure (c++98) ::
- three-way comparison operator (operator '<=>') :: 
- dynamic vs automatic storage (c++98) ::
- project structure and layout (design part ??) :: 
- coroutines (design ??) ::
- modules (design ??) :: 
- ODR violations ::

* Assembler
** Sources
- cheatsheet :: https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
- cppcon2021, "Just Enough Assembly for Compiler Explorer" :: https://www.youtube.com/watch?v=_sSFtJwgVYQ
** Notes
- compiling to machine code general process :: lexical analysis -> syntax analysis -> semantic analysis -> intermediate code generation -> code optimization -> target code generation
- c++ code source compiling process ::
  + source code -(preprocessor)-> expanded code -(compiler)-> assembly code -(assembler)-> object code (+other object files, and libraries) -(linker)-> executable code
  + preprocessor :: instructions that start with ==#== (#include, #define, #ifdef, etc.), are usually completed in the pre-processing stage: opens all quoted header files, replace all the macros, remove comments, remove from conditional compilation the parts that don't meet the conditions defined in the #ifdefs
    - with gcc, can provide flag ==-E== to stop process to the pre-processing stage (to stop after the preprocessing stage, and do not run the compiler)
  + compiler :: check program for any lexical/grammatical/semantic errors; and generate assembly code. Assembly language only uses some machine language based mnemonics.
    - gcc option ==-S== to stop after compilation proper, and do not assemble
  + assembly :: convert the assembly code generated by the compiler into executable (machine language that can be executed by the machine).
    - gcc ==-c== to assemble assembly code into object code, but not link
  + linker :: system program needed to bind generated binary/object code (and libraries; such as windows' dll (dynamic-link library)) and combine them into an executable, library, or another object file
    - usually, a computer program do not need to be contained within a single object file. In such case, its parts/modules refer to each other using ==symbols== as addresses into other modules, which are mapped into memory addresses when linked for execution. The process of linking is meant to combine these independent parts. The advantage of separating those parts are, among others, ease of organizing several smaller pieces, and the ability to better define the purpose and responsibilities of each individual piece (scalability and maintenance)
    - notes ::
      + debug symbol :: special kind of symbol that attaches additional information to the symbol table of an object file, such as a shared library or an executable. This information allows a symbolic debugger to gain access to information from the source code of the binary, such as the names of identifiers, including variables and routines
      + object files can contain three kinds of symbols ::
        - defined 'external' symbols, sometimes called "public" or "entry" symbols, which allow it to be called by other modules,
        - undefined 'external' symbols, which reference other modules where these symbols are defined,
        - local symbols, used internally within the object file to facilitate relocation (assigning load addresses for position-dependent code and data of a program and adjusting the code and data to reflect the assigned addresses)
      + the linker also takes care of arranging the objects in a program's address space. This may involve relocating code that assumes a specific base address into another base. Since a compiler seldom knows where an object will reside, it often assumes a fixed base location (for example, zero). Relocating machine code may involve re-targeting absolute jumps, loads, and stores.
      + the executable output by the linker may need another relocation pass when it is finally loaded into memory (just before execution)
      + further notes :: 
        - for most compilers, object files are the results of compiling an input source code file. When a program comprises multiple object files, the linker combines these files into a unified executable program, resolving the symbols as it goes along.
        - linkers can take objects from a library or runtime library.
        - most linkers do not include *all* the object files in a static library in the output executable; they include only those object files from the library that are referenced by other object files or libraries directly or indirectly.
          + static libraries :: set of routines, external functions and variables which are resolved in a caller at *compile-time* and copied into a target application by a compiler, linker, or binder, producing an object file and a stand-alone executable.
        - for a shared library, the entire library has to be loaded during runtime as it is not known which functions or methods will be called during runtime
    - dynamic linking :: many OS environments allow dynamic linking, deferring the resolution of some undefined symbols until a program is run. That means that the executable code still contains undefined symbols, plus a list of objects or libraries that will provide definitions for these. Loading the program will load these objects/libraries as well, and perform a final linking.
      + advantages :: 1. often-used libraries (eg: the standard system libraries) need to be stored in only one location, not duplicated in every single executable file, thus saving limited memory and disk space; 2. if a bug in a library function is corrected by replacing the library or performance is improved, all programs using it dynamically will benefit from the correction after restarting them. Programs that included this function by static linking would have to be re-linked first.
      + disadvantages :: 1. 'dll hell' on windows: an incompatible updated library will break executables that depended on the behavior of the previous version of the library if the newer version is not correctly backward compatible; 2. a program, together with the libraries it uses, might be certified (e.g. as to correctness, documentation requirements, or performance) as a package, but not if components can be replaced (this also argues against automatic OS updates in critical systems; in both cases, the OS and libraries form part of a qualified environment).
    - static linking :: result of the linker copying all library routines used in the program into the executable image. May require more disk space and memory than dynamic linking, but is more portable, since does not require the presence of the library on the system where it runs. Also prevents 'DLL hell', since each program includes exactly the versions of library routines that it requires, with no conflict with other programs. Programs using just a few routines from a library do not require the entire library to be installed.
    - relocation :: the compiler has no information on the layout of objects in the final output, it cannot take advantage of shorter or more efficient instructions that place a requirement on the address of another object. For example, jump instructions can reference an absolute address or an offset from the current location, and the offset could be expressed with different lengths depending on the distance to the target. By first generating the most conservative instruction (usually the largest relative or absolute variant, depending on platform) and adding relaxation hints, it is possible to substitute shorter or more efficient instructions during the final link. In regard to jump optimizations this is also called automatic jump-sizing. This step can be performed only after all input objects have been read and assigned temporary addresses; the linker relaxation pass subsequently reassigns addresses, which may in turn allow more potential relaxations to occur. In general, the substituted sequences are shorter, which allows this process to always converge on the best solution given a fixed order of objects; if this is not the case, relaxations can conflict, and the linker needs to weigh the advantages of either option. 
  + gcc flags ::
    - -E :: stop after the preprocessing stage; do not run the compiler proper
    - -S :: stop after the stage of compilation proper; do not assemble
    - -c :: compile or assemble, but do not link
    - -o <file> :: place output in <file>. Applies regardless to whatever sort of output being produced: executable file, object file, assembler file or preprocessed C code. If -o is not specified, the default is to put an executable file in a.out
** keywords
[2024-04-02 Tue 16:17]
- "byte" refers to a one-byte integer
- "word" refers to a two-byte integer
- "doubleword" refers to a four-byte integer
- "quadword" refers to an eight-byte value
* Best practices
* Glossary
  - programming :: writing program that creates, transforms, filters, aggregates and otherwise manipulates data.
  - Metaprogramming :: writing a program that creates, transforms, filters, aggregates and otherwise manipulates *programs*.
  - Generic programming :: writing a program that creates, transforms, filters, aggregates and otherwise manipulates data, but makes only the minimum assumptions about the structure of the data, thus maximizing reuse across a wide range of datatypes.
  - Note on difference between metaprogramming and generic programming ::
    + generic Programming and (static/compile time) metaprogramming are both done with Templates
    + plus, generic programming uses Metaprogramming to be efficient, i.e. Template Specialization generates specialized (fast) programs from generic ones.
* CMAKE
* Unit testing

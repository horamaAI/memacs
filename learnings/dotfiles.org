# -*- mode: org -*-
#+TITLE: my dotfiles structure and configs but in orgmode
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+LANGUAGE: en
#+OPTIONS: toc:3 timestamp:t
#+DESCRIPTION: My dotfiles structure, configs and descriptions (got most of them from Bernt Hansen (http://doc.norang.ca/org-mode.html))
#+KEYWORDS: dotfiles org-mode Emacs organization GTD getting-things-done git


* Intro
** Notes
- sources ::
  + main reference :: https://dotfiles.github.io/tutorials/
- what is it used for ::
  + handy way to customize one's system ('dotfiles' is derived from Unix-like systems' configuration files that start with a dot: .bash_profile, .gitconfig, etc.)
  + fetching configurations whenever needed and ready to go; easy to deploy when installing from scratch; useful for syncing preferences across multiple devices
- existing dotfiles configurations are diverse and with various styles. dotfiles are very personal, no "one way to rule them all" setup
- alternative to symlinking the machine's configuration files to $HOME/* for example (though symlinking is part of some dotfiles configuration styles)
- better to split user and hostname-based configurations containing configuration files based on target environment and specific configurations : ==user, server, common, private, public, work, work-a, etc.==
  + for ease of use and retrieval, better to add target's specific configuration files into these configuration directories, eg: ~user/configuration-file~
** awesome dotfiles (list of existing dotfiles repos and other dotfiles related tools)
[2024-05-29 Wed 21:19]
- https://github.com/webpro/awesome-dotfiles
** some dotfiles stuff
[2024-05-26 Sun 21:39]
- files name :: 
  + .alias ::
  + .env :: for environment variables
  + .functions :: for functions that are too complex to be aliases, and too short to be added as scripts
  + .inputrc :: for keybindings and other keys behaviour, eg: ~set completion-ignore-case on~
* Getting started with dotfiles (very basic descriptions)
[2024-05-29 Wed 20:02]
** Notes
- sources ::
  + https://www.webpro.nl/articles/getting-started-with-dotfiles
    - see Lars Kappert's [[https://github.com/webpro/dotfiles][dotfiles configs]], and [[https://github.com/mathiasbynens/dotfiles][Mathias Bynens' one]] (Lars based his configs from his)
  + https://kalis.me/dotfiles-automating-macos-system-configuration/
- tips and tricks ::
  + structure abd organise dotfiles in directories as per your need: topic/environment/hostname/etc.
  + use version control systems "branches" to adapt configs to different systems (linux distros, macOS, etc.)
  + set root installer to use basic tools such as curl or wget (later usually not available on vanilla linux), and add git as a further installation (see example: ~bash -c "`curl -fsSL https://raw.githubusercontent.com/webpro/dotfiles/master/remote-install.sh`"~)
  + use dependencies manager or other tools for dependencies and additional tools (eg: cmake, makefile, ansible, etc.)
  + git actions, git submodules, and git subtree are powerful tools to enhance dotfiles configurations
  + updating dotfiles script(s) :: plan for a smooth and idempotent (same and deterministic results for each run) script/ update
    - why :: fix symlinks, update packages
  + create '*.yaml' files for tool specific installations, eg: ~apt.yaml~ for packages to install with apt, ~npm.yaml~ for those to install with npm, etc.
    - source :: https://kalis.me/dotfiles-automating-macos-system-configuration/
    - same, can also create '*.yaml' files for repositories and make a script to automatise the git cloning
    - can be tidier to group repository folders, per project or topic for example, eg: ==~/dev/personal==, ==~/dev/work==,  ==~/dev/research==, etc.
    - eg: (.list files are instead to be used as .yaml files)
      #+begin_example
      #! /usr/bin/env sh
      
      DIR=$(dirname "$0")
      cd "$DIR"
      
      COMMENT=\#*
      REPO_PATH=$(realpath ~/repos)
      
      find * -name "*.list" | while read fn; do
          folder="${fn%.*}"
          mkdir -p "$REPO_PATH/$folder"
          while read repo; do
              if [[ $repo == $COMMENT ]];
                  then continue;
              else
                  pushd "$REPO_PATH/$folder"
                  git clone $repo
                  popd
              fi
          done < "$fn"
      done
      #+end_example
* dotfiles configurations styles
[2024-05-24 Fri 23:41]
** dotfiles and topical organisation (dotfiles organised into directories, each entitled to specific subject)
[2024-05-26 Sun 19:35]
- notes ::
  + example of topical organisation: has directories: ==git/==, ==ruby/==, etc., each dedicated to appropriate settings: git, ruby, etc.
  + directories have each their own aliases, path settings, etc., separated
- pros and cons ::
  + pros ::
    - neat structure, easy to navigate
  + cons ::
    - too many directories, most of the time too few content, and with too few rules in those files content
** dotfiles as git repositories ($HOME only, or one hostname-based configuration per git repo)
[2024-05-24 Fri 22:35]
- Notes ::
  + purpose :: having $HOME as git repository: any personal config can be repurposed on any new installation
  + main idea :: set ~$HOME/.gitignore~ to contain only one byte element: ~*~
    - that way, unless a file is added explicitly (with ~git add -f~, or ~--force~, eg: ~git add -f .zshrc_user~), unwanted $HOME element are not added to the repo
    - after ==--force==, gitignore configs won't apply to files already being tracked by git: so, any future changes to files previously added with ==force== will show up in git status, diff, etc., and will be easily committed, staged, etc., with ==-f== no longer necessary
  + setting up a new machine is then easy :: after installation, just:
    #+begin_example
    cd ~
    git init
    git remote add origin [your-dotfiles-git-repo]
    git fetch
    git checkout -f [your-master-branch]
    #+end_example
  + with this dotfiles configuration as repo, it's even possible to shadow system programs by wrapping those sometimes not easy to configure system programs with custom scripts/actions: put ~$HOME/bin~ always ahead of any other tools in ~$PATH~:
    - example: wrap xdg-open with custom pre-commands in script ==~/bin/xdg-open== (replace annoying-to-customize xdg-open with own version, and only fall back to /usr/bin/xdg-open if necessary):
      #+begin_example
      #!/bin/sh
      case "${1%%:*}" in
      	http|https|*.pdf)
      		exec qutebrowser "$1"
      		;;
      	mailto)
      		exec aerc "$1"
      		;;
      	*)
      		exec /usr/bin/xdg-open "$@"
      		;;
      esac
      #+end_example
  + configuring custom dotfiles for other environments/distributions/hosts/purpose ::
    - the same as ~$HOME/bin~ is prefixed before any other element in ~$PATH~ for custom configs, one can further customise the dotfiles to consider different hostnames: just need to preface ~$HOME/bin/$(hostname)~ before ~$HOME/bin~ in $PATH
      + to also consider the different architectures in the configurations: can add ~$HOME/bin/$(uname -m)~ configurations to the dotfiles repo
        - eg: to customize sway configurations to consider the different device configurations of each host, use following directive in ==~/.config/sway/config==: ~include ~/.config/sway/`hostname`~
      + same, if want configurations specific to server for example, use its ~$HOME/bin/server~ path before
- pros and cons ::
  + pros ::
    - main tools and configurations ready to use :: ==~/bin, ~/lib, ~/config==, etc.
  + cons ::
    - one hostname-based configuration per repo. Further configurations need to add those in the repo, with all different usecases, architectures, etc.
** dotfiles as --bare git repositories
[2024-05-29 Wed 22:25]
- notes ::
  + sources ::
    - https://www.atlassian.com/git/tutorials/dotfiles
  + 'bare' repositories :: can be seen as "side" repositories that don't update its content with usual git commands such as git pull/push (see [[https://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/]["working" vs "bare" repositories]]), and need specific way to do so
    - by convention, bare repos need to have extension ==.git== (eg: ~mybarerepo.git~)
    - bare repos can be seen as 'shared' repos, where one can only push/pull from, but never directly commit to
    - recommended for shared and central repositories, kind of 'managers' repos
    - most common use case for  ~git init --bare~ is creating a remote central repository: ~ssh <user>@<host> cd path/above/repo git init --bare my-project.git~
      + ssh connect to server containing bare repository, create bare repo, and then users will clone bare repo to create local repo
  + => prerequisite :: have git pre-installed
  + pros ::
    - no extra tools, or symlinks, the files are tracked with a version control system
    - switch to extra branch and fetch to include different environment
  + cons ::
    - complex actions to segregate specific data to push
  + main idea ::
    - create a bare repository to interact with when updating mother configuration (eg: ~$HOME/.cfg~, or ~$HOME/.topcfg~)
    - add alias for interactions with the bare repository instead of using the usual git (otherwise it would interfere with working repository)
*** process
- example ::
  #+begin_example
  $git init --bare $HOME/.cfg
  # creates alias to use a specific git command with git directory the bare repo, and with work-tree set at $HOME
  $alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
  # flag --local to hide files not explicitly tracked yet
  # twice 'config' might be a typo, check first without
  $config config --local status.showUntrackedFiles no
  # add config alias to bash/zsh startup file
  $echo "alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'" >> $HOME/.bashrc
  #+end_example
- after setup steps :: any file within ~$HOME~ can be versioned using ~config~:
  #+begin_example
  config status
  config add .vimrc
  config commit -m "Add vimrc"
  config add .bashrc
  config commit -m "Add bashrc"
  config push
  #+end_example
- installing dotfiles on new system ::
  + first ::
    - make sure ~config~ alias is set on bash or zsh :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
    - and that source repo will ignore folder where will be cloned :: (otherwise might create weird recursion issues): ~echo ".cfg" >> .gitignore~
  + then clone dotfiles into bare repo :: ~git clone --bare <git-repo-url> $HOME/.cfg~
  + define alias in current shell scope :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
  + checkout actual content from the bare repository to $HOME :: ~config checkout~
    - if steps fails with following error:
      #+begin_example
      error: The following untracked working tree files would be overwritten by checkout:
          .bashrc
          .gitignore
      Please move or remove them before you can switch branches.
      Aborting
      #+end_example
    - it's due to existing config files
    - if need to backup:
      #+begin_example
      mkdir -p .config-backup && \
      config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | \
      xargs -I{} mv {} .config-backup/{}
      #+end_example
    - and rerun ~config checkout~
    - set flag showUntrackedFiles to no on the local repository: ~config config --local status.showUntrackedFiles no~
    - and done!
    - from there, can use ==config== to add/update dotfiles:
      #+begin_example
      config status
      config add .vimrc
      config commit -m "Add vimrc"
      config add .bashrc
      config commit -m "Add bashrc"
      config push
      #+end_example
  + example script for previous points ::
    #+begin_example
    git clone --bare https://bitbucket.org/durdn/cfg.git $HOME/.cfg
    function config {
       /usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME $@
    }
    mkdir -p .config-backup
    config checkout
    if [ $? = 0 ]; then
      echo "Checked out config.";
      else
        echo "Backing up pre-existing dot files.";
        config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | xargs -I{} mv {} .config-backup/{}
    fi;
    config checkout
    config config status.showUntrackedFiles no
    #+end_example
** dotfiles as host-based environment profiles with various tools
[2024-05-25 Sat 00:24]
** dotfiles for configs + ansible for dependencies
[2024-05-25 Sat 01:13]
* My dotfiles
[2024-06-01 Sat 15:25]
- draft ::
  + to include ::
    - [ ] add ppas for additional apt installs (https://github.com/cowboy/dotfiles/blob/master/init/20_ubuntu_apt.sh#L16)
    - [ ] packages and tools installation
      + setup for installation mandatory essentials packages (build-essential, emacs, python, npm, etc.) before installing other tools
      + example in [[https://github.com/rkalis/dotfiles/][this repo]], the main setup is running the [[https://github.com/rkalis/dotfiles/blob/master/bootstrap.sh#L30][main packages install]] (~./packages/setup.sh~ which is [[https://github.com/rkalis/dotfiles/blob/master/packages/setup.sh][here]]), and then locate and run the remaining setup (~find * -name "setup.sh" -not -wholename "packages*"~ and skips ~./packages/setup.sh~ which was run before)
      + [ ] '*.list' ([selected] '*.yaml') files for installation specific commands (filed by +command to use+ :used by function: ~[folder]/packages~, ~[folder]/opt~, etc.), eg: ~apt.yaml~ for packages to install with apt, ~npm.yaml~ for npm, ~python3.yaml~, etc.
        - [aborted] for packages to install, line starts with:
          + ==$== : then the line is the command to use for following packages
          + ==#== comment, skip
          + all remaining lines are packages to install using current command
        - [selected] use yaml file and install command content into a schema that validates
      + [ ] opt
      + [ ] git repositories
    - [ ] tools configs: .zshrc, .zshrc_user, oh-my-zsh, .screen, .inputrc, .alias, etc
    - [ ] emacs ::
      + add in-terminal settings
      + split profile for ==common== and ==dmahoro==
    - [ ] git:
      + [ ] git ci/cd, eg: git hooks
      + [ ] git configs with multiple configs (direnv maybe ?: https://direnv.net/)
        - checkout [[https://github.com/jogendra/dotfiles/blob/master/git/pull_request.sh][these cool git functions]] and [[https://github.com/jogendra/dotfiles/blob/master/git/gitconfig][configs]]
      + [ ] git bare repo ?
        - user's home is overflowing with dotfiles ('hidden'), mind it could be tedious if choose git bare and have to go through all the files to add to own dotfiles (https://web.archive.org/web/20171003124306/https://plus.google.com/+RobPikeTheHuman/posts/R58WgWwN9jp)
    - [ ] checkout use of environment variables $XDG_* (https://0x46.net/thoughts/2019/02/01/dotfile-madness/ and https://wiki.gentoo.org/wiki/XDG/Base_Directories)
      + $XDG_DATA_HOME or $HOME/.local/share for example to store plugins downloaded by the user, databases created by your program, user's input history, bookmarks, emails, and so on
    - [ ] optimise auto-complete
    - [ ] vim (learn basics, and tweak configs, seems there is no way to escape from it when working with bare installation or with the terminal)
    - [ ] IDE ::
      + add configs for one 'mainstream' IDE too, eg: vscode (settings, format, plugins, etc.)
    - [ ] ==user, server, common, private, business, work, work-a, etc.==
    - [ ] stow ?
      + at first glance yes: build folder ~dotfiles/$user~, so will most probably stow that folder
      + checkout [[https://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html][this]], [[https://spin.atomicobject.com/manage-dotfiles-gnu-stow/][this]] and [[https://blog.palcu.net/2014/06/dotfiles-and-dev-tools-provisioned-by.html][this one maybe]] which relies more on ansible ("bash on steroid")
    - [ ] live updates mechanism:
      + [ ] preferably add 'uninstall' or remove command
      + [ ] script for updating target 
    - [ ] ansible might be a robust alternative to writing custom bash script, for example, could be useful to manage when an action was successful, or when an error occurs, resume where left off
    - [ ] [[https://zellij.dev/documentation/][zellij]] (terminal multiplexer written in rust and made to be a better tool than tmux, which is written in C, and sometimes lacking)
      + checkout how to create workspaces: https://spin.atomicobject.com/dev-project-workspace-tmux/
      + checkout how to add more functionalities to it:
        - https://jolicode.com/blog/organiser-son-terminal-avec-des-workspaces
        - https://github.com/niflostancu/tmux-workspaces
    - [ ] zplugin ? : as a replacement for zplug (https://gist.github.com/laggardkernel/4a4c4986ccdcaf47b91e8227f9868ded)
- questions ::
  + target structure ::
    - should be different than the dotfiles structure ? => how will updates work when wants to change something and push it to dotfiles repo ?
- issues :: (while working on dotfiles)
  + testing dotfiles in an isolated (containerised) environment:
    - vim in containers:
      + not pre-installed, so need to install it first
      + vimrc:
    - podman:
      + podman is rootless (mainly):
        - by default, not able to use sudo (from within the container)
        - to be able to install packages for example, need to run rootful (from host)
        - no user environment predefined (eg: $USER)
      + workaround: (need for configurations to be added into a Containerfile ?)
        - run as rootful from host: ~sudo podman run~
        - manually set $USER since needed for $TARGET_FOLDER
        - silence out (comment) keep-alive checks for sudo ~if sudo -v; then~
        - cancel out "sudo": fortunately all dotfiles commands to run go through function ==dotfiles/configs/basic/bin/functions/utils.sh:execute_command==, so can filter out "sudo":
          #+begin_example
          mkdir -p repos && cd repos
          if [[ -n "$command_to_run" ]]; then
            eval "$command_to_run"
            if [[ "$command_to_run" == *"sudo"* ]]; then
              # thecmd=${command_to_run: 5} // remove since not specific enough
              thecmd=$(echo "$command_to_run" | sed -e 's/[[:space:]]*sudo[[:space:]]*//g')
              echo "the command to run: $thecmd"
              eval "$thecmd"
            fi
            #eval "$command_to_run"
          fi
          #+end_example
        - containerfile for build image:
          #+begin_example
          FROM alpine:latest
          ARG DOCKER_USER=default_user
          RUN addgroup -S $DOCKER_USER && adduser -S $DOCKER_USER -G $DOCKER_USER
          USER $DOCKER_USER
          CMD ["whoami"]
          #+end_example
- dotfiles structure :: source of things to do
  + install.sh ::
    - main entry point for dotfiles installation
  + configs :: 
    - any env, 'smthing.yaml', opt, in config other than basic, is an addition to base config: ==basic > common > dmahoro==
    - academic ::
      + decouple config from 'private'
      + latex for emacs
    - basic ::
      + ==packages/*.yaml== ::
        - used to install tools needed for basic install use
        - others tools to install are to be put in specific "group" of '*.yaml' installation files ('dpkg.yaml', 'pip.yaml', etc.)
        - add some basic tools and default compilers to start with, so can do basic tasks such as running a basic test environment
        - to install ::
          + build-essential, git, tree, curl, wget, screen (GNU screen, multiplexer), g++, python, java jdk (basic one: default-jre), valgrind, ccze (log files colorizer)
      + basic.env ::
        - GNU screen custom configs ::
          + see complete configs in basic configs ==screenrc== file
          + change GNU screen's default control sequence prefix ~C-a~, which is used many other places and other commands, to ~C-@~, and its alias ~M-1~ (see [[file:linux_commands_and_tools.org::#screen_configs][see screen (terminal multiplexer)/basics/screen control sequence prefix]])
          + bind ~[prefix] X~ to close current screen split region: ~bind X remove~ (same as doing into the split screen ~[prefix] ':remove'~)
      + bin (folder) :: 
      + opt (file) :: for opt configs
      + opt.yaml ::
        - basic 'opt' tools that needs to be cloned (org-contrib ?), or installed specifically in 'opt' folder
        - to install :: ==opt/elisp/org-contrib==
      + vim ::
        - ".vimrc": vim configs
        - vim.sh: for eventual plugin install
        - emacs configs to be put in 'common' profile, in basic one just deal with vim terminal
    - common ::
      + apt.yaml ::
        - add to default compilers further debugging, dependencies managers, and optimisation tools (valgrind, ansible, etc.)
        - to install ::
          + docker, ansible
      + opt (file) :: further opt configs
      + opt.yaml ::
        - cloning additional elisp stuff, knowing that some are already in 'basic', eg: ==opt/elisp/org-contrib==
      + dev (folder) ::
        - contains configs for IDEs, formatting, dev utils, etc.
        - additional tools/repos/plugins/etc. are either in 'dev' folder, or any other dotfile/**/*.yaml, such as ==./common/some-ide.yaml==
        - docker ::
        - podman ::
        - vscode (folder) ::
          + vscode (file) :: for configs
          + vscode.yaml (file) ::
            - to install extensions through command line, checkout how to do it [[https://code.visualstudio.com/docs/editor/extension-marketplace#_command-line-extension-management][here]]
          + settings.json ::
          + *.json :: 
      + emacs (file) ? :: what to install in basic emacs split from common ?
        - no 'emacs.yaml' file, emacs packages are installed and set in .el configuration files
          + or maybe an emacs.sh since script will execute installation instructions
        - basic emacs configs
        - undo-tree, global-undo-tree-mode, emacs multiplexer
        - do not forget to adapt emacs to windows, for example when enabling flyspell/ispell, one needs to install the dictionary first (here hunspell aspell is used in place of usual ispell):
          #+begin_example
          ;; add the path of the aspell exec to your emacs exec-path (absolute path required)
          ;; but better use a generic path: ==~/opt/Hunspell== instead of "c:/Program Files (x86)/Hunspell/bin/"
          (add-to-list 'exec-path "c:/Program Files (x86)/Hunspell/bin/")
          
          ;; tell emacs to use aspell in place of ispell
          (setq ispell-program-name "hunspell")
          
          ;; from any file, one can select a different language dictionary with ==M-x ispell-change-dictionary==
          (setq ispell-local-dictionary "en_US")
          
          ;; For saving new words to the personal dictionary, don't infer it from the locale, otherwise it will be saved to the default
          (setq ispell-personal-dictionary "~/.hunspell_personal")
          
          (require 'ispell)
          #+end_example
      + emacs (folder) ? ::
        - clone of ==~/.emacs.d/== ? :: should contain emacs.d content, ones that can't be installed
      + git ::
        - advanced configs, such as direnv
        - preferably use git submodules when dealing with embedded repos, and maybe use subtree and worktrees when appropriate
    - private ::
      + added as a private repo with git submodules
  + profiles ::
    - allows easy selection of given profile: suppose one needs to configure a very light basic environment (==basic==), an more heavier environment that is still missing personal stuff, but with a working docker environment: (==basic+common==), or a full personal profile that contains all "dmahoro" environment (==basic+common+private+academic==), etc.
    - when a profile is configured meaning the structure is there, the env set, bin, etc. then one can stow that profile, for example ~stow common~
    - install.sh ::
      + so that can setup the selected profile, and also have the same basic folders organisation for all profiles  ::
        - all profiles have the same basic folder organisation, and each content will expand from it:
          + opt ::
          + emacs ::
          + repos ::
          + etc. ::
      + other profiles have this basic files structure, plus further customisation
      + "custom" profile ::
        - if select a specific profile, it might install others:
          + common :: basic+common
          + academic :: dmahoro-private
          + private :: dmahoro-acade
          + dmahoro :: all
    - basic ::
      + default environment installed if no particular one specified
      + basic profile to bootstrap a lightweight and ready-to-go environment, eg: for a docker environment to use for tests
    - common ::
      + less lightweight than basic and close to full working environment, but still not too cluttered to be described as a "light" environment
    - dmahoro ::
      + "configs": ==basic + common + academic + private== (all)
      + env :: 
      + opt :: add further full profile for dmahoro "dev" for example, with c++/cmake/java/docker/etc.
      + repos :: add complete list of repos
        - org :: memacs
      + private ::
        - set through profile 'private'
        - folder containing private submodules, some with different remote links (direnv ?), but in any case need to set a ==gitignore== to adapt git configs to target different remotes for example
        - see private for content structure pro
        - work ::
          + company_a ::
          + company_b ::
          + etc. :: 
    - private ::
      + profile for private stuff =>
        - *DON'T commit keys/tokens/passwords and create SECURITY BREACHES*
        - *DON'T push on public profile*
        - dev-repos ::
      + repos-private ::
        - bizz ::
          + for private projects with "for-profit" intent
          + proj-a ::
            - dev :: for repos
            - org :: for org stuff
          + proj-b ::
          + etc.
        - work ::
          + company_a ::
            - dev :: for repos
            - org :: for org stuff
    - "custom" ::
      + alias for "common", but with different $USER value (is it even possible ? $USER is set at installation right ?)
    - can create others whenever needed
- testing ::
  + required ::
    - podman
    - all steps can be found in and run from folder ~configs/common/containers~
  + steps ::
    1. pull debian sandbox: ~podman pull docker.io/library/debian:bookworm-slim~
    2. build a Containerfile to configure the image build process:
       #+begin_example
       FROM debian:bookworm-slim
       ARG CONTAINER_USER=sandboxuser
       # Set the working directory in the container
       WORKDIR /home/$CONTAINER_USER
       RUN addgroup -S $CONTAINER_USER && adduser -S $CONTAINER_USER -G $CONTAINER_USER
       USER $CONTAINER_USER
       CMD ["whoami"]
       #+end_example
    3. run debian container: ~podman run -it debian:bookworm-slim~
       - issues:
         + podman containers are rootless so by default there is no 'sudo' allowed
         + default user is "root", that can only change the state of the container when run as rootful: ~sudo podman run~
         + fixes:
           - still use 'root' as user:
             + => no environment variables set, eg: "$user"


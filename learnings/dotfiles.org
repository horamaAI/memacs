# -*- mode: org -*-
#+TITLE: my dotfiles structure and configs but in orgmode
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+LANGUAGE: en
#+OPTIONS: toc:3 timestamp:t
#+DESCRIPTION: My dotfiles structure, configs and descriptions (got most of them from Bernt Hansen (http://doc.norang.ca/org-mode.html))
#+KEYWORDS: dotfiles org-mode Emacs organization GTD getting-things-done git


* Intro
** Notes
- sources ::
  + main reference :: https://dotfiles.github.io/tutorials/
- what is it used for ::
  + handy way to customize one's system ('dotfiles' is derived from Unix-like systems' configuration files that start with a dot: .bash_profile, .gitconfig, etc.)
  + fetching configurations whenever needed and ready to go; easy to deploy when installing from scratch; useful for syncing preferences across multiple devices
- existing dotfiles configurations are diverse and with various styles. dotfiles are very personal, no "one way to rule them all" setup
- alternative to symlinking the machine's configuration files to $HOME/* for example (though symlinking is part of some dotfiles configuration styles)
- better to split user and hostname-based configurations containing configuration files based on target environment and specific configurations : ==user, server, common, private, public, work, work-a, etc.==
  + for ease of use and retrieval, better to add target's specific configuration files into these configuration directories, eg: ~user/configuration-file~
** some dotfiles
[2024-05-26 Sun 21:39]
- .inputrc :: for keybindings
- .alias ::
- .functions :: for functions that are too complex to be aliases, and too short to be added as scripts
- .env :: for environment variables
** awesome dotfiles (list of useful dotfiles repos and other tools)
[2024-05-29 Wed 21:19]
- https://github.com/webpro/awesome-dotfiles
* Getting started with dotfiles (very basic descriptions)
[2024-05-29 Wed 20:02]
** Notes
- sources ::
  + https://www.webpro.nl/articles/getting-started-with-dotfiles
    - see Lars Kappert's [[https://github.com/webpro/dotfiles][dotfiles configs]], and [[https://github.com/mathiasbynens/dotfiles][Mathias Bynens' one]] (Lars based his configs from his)
- tips and tricks ::
  + structure abd organise dotfiles in directories as per your need: topic/environment/hostname/etc.
  + set root installer to use basic tools such as curl or wget (later usually not available on vanilla linux), and add git as a further installation (see example: ~bash -c "`curl -fsSL https://raw.githubusercontent.com/webpro/dotfiles/master/remote-install.sh`"~)
  + use dependencies manager or other tools for dependencies and additional tools (eg: cmake, makefile, ansible, etc.)
  + git actions, git submodules, and git subtree are powerful tools to enhance dotfiles configurations
  + updating dotfiles script(s) :: plan for a smooth and idempotent (same and deterministic results for each run) script/ update
    - why :: fix symlinks, update packages
* dotfiles configurations styles
[2024-05-24 Fri 23:41]
** dotfiles and topical organisation (dotfiles organised into directories, each entitled to specific subject)
[2024-05-26 Sun 19:35]
- notes ::
  + example of topical organisation: has directories: ==git/==, ==ruby/==, etc., each dedicated to appropriate settings: git, ruby, etc.
  + directories have each their own aliases, path settings, etc., separated
- pros and cons ::
  + pros ::
    - neat structure, easy to navigate
  + cons ::
    - too many directories, most of the time too few content, and with too few rules in those files content
** dotfiles as git repositories ($HOME only, or one hostname-based configuration per git repo)
[2024-05-24 Fri 22:35]
- Notes ::
  + purpose :: having $HOME as git repository: any personal config can be repurposed on any new installation
  + main idea :: set ~$HOME/.gitignore~ to contain only one byte element: ~*~
    - that way, unless a file is added explicitly (with ~git add -f~, or ~--force~, eg: ~git add -f .zshrc_user~), unwanted $HOME element are not added to the repo
    - after ==--force==, gitignore configs won't apply to files already being tracked by git: so, any future changes to files previously added with ==force== will show up in git status, diff, etc., and will be easily committed, staged, etc., with ==-f== no longer necessary
  + setting up a new machine is then easy :: after installation, just:
    #+begin_example
    cd ~
    git init
    git remote add origin [your-dotfiles-git-repo]
    git fetch
    git checkout -f [your-master-branch]
    #+end_example
  + with this dotfiles configuration as repo, it's even possible to shadow system programs by wrapping those sometimes not easy to configure system programs with custom scripts/actions: put ~$HOME/bin~ always ahead of any other tools in ~$PATH~:
    - example: wrap xdg-open with custom pre-commands in script ==~/bin/xdg-open== (replace annoying-to-customize xdg-open with own version, and only fall back to /usr/bin/xdg-open if necessary):
      #+begin_example
      #!/bin/sh
      case "${1%%:*}" in
      	http|https|*.pdf)
      		exec qutebrowser "$1"
      		;;
      	mailto)
      		exec aerc "$1"
      		;;
      	*)
      		exec /usr/bin/xdg-open "$@"
      		;;
      esac
      #+end_example
  + configuring custom dotfiles for other environments/distributions/hosts/purpose ::
    - the same as ~$HOME/bin~ is prefixed before any other element in ~$PATH~ for custom configs, one can further customise the dotfiles to consider different hostnames: just need to preface ~$HOME/bin/$(hostname)~ before ~$HOME/bin~ in $PATH
      + to also consider the different architectures in the configurations: can add ~$HOME/bin/$(uname -m)~ configurations to the dotfiles repo
        - eg: to customize sway configurations to consider the different device configurations of each host, use following directive in ==~/.config/sway/config==: ~include ~/.config/sway/`hostname`~
      + same, if want configurations specific to server for example, use its ~$HOME/bin/server~ path before
- pros and cons ::
  + pros ::
    - main tools and configurations ready to use :: ==~/bin, ~/lib, ~/config==, etc.
  + cons ::
    - one hostname-based configuration per repo. Further configurations need to add those in the repo, with all different usecases, architectures, etc.
** dotfiles as --bare git repositories
[2024-05-29 Wed 22:25]
- notes ::
  + sources ::
    - https://www.atlassian.com/git/tutorials/dotfiles
  + 'bare' repositories :: can be seen as "side" repositories that don't update its content with usual git commands such as git pull/push (see [[https://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/]["working" vs "bare" repositories]]), and need specific way to do so
    - by convention, bare repos need to have extension ==.git== (eg: ~mybarerepo.git~)
    - bare repos can be seen as 'shared' repos, where one can only push/pull from, but never directly commit to
    - recommended for shared and central repositories, kind of 'managers' repos
    - most common use case for  ~git init --bare~ is creating a remote central repository: ~ssh <user>@<host> cd path/above/repo git init --bare my-project.git~
      + ssh connect to server containing bare repository, create bare repo, and then users will clone bare repo to create local repo
  + => prerequisite :: have git pre-installed
  + pros ::
    - no extra tools, or symlinks, the files are tracked with a version control system
    - switch to extra branch and fetch to include different environment
  + cons ::
    - complex actions to segregate specific data to push
  + main idea ::
    - create a bare repository to interact with when updating mother configuration (eg: ~$HOME/.cfg~, or ~$HOME/.topcfg~)
    - add alias for interactions with the bare repository instead of using the usual git (otherwise it would interfere with working repository)
*** process
- example ::
  #+begin_example
  $git init --bare $HOME/.cfg
  # creates alias to use a specific git command with git directory the bare repo, and with work-tree set at $HOME
  $alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
  # flag --local to hide files not explicitly tracked yet
  # twice 'config' might be a typo, check first without
  $config config --local status.showUntrackedFiles no
  # add config alias to bash/zsh startup file
  $echo "alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'" >> $HOME/.bashrc
  #+end_example
- after setup steps :: any file within ~$HOME~ can be versioned using ~config~:
  #+begin_example
  config status
  config add .vimrc
  config commit -m "Add vimrc"
  config add .bashrc
  config commit -m "Add bashrc"
  config push
  #+end_example
- installing dotfiles on new system ::
  + first ::
    - make sure ~config~ alias is set on bash or zsh :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
    - and that source repo will ignore folder where will be cloned :: (otherwise might create weird recursion issues): ~echo ".cfg" >> .gitignore~
  + then clone dotfiles into bare repo :: ~git clone --bare <git-repo-url> $HOME/.cfg~
  + define alias in current shell scope :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
  + checkout actual content from the bare repository to $HOME :: ~config checkout~
    - if steps fails with following error:
      #+begin_example
      error: The following untracked working tree files would be overwritten by checkout:
          .bashrc
          .gitignore
      Please move or remove them before you can switch branches.
      Aborting
      #+end_example
    - it's due to existing config files
    - if need to backup:
      #+begin_example
      mkdir -p .config-backup && \
      config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | \
      xargs -I{} mv {} .config-backup/{}
      #+end_example
    - and rerun ~config checkout~
    - set flag showUntrackedFiles to no on the local repository: ~config config --local status.showUntrackedFiles no~
    - and done!
    - from there, can use ==config== to add/update dotfiles:
      #+begin_example
      config status
      config add .vimrc
      config commit -m "Add vimrc"
      config add .bashrc
      config commit -m "Add bashrc"
      config push
      #+end_example
  + example script for previous points ::
    #+begin_example
    git clone --bare https://bitbucket.org/durdn/cfg.git $HOME/.cfg
    function config {
       /usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME $@
    }
    mkdir -p .config-backup
    config checkout
    if [ $? = 0 ]; then
      echo "Checked out config.";
      else
        echo "Backing up pre-existing dot files.";
        config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | xargs -I{} mv {} .config-backup/{}
    fi;
    config checkout
    config config status.showUntrackedFiles no
    #+end_example
** dotfiles as host-based environment profiles with various tools
[2024-05-25 Sat 00:24]
** dotfiles for configs + ansible for dependencies
[2024-05-25 Sat 01:13]

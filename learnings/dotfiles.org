# -*- mode: org -*-
#+TITLE: my dotfiles structure and configs but in orgmode
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+LANGUAGE: en
#+OPTIONS: toc:3 timestamp:t
#+DESCRIPTION: My dotfiles structure, configs and descriptions (got most of them from Bernt Hansen (http://doc.norang.ca/org-mode.html))
#+KEYWORDS: dotfiles org-mode Emacs organization GTD getting-things-done git


* Intro
** Notes
- sources ::
  + main reference :: https://dotfiles.github.io/tutorials/
- what is it used for ::
  + handy way to customize one's system ('dotfiles' is derived from Unix-like systems' configuration files that start with a dot: .bash_profile, .gitconfig, etc.)
  + fetching configurations whenever needed and ready to go; easy to deploy when installing from scratch; useful for syncing preferences across multiple devices
- existing dotfiles configurations are diverse and with various styles. dotfiles are very personal, no "one way to rule them all" setup
- alternative to symlinking the machine's configuration files to $HOME/* for example (though symlinking is part of some dotfiles configuration styles)
- better to split user and hostname-based configurations containing configuration files based on target environment and specific configurations : ==user, server, common, private, public, work, work-a, etc.==
  + for ease of use and retrieval, better to add target's specific configuration files into these configuration directories, eg: ~user/configuration-file~
** awesome dotfiles (list of existing dotfiles repos and other dotfiles related tools)
[2024-05-29 Wed 21:19]
- https://github.com/webpro/awesome-dotfiles
** some dotfiles stuff
[2024-05-26 Sun 21:39]
- files name :: 
  + .alias ::
  + .env :: for environment variables
  + .functions :: for functions that are too complex to be aliases, and too short to be added as scripts
  + .inputrc :: for keybindings and other keys behaviour, eg: ~set completion-ignore-case on~
* Getting started with dotfiles (very basic descriptions)
[2024-05-29 Wed 20:02]
** Notes
- sources ::
  + https://www.webpro.nl/articles/getting-started-with-dotfiles
    - see Lars Kappert's [[https://github.com/webpro/dotfiles][dotfiles configs]], and [[https://github.com/mathiasbynens/dotfiles][Mathias Bynens' one]] (Lars based his configs from his)
  + https://kalis.me/dotfiles-automating-macos-system-configuration/
- tips and tricks ::
  + structure abd organise dotfiles in directories as per your need: topic/environment/hostname/etc.
  + use version control systems "branches" to adapt configs to different systems (linux distros, macOS, etc.)
  + set root installer to use basic tools such as curl or wget (later usually not available on vanilla linux), and add git as a further installation (see example: ~bash -c "`curl -fsSL https://raw.githubusercontent.com/webpro/dotfiles/master/remote-install.sh`"~)
  + use dependencies manager or other tools for dependencies and additional tools (eg: cmake, makefile, ansible, etc.)
  + git actions, git submodules, and git subtree are powerful tools to enhance dotfiles configurations
  + updating dotfiles script(s) :: plan for a smooth and idempotent (same and deterministic results for each run) script/ update
    - why :: fix symlinks, update packages
  + create '*.list' files for tool specific installations, eg: ~apt.list~ for packages to install with apt, ~npm.list~ for those to install with npm, etc.
    - source :: https://kalis.me/dotfiles-automating-macos-system-configuration/
    - same, can also create '*.list' files for repositories and make a script to automatise the git cloning
    - can be tidier to group repository folders, per project or topic for example, eg: ==~/dev/personal==, ==~/dev/work==,  ==~/dev/research==, etc.
    - eg:
      #+begin_example
      #! /usr/bin/env sh
      
      DIR=$(dirname "$0")
      cd "$DIR"
      
      COMMENT=\#*
      REPO_PATH=$(realpath ~/repos)
      
      find * -name "*.list" | while read fn; do
          folder="${fn%.*}"
          mkdir -p "$REPO_PATH/$folder"
          while read repo; do
              if [[ $repo == $COMMENT ]];
                  then continue;
              else
                  pushd "$REPO_PATH/$folder"
                  git clone $repo
                  popd
              fi
          done < "$fn"
      done
      #+end_example
* dotfiles configurations styles
[2024-05-24 Fri 23:41]
** dotfiles and topical organisation (dotfiles organised into directories, each entitled to specific subject)
[2024-05-26 Sun 19:35]
- notes ::
  + example of topical organisation: has directories: ==git/==, ==ruby/==, etc., each dedicated to appropriate settings: git, ruby, etc.
  + directories have each their own aliases, path settings, etc., separated
- pros and cons ::
  + pros ::
    - neat structure, easy to navigate
  + cons ::
    - too many directories, most of the time too few content, and with too few rules in those files content
** dotfiles as git repositories ($HOME only, or one hostname-based configuration per git repo)
[2024-05-24 Fri 22:35]
- Notes ::
  + purpose :: having $HOME as git repository: any personal config can be repurposed on any new installation
  + main idea :: set ~$HOME/.gitignore~ to contain only one byte element: ~*~
    - that way, unless a file is added explicitly (with ~git add -f~, or ~--force~, eg: ~git add -f .zshrc_user~), unwanted $HOME element are not added to the repo
    - after ==--force==, gitignore configs won't apply to files already being tracked by git: so, any future changes to files previously added with ==force== will show up in git status, diff, etc., and will be easily committed, staged, etc., with ==-f== no longer necessary
  + setting up a new machine is then easy :: after installation, just:
    #+begin_example
    cd ~
    git init
    git remote add origin [your-dotfiles-git-repo]
    git fetch
    git checkout -f [your-master-branch]
    #+end_example
  + with this dotfiles configuration as repo, it's even possible to shadow system programs by wrapping those sometimes not easy to configure system programs with custom scripts/actions: put ~$HOME/bin~ always ahead of any other tools in ~$PATH~:
    - example: wrap xdg-open with custom pre-commands in script ==~/bin/xdg-open== (replace annoying-to-customize xdg-open with own version, and only fall back to /usr/bin/xdg-open if necessary):
      #+begin_example
      #!/bin/sh
      case "${1%%:*}" in
      	http|https|*.pdf)
      		exec qutebrowser "$1"
      		;;
      	mailto)
      		exec aerc "$1"
      		;;
      	*)
      		exec /usr/bin/xdg-open "$@"
      		;;
      esac
      #+end_example
  + configuring custom dotfiles for other environments/distributions/hosts/purpose ::
    - the same as ~$HOME/bin~ is prefixed before any other element in ~$PATH~ for custom configs, one can further customise the dotfiles to consider different hostnames: just need to preface ~$HOME/bin/$(hostname)~ before ~$HOME/bin~ in $PATH
      + to also consider the different architectures in the configurations: can add ~$HOME/bin/$(uname -m)~ configurations to the dotfiles repo
        - eg: to customize sway configurations to consider the different device configurations of each host, use following directive in ==~/.config/sway/config==: ~include ~/.config/sway/`hostname`~
      + same, if want configurations specific to server for example, use its ~$HOME/bin/server~ path before
- pros and cons ::
  + pros ::
    - main tools and configurations ready to use :: ==~/bin, ~/lib, ~/config==, etc.
  + cons ::
    - one hostname-based configuration per repo. Further configurations need to add those in the repo, with all different usecases, architectures, etc.
** dotfiles as --bare git repositories
[2024-05-29 Wed 22:25]
- notes ::
  + sources ::
    - https://www.atlassian.com/git/tutorials/dotfiles
  + 'bare' repositories :: can be seen as "side" repositories that don't update its content with usual git commands such as git pull/push (see [[https://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/]["working" vs "bare" repositories]]), and need specific way to do so
    - by convention, bare repos need to have extension ==.git== (eg: ~mybarerepo.git~)
    - bare repos can be seen as 'shared' repos, where one can only push/pull from, but never directly commit to
    - recommended for shared and central repositories, kind of 'managers' repos
    - most common use case for  ~git init --bare~ is creating a remote central repository: ~ssh <user>@<host> cd path/above/repo git init --bare my-project.git~
      + ssh connect to server containing bare repository, create bare repo, and then users will clone bare repo to create local repo
  + => prerequisite :: have git pre-installed
  + pros ::
    - no extra tools, or symlinks, the files are tracked with a version control system
    - switch to extra branch and fetch to include different environment
  + cons ::
    - complex actions to segregate specific data to push
  + main idea ::
    - create a bare repository to interact with when updating mother configuration (eg: ~$HOME/.cfg~, or ~$HOME/.topcfg~)
    - add alias for interactions with the bare repository instead of using the usual git (otherwise it would interfere with working repository)
*** process
- example ::
  #+begin_example
  $git init --bare $HOME/.cfg
  # creates alias to use a specific git command with git directory the bare repo, and with work-tree set at $HOME
  $alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
  # flag --local to hide files not explicitly tracked yet
  # twice 'config' might be a typo, check first without
  $config config --local status.showUntrackedFiles no
  # add config alias to bash/zsh startup file
  $echo "alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'" >> $HOME/.bashrc
  #+end_example
- after setup steps :: any file within ~$HOME~ can be versioned using ~config~:
  #+begin_example
  config status
  config add .vimrc
  config commit -m "Add vimrc"
  config add .bashrc
  config commit -m "Add bashrc"
  config push
  #+end_example
- installing dotfiles on new system ::
  + first ::
    - make sure ~config~ alias is set on bash or zsh :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
    - and that source repo will ignore folder where will be cloned :: (otherwise might create weird recursion issues): ~echo ".cfg" >> .gitignore~
  + then clone dotfiles into bare repo :: ~git clone --bare <git-repo-url> $HOME/.cfg~
  + define alias in current shell scope :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
  + checkout actual content from the bare repository to $HOME :: ~config checkout~
    - if steps fails with following error:
      #+begin_example
      error: The following untracked working tree files would be overwritten by checkout:
          .bashrc
          .gitignore
      Please move or remove them before you can switch branches.
      Aborting
      #+end_example
    - it's due to existing config files
    - if need to backup:
      #+begin_example
      mkdir -p .config-backup && \
      config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | \
      xargs -I{} mv {} .config-backup/{}
      #+end_example
    - and rerun ~config checkout~
    - set flag showUntrackedFiles to no on the local repository: ~config config --local status.showUntrackedFiles no~
    - and done!
    - from there, can use ==config== to add/update dotfiles:
      #+begin_example
      config status
      config add .vimrc
      config commit -m "Add vimrc"
      config add .bashrc
      config commit -m "Add bashrc"
      config push
      #+end_example
  + example script for previous points ::
    #+begin_example
    git clone --bare https://bitbucket.org/durdn/cfg.git $HOME/.cfg
    function config {
       /usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME $@
    }
    mkdir -p .config-backup
    config checkout
    if [ $? = 0 ]; then
      echo "Checked out config.";
      else
        echo "Backing up pre-existing dot files.";
        config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | xargs -I{} mv {} .config-backup/{}
    fi;
    config checkout
    config config status.showUntrackedFiles no
    #+end_example
** dotfiles as host-based environment profiles with various tools
[2024-05-25 Sat 00:24]
** dotfiles for configs + ansible for dependencies
[2024-05-25 Sat 01:13]
* My dotfiles
[2024-06-01 Sat 15:25]
- draft ::
  + to include ::
    - ==user, server, common, private, business, work, work-a, etc.==
    - don't forget adding ppas for additional apt installs (https://github.com/cowboy/dotfiles/blob/master/init/20_ubuntu_apt.sh#L16)
    - stow ? checkout [[https://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html][this]], [[https://spin.atomicobject.com/manage-dotfiles-gnu-stow/][this]] and [[https://blog.palcu.net/2014/06/dotfiles-and-dev-tools-provisioned-by.html][this one maybe]] which relies more on ansible ("bash on steroid")
      + ansible is a more robust alternative to writing your own bash script, it manages checking for example if an action was successful, or if an error occurs, resume where left off
    - '*.list' files for tool specific installations (filed by command to use), eg: ~apt.list~ for packages to install with apt, ~npm.list~ for npm, ~python2.list~, etc.
      + for packages to install, line starts with:
        - ==$== : then the line is the command to use for following packages
        - ==#== comment, skip
        - all remaining lines are packages to install using current command
      + setup for installation first some essentials packages that are mandatory (build-essential, emacs, python, npm, etc.) to have before installing other tools
        - for example in [[https://github.com/rkalis/dotfiles/][this repo]], the main setup is running the [[https://github.com/rkalis/dotfiles/blob/master/bootstrap.sh#L30][main packages install]] (~./packages/setup.sh~ which is [[https://github.com/rkalis/dotfiles/blob/master/packages/setup.sh][here]]), and then locate and run the remaining setup (~find * -name "setup.sh" -not -wholename "packages*"~ and skips ~./packages/setup.sh~ which was run before)
    - '*.list' files for repositories
    - git bare repo ?
      + user's home is overflowing with dotfiles ('hidden'), mind it could be tedious if choose git bare and have to go through all the files to add to own dotfiles (https://web.archive.org/web/20171003124306/https://plus.google.com/+RobPikeTheHuman/posts/R58WgWwN9jp)
    - checkout use of environment variables $XDG_* (https://0x46.net/thoughts/2019/02/01/dotfile-madness/ and https://wiki.gentoo.org/wiki/XDG/Base_Directories)
      + $XDG_DATA_HOME or $HOME/.local/share for example to store plugins downloaded by the user, databases created by your program, user's input history, bookmarks, emails, and so on
    - .inputrc, .alias, etc
    - optimise autocomplete
    - direnv ? (https://direnv.net/)
    - git configs with multiple configs (direnv maybe ?)
      + checkout [[https://github.com/jogendra/dotfiles/blob/master/git/pull_request.sh][these cool git functions]] and [[https://github.com/jogendra/dotfiles/blob/master/git/gitconfig][configs]]
    - [[https://zellij.dev/documentation/][zellij]] (terminal multiplexer written in rust and made to be a better tool than tmux, which is written in C, and sometimes lacking)
      + checkout how to create workspaces: https://spin.atomicobject.com/dev-project-workspace-tmux/
      + checkout how to add more functionalities to it:
        - https://jolicode.com/blog/organiser-son-terminal-avec-des-workspaces
        - https://github.com/niflostancu/tmux-workspaces
    - oh-my-zsh configs and customisation
    - vim (learn basics, and tweak configs, seems there is no way to escape from it when working with bare installation or with the terminal)
    - IDE ::
      + add configs for one 'mainstream' IDE too (settings, format, plugins, etc.)
    - emacs ::
      + add in-terminal settings
    - preferably add 'uninstall' or remove command
  + "update" ::
    - script for updating target 
- dotfiles structure :: source of things to do
  + install.sh ::
    - main entry point for dotfiles installation
  + configs :: 
    - academic ::
      + 'smthing.list', and 'smthing' file for specific installs and configs
      + decouple config from 'private'
      + latex for emacs
    - basic ::
      + apt.list (file) ::
        - main tools needed for basic install use
        - others tools to install are to be put in specific "group" of '*.list' installation files ('dpkg.list', 'pip.list', etc.)
        - add some basic tools and default compilers to start with, so can do basic tasks such as running a basic test environment
        - to install ::
          + build-essential, git, tree, curl, wget, screen (GNU screen, multiplexer), g++, python, java jdk (basic one: default-jre), valgrind
      + bin (folder) :: 
      + opt (file) :: for opt configs
      + opt.list ::
        - basic 'opt' tools that needs to be cloned (org-contrib ?), or installed specifically in 'opt' folder
        - to install :: ==opt/elisp/org-contrib==
      + vim ::
        - vim configs
        - emacs configs to be put in 'common' profile, in basic one just deal with vim terminal
    - common ::
      + apt.list ::
        - add to default compilers further debugging, dependencies managers, and optimisation tools (valgrind, ansible, etc.)
        - to install ::
          + docker, ansible
      + opt (file) :: further opt configs
      + opt.list ::
        - cloning additional elisp stuff, knowing that some are already in 'basic', eg: ==opt/elisp/org-contrib==
      + dev (folder) ::
        - contains configs for IDEs, formatting, dev utils, etc.
        - additional tools/repos/plugins/etc. are either in 'dev' folder, or any other dotfile/**/*.list, such as ==./common/some-ide.list==
        - docker ::
        - podman ::
        - vscode (folder) ::
          + vscode (file) :: for configs
          + vscode.list (file) ::
            - to install extensions through command line, checkout how to do it [[https://code.visualstudio.com/docs/editor/extension-marketplace#_command-line-extension-management][here]]
          + settings.json ::
          + *.json :: 
      + emacs (file) ? :: what to install in basic emacs split from common ?
        - no 'emacs.list' file, emacs packages are installed and set in .el configuration files
        - basic emacs configs
        - undo-tree, global-undo-tree-mode, emacs multiplexer
      + emacs (folder) ? ::
        - clone of ==~/.emacs.d/== ? :: should contain emacs.d content, ones that can't be installed
      + git ::
        - advanced configs, such as direnv
        - preferably use git submodules when dealing with embedded repos, and maybe use subtree and worktrees when appropriate
    - private ::
      + added as a private repo with git submodules
  + profiles ::
    - allows easy selection of given profile: suppose one needs to configure a very light basic environment (==basic==), an more heavier environment that is still missing personal stuff, but with a working docker environment: (==basic+common==), or a full personal profile that contains all "dmahoro" environment (==basic+common+private+academic==), etc.
    - when a profile is configured meaning the structure is there, the env set, bin, etc. then one can stow that profile, for example ~stow common~
    - install.sh ::
      + so that can setup the selected profile, and also have the same basic folders organisation for all profiles  ::
        - all profiles have the same basic folder organisation, and each content will expand from it:
          + opt ::
          + emacs ::
          + repos ::
          + etc. ::
      + other profiles have this basic files structure, plus further customisation
      + "custom" profile ::
        - if select a specific profile, it might install others:
          + common :: basic+common
          + academic :: dmahoro-private
          + private :: dmahoro-acade
          + dmahoro :: all
    - basic ::
      + default environment installed if no particular one specified
      + basic profile to bootstrap a lightweight and ready-to-go environment, eg: for a docker environment to use for tests
    - common ::
      + less lightweight than basic and close to full working environment, but still not too cluttered to be described as a "light" environment
    - dmahoro ::
      + "configs": ==basic + common + academic + private== (all)
      + env :: 
      + opt :: add further full profile for dmahoro "dev" for example, with c++/cmake/java/docker/etc.
      + repos :: add complete list of repos
        - org :: memacs
      + private ::
        - set through profile 'private'
        - folder containing private submodules, some with different remote links (direnv ?), but in any case need to set a ==gitignore== to adapt git configs to target different remotes for example
        - see private for content structure pro
        - work ::
          + company_a ::
          + company_b ::
          + etc. :: 
    - private ::
      + profile for private stuff =>
        - *DON'T commit keys/tokens/passwords and create SECURITY BREACHES*
        - *DON'T push on public profile*
        - dev-repos ::
      + repos-private ::
        - bizz ::
          + for private projects with "for-profit" intent
          + proj-a ::
            - dev :: for repos
            - org :: for org stuff
          + proj-b ::
          + etc.
        - work ::
          + company_a ::
            - dev :: for repos
            - org :: for org stuff
    - "custom" ::
      + alias for "common", but with different $USER value (is it even possible ? $USER is set at installation right ?)
    - can create others whenever needed
- questions ::
  + target structure ::
    - should be different than the dotfiles structure ? => how will updates work when wants to change something and push it to dotfiles repo ?


# -*- mode: org -*-
#+TITLE: my dotfiles structure and configs but in orgmode
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+LANGUAGE: en
#+OPTIONS: toc:3 timestamp:t
#+DESCRIPTION: My dotfiles structure, configs and descriptions (got most of them from Bernt Hansen (http://doc.norang.ca/org-mode.html))
#+KEYWORDS: dotfiles org-mode Emacs organization GTD getting-things-done git


* Intro
** Notes
- sources ::
  + main reference :: https://dotfiles.github.io/tutorials/
- what is it used for ::
  + handy way to customize one's system ('dotfiles' is derived from Unix-like systems' configuration files that start with a dot: .bash_profile, .gitconfig, etc.)
  + fetching configurations whenever needed and ready to go; easy to deploy when installing from scratch; useful for syncing preferences across multiple devices
- existing dotfiles configurations are diverse and with various styles. dotfiles are very personal, no "one way to rule them all" setup
- alternative to symlinking the machine's configuration files to $HOME/* for example (though symlinking is part of some dotfiles configuration styles)
- better to split user and hostname-based configurations containing configuration files based on target environment and specific configurations : ==user, server, common, private, public, work, work-a, etc.==
  + for ease of use and retrieval, better to add target's specific configuration files into these configuration directories, eg: ~user/configuration-file~
** awesome dotfiles (list of existing dotfiles repos and other dotfiles related tools)
[2024-05-29 Wed 21:19]
- https://github.com/webpro/awesome-dotfiles
** some dotfiles stuff
[2024-05-26 Sun 21:39]
- files name :: 
  + .alias ::
  + .env :: for environment variables
  + .functions :: for functions that are too complex to be aliases, and too short to be added as scripts
  + .inputrc :: for keybindings and other keys behaviour, eg: ~set completion-ignore-case on~
* Getting started with dotfiles (very basic descriptions)
[2024-05-29 Wed 20:02]
** Notes
- sources ::
  + https://www.webpro.nl/articles/getting-started-with-dotfiles
    - see Lars Kappert's [[https://github.com/webpro/dotfiles][dotfiles configs]], and [[https://github.com/mathiasbynens/dotfiles][Mathias Bynens' one]] (Lars based his configs from his)
  + https://kalis.me/dotfiles-automating-macos-system-configuration/
- tips and tricks ::
  + structure abd organise dotfiles in directories as per your need: topic/environment/hostname/etc.
  + use version control systems "branches" to adapt configs to different systems (linux distros, macOS, etc.)
  + set root installer to use basic tools such as curl or wget (later usually not available on vanilla linux), and add git as a further installation (see example: ~bash -c "`curl -fsSL https://raw.githubusercontent.com/webpro/dotfiles/master/remote-install.sh`"~)
  + use dependencies manager or other tools for dependencies and additional tools (eg: cmake, makefile, ansible, etc.)
  + git actions, git submodules, and git subtree are powerful tools to enhance dotfiles configurations
  + updating dotfiles script(s) :: plan for a smooth and idempotent (same and deterministic results for each run) script/ update
    - why :: fix symlinks, update packages
  + create '*.yaml' files for tool specific installations, eg: ~apt.yaml~ for packages to install with apt, ~npm.yaml~ for those to install with npm, etc.
    - source :: https://kalis.me/dotfiles-automating-macos-system-configuration/
    - same, can also create '*.yaml' files for repositories and make a script to automatise the git cloning
    - can be tidier to group repository folders, per project or topic for example, eg: ==~/dev/personal==, ==~/dev/work==,  ==~/dev/research==, etc.
    - eg: (.list files are instead to be used as .yaml files)
      #+begin_example
      #! /usr/bin/env sh
      
      DIR=$(dirname "$0")
      cd "$DIR"
      
      COMMENT=\#*
      REPO_PATH=$(realpath ~/repos)
      
      find * -name "*.list" | while read fn; do
          folder="${fn%.*}"
          mkdir -p "$REPO_PATH/$folder"
          while read repo; do
              if [[ $repo == $COMMENT ]];
                  then continue;
              else
                  pushd "$REPO_PATH/$folder"
                  git clone $repo
                  popd
              fi
          done < "$fn"
      done
      #+end_example
* dotfiles configurations styles
[2024-05-24 Fri 23:41]
** dotfiles and topical organisation (dotfiles organised into directories, each entitled to specific subject)
[2024-05-26 Sun 19:35]
- notes ::
  + example of topical organisation: has directories: ==git/==, ==ruby/==, etc., each dedicated to appropriate settings: git, ruby, etc.
  + directories have each their own aliases, path settings, etc., separated
- pros and cons ::
  + pros ::
    - neat structure, easy to navigate
  + cons ::
    - too many directories, most of the time too few content, and with too few rules in those files content
** dotfiles as git repositories ($HOME only, or one hostname-based configuration per git repo)
[2024-05-24 Fri 22:35]
- Notes ::
  + purpose :: having $HOME as git repository: any personal config can be repurposed on any new installation
  + main idea :: set ~$HOME/.gitignore~ to contain only one byte element: ~*~
    - that way, unless a file is added explicitly (with ~git add -f~, or ~--force~, eg: ~git add -f .zshrc_user~), unwanted $HOME element are not added to the repo
    - after ==--force==, gitignore configs won't apply to files already being tracked by git: so, any future changes to files previously added with ==force== will show up in git status, diff, etc., and will be easily committed, staged, etc., with ==-f== no longer necessary
  + setting up a new machine is then easy :: after installation, just:
    #+begin_example
    cd ~
    git init
    git remote add origin [your-dotfiles-git-repo]
    git fetch
    git checkout -f [your-master-branch]
    #+end_example
  + with this dotfiles configuration as repo, it's even possible to shadow system programs by wrapping those sometimes not easy to configure system programs with custom scripts/actions: put ~$HOME/bin~ always ahead of any other tools in ~$PATH~:
    - example: wrap xdg-open with custom pre-commands in script ==~/bin/xdg-open== (replace annoying-to-customize xdg-open with own version, and only fall back to /usr/bin/xdg-open if necessary):
      #+begin_example
      #!/bin/sh
      case "${1%%:*}" in
      	http|https|*.pdf)
      		exec qutebrowser "$1"
      		;;
      	mailto)
      		exec aerc "$1"
      		;;
      	*)
      		exec /usr/bin/xdg-open "$@"
      		;;
      esac
      #+end_example
  + configuring custom dotfiles for other environments/distributions/hosts/purpose ::
    - the same as ~$HOME/bin~ is prefixed before any other element in ~$PATH~ for custom configs, one can further customise the dotfiles to consider different hostnames: just need to preface ~$HOME/bin/$(hostname)~ before ~$HOME/bin~ in $PATH
      + to also consider the different architectures in the configurations: can add ~$HOME/bin/$(uname -m)~ configurations to the dotfiles repo
        - eg: to customize sway configurations to consider the different device configurations of each host, use following directive in ==~/.config/sway/config==: ~include ~/.config/sway/`hostname`~
      + same, if want configurations specific to server for example, use its ~$HOME/bin/server~ path before
- pros and cons ::
  + pros ::
    - main tools and configurations ready to use :: ==~/bin, ~/lib, ~/config==, etc.
  + cons ::
    - one hostname-based configuration per repo. Further configurations need to add those in the repo, with all different usecases, architectures, etc.
** dotfiles as --bare git repositories
[2024-05-29 Wed 22:25]
- notes ::
  + sources ::
    - https://www.atlassian.com/git/tutorials/dotfiles
  + 'bare' repositories :: can be seen as "side" repositories that don't update its content with usual git commands such as git pull/push (see [[https://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/]["working" vs "bare" repositories]]), and need specific way to do so
    - by convention, bare repos need to have extension ==.git== (eg: ~mybarerepo.git~)
    - bare repos can be seen as 'shared' repos, where one can only push/pull from, but never directly commit to
    - recommended for shared and central repositories, kind of 'managers' repos
    - most common use case for  ~git init --bare~ is creating a remote central repository: ~ssh <user>@<host> cd path/above/repo git init --bare my-project.git~
      + ssh connect to server containing bare repository, create bare repo, and then users will clone bare repo to create local repo
  + => prerequisite :: have git pre-installed
  + pros ::
    - no extra tools, or symlinks, the files are tracked with a version control system
    - switch to extra branch and fetch to include different environment
  + cons ::
    - complex actions to segregate specific data to push
  + main idea ::
    - create a bare repository to interact with when updating mother configuration (eg: ~$HOME/.cfg~, or ~$HOME/.topcfg~)
    - add alias for interactions with the bare repository instead of using the usual git (otherwise it would interfere with working repository)
*** process
- example ::
  #+begin_example
  $git init --bare $HOME/.cfg
  # creates alias to use a specific git command with git directory the bare repo, and with work-tree set at $HOME
  $alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
  # flag --local to hide files not explicitly tracked yet
  # twice 'config' might be a typo, check first without
  $config config --local status.showUntrackedFiles no
  # add config alias to bash/zsh startup file
  $echo "alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'" >> $HOME/.bashrc
  #+end_example
- after setup steps :: any file within ~$HOME~ can be versioned using ~config~:
  #+begin_example
  config status
  config add .vimrc
  config commit -m "Add vimrc"
  config add .bashrc
  config commit -m "Add bashrc"
  config push
  #+end_example
- installing dotfiles on new system ::
  + first ::
    - make sure ~config~ alias is set on bash or zsh :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
    - and that source repo will ignore folder where will be cloned :: (otherwise might create weird recursion issues): ~echo ".cfg" >> .gitignore~
  + then clone dotfiles into bare repo :: ~git clone --bare <git-repo-url> $HOME/.cfg~
  + define alias in current shell scope :: ~alias config='/usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME'~
  + checkout actual content from the bare repository to $HOME :: ~config checkout~
    - if steps fails with following error:
      #+begin_example
      error: The following untracked working tree files would be overwritten by checkout:
          .bashrc
          .gitignore
      Please move or remove them before you can switch branches.
      Aborting
      #+end_example
    - it's due to existing config files
    - if need to backup:
      #+begin_example
      mkdir -p .config-backup && \
      config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | \
      xargs -I{} mv {} .config-backup/{}
      #+end_example
    - and rerun ~config checkout~
    - set flag showUntrackedFiles to no on the local repository: ~config config --local status.showUntrackedFiles no~
    - and done!
    - from there, can use ==config== to add/update dotfiles:
      #+begin_example
      config status
      config add .vimrc
      config commit -m "Add vimrc"
      config add .bashrc
      config commit -m "Add bashrc"
      config push
      #+end_example
  + example script for previous points ::
    #+begin_example
    git clone --bare https://bitbucket.org/durdn/cfg.git $HOME/.cfg
    function config {
       /usr/bin/git --git-dir=$HOME/.cfg/ --work-tree=$HOME $@
    }
    mkdir -p .config-backup
    config checkout
    if [ $? = 0 ]; then
      echo "Checked out config.";
      else
        echo "Backing up pre-existing dot files.";
        config checkout 2>&1 | egrep "\s+\." | awk {'print $1'} | xargs -I{} mv {} .config-backup/{}
    fi;
    config checkout
    config config status.showUntrackedFiles no
    #+end_example
** dotfiles as host-based environment profiles with various tools
[2024-05-25 Sat 00:24]
** dotfiles for configs + ansible for dependencies
[2024-05-25 Sat 01:13]
* My dotfiles
[2024-06-01 Sat 15:25]
** Draft configuration, organisation, drafts, etc.
*** Todos, propositions, drafts, etc.
- to include (suggestions) ::
  + [ ] add ppas for additional apt installs (https://github.com/cowboy/dotfiles/blob/master/init/20_ubuntu_apt.sh#L16)
  + [ ] packages and tools installation
    - setup for installation mandatory essentials packages (build-essential, emacs, python, npm, etc.) before installing other tools
    - example in [[https://github.com/rkalis/dotfiles/][this repo]], the main setup is running the [[https://github.com/rkalis/dotfiles/blob/master/bootstrap.sh#L30][main packages install]] (~./packages/setup.sh~ which is [[https://github.com/rkalis/dotfiles/blob/master/packages/setup.sh][here]]), and then locate and run the remaining setup (~find * -name "setup.sh" -not -wholename "packages*"~ and skips ~./packages/setup.sh~ which was run before)
    - [ ] '*.list' ([selected] '*.yaml') files for installation specific commands (filed by +command to use+ :used by function: ~[folder]/packages~, ~[folder]/opt~, etc.), eg: ~apt.yaml~ for packages to install with apt, ~npm.yaml~ for npm, ~python3.yaml~, etc.
      + [aborted] for packages to install, line starts with:
        - ==$== : then the line is the command to use for following packages
        - ==#== comment, skip
        - all remaining lines are packages to install using current command
      + [selected] use yaml file and install command content into a schema that validates
    - [ ] opt
    - [ ] git repositories
  + [ ] tools configs: .zshrc, .zshrc_user, oh-my-zsh, .screen, .inputrc, .alias, etc
  + [ ] emacs ::
    - add in-terminal settings
    - split profile for ==common== and ==dmahoro==
  + [ ] git:
    - [ ] git ci/cd, eg: git hooks
    - [ ] git configs with multiple configs (direnv maybe ?: https://direnv.net/)
      + checkout [[https://github.com/jogendra/dotfiles/blob/master/git/pull_request.sh][these cool git functions]] and [[https://github.com/jogendra/dotfiles/blob/master/git/gitconfig][configs]]
    - [ ] git bare repo ?
      + user's home is overflowing with dotfiles ('hidden'), mind it could be tedious if choose git bare and have to go through all the files to add to own dotfiles (https://web.archive.org/web/20171003124306/https://plus.google.com/+RobPikeTheHuman/posts/R58WgWwN9jp)
  + [ ] checkout use of environment variables $XDG_* (https://0x46.net/thoughts/2019/02/01/dotfile-madness/ and https://wiki.gentoo.org/wiki/XDG/Base_Directories)
    - $XDG_DATA_HOME or $HOME/.local/share for example to store plugins downloaded by the user, databases created by your program, user's input history, bookmarks, emails, and so on
  + [ ] optimise auto-complete
  + [ ] vim (learn basics, and tweak configs, seems there is no way to escape from it when working with bare installation or with the terminal)
  + [ ] IDE ::
    - add configs for one 'mainstream' IDE too, eg: vscode (settings, format, plugins, etc.)
  + [ ] ==user, server, common, private, business, work, work-a, etc.==
  + [ ] stow ?
    - at first glance yes: build folder ~dotfiles/$user~, so will most probably stow that folder
    - checkout [[https://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html][this]], [[https://spin.atomicobject.com/manage-dotfiles-gnu-stow/][this]] and [[https://blog.palcu.net/2014/06/dotfiles-and-dev-tools-provisioned-by.html][this one maybe]] which relies more on ansible ("bash on steroid")
  + [ ] live updates mechanism:
    - [ ] preferably add 'uninstall' or remove command
    - [ ] script for updating target 
  + [ ] ansible might be a robust alternative to writing custom bash script, for example, could be useful to manage when an action was successful, or when an error occurs, resume where left off
  + [ ] [[https://zellij.dev/documentation/][zellij]] (terminal multiplexer written in rust and made to be a better tool than tmux, which is written in C, and sometimes lacking)
    - checkout how to create workspaces: https://spin.atomicobject.com/dev-project-workspace-tmux/
    - checkout how to add more functionalities to it:
      + https://jolicode.com/blog/organiser-son-terminal-avec-des-workspaces
      + https://github.com/niflostancu/tmux-workspaces
  + [ ] zplugin ? : as a replacement for zplug (https://gist.github.com/laggardkernel/4a4c4986ccdcaf47b91e8227f9868ded)
*** Notable files and folders (some)
- dotfiles structure :: source of things to do
- install.sh ::
  + main entry point for dotfiles installation
- configs :: 
  + any env, 'smthing.yaml', opt, in config other than basic, is an addition to base config: ==basic > common > dmahoro==
  + basic :: configs and tools for basic environment
    - ==packages/*.yaml== ::
      + used to install tools needed for basic install use
      + others tools to install are to be put in specific "group" of '*.yaml' installation files ('dpkg.yaml', 'pip.yaml', etc.)
      + add some basic tools and default compilers to start with, so can do basic tasks such as running a basic test environment
      + to install ::
        - build-essential, git, tree, curl, wget, screen (GNU screen, multiplexer), g++, python, java jdk (basic one: default-jre), valgrind, ccze (log files colorizer)
    - env :: 
      + basic.env :: for lightweight basic configs
        - GNU screen custom configs ::
          + complete configs in ==screenrc==
          + change GNU screen's default control sequence prefix ~C-a~, which is used many other places and other commands, to ~C-@~, and its alias ~M-1~ (see [[file:linux_commands_and_tools.org::#screen_configs][see screen (terminal multiplexer)/basics/screen control sequence prefix]])
          + bind ~[prefix] X~ to close current screen split region: ~bind X remove~ (same as doing into the split screen ~[prefix] ':remove'~)
    - bin (folder) :: 
    - opt (file) :: for opt configs
    - opt.yaml ::
      + basic 'opt' tools that needs to be cloned (org-contrib ?), or installed specifically in 'opt' folder
      + to install :: ==opt/elisp/org-contrib==
    - vim ::
      + ".vimrc": vim configs
      + vim.sh: for eventual plugin install
      + emacs configs to be put in 'common' profile, in basic one just deal with vim terminal
  + academic ::
    - decouple config from 'private'
    - latex for emacs
  + common ::
    - apt.yaml ::
      + add to default compilers further debugging, dependencies managers, and optimisation tools (valgrind, ansible, etc.)
      + to install ::
        - docker, ansible
    - opt (file) :: further opt configs
    - opt.yaml ::
      + cloning additional elisp stuff, knowing that some are already in 'basic', eg: ==opt/elisp/org-contrib==
    - dev (folder) ::
      + contains configs for IDEs, formatting, dev utils, etc.
      + additional tools/repos/plugins/etc. are either in 'dev' folder, or any other dotfile/**/*.yaml, such as ==./common/some-ide.yaml==
      + docker ::
      + podman ::
      + vscode (folder) ::
        - vscode (file) :: for configs
        - vscode.yaml (file) ::
          + to install extensions through command line, checkout how to do it [[https://code.visualstudio.com/docs/editor/extension-marketplace#_command-line-extension-management][here]]
        - settings.json ::
        - *.json :: 
    - emacs (file) ? :: what to install in basic emacs split from common ?
      + no 'emacs.yaml' file, emacs packages are installed and set in .el configuration files
        - or maybe an emacs.sh since script will execute installation instructions
      + basic emacs configs
      + undo-tree, global-undo-tree-mode, emacs multiplexer
      + do not forget to adapt emacs to windows, for example when enabling flyspell/ispell, one needs to install the dictionary first (here hunspell aspell is used in place of usual ispell):
        #+begin_example
        ;; add the path of the aspell exec to your emacs exec-path (absolute path required)
        ;; but better use a generic path: ==~/opt/Hunspell== instead of "c:/Program Files (x86)/Hunspell/bin/"
        (add-to-list 'exec-path "c:/Program Files (x86)/Hunspell/bin/")
          
        ;; tell emacs to use aspell in place of ispell
        (setq ispell-program-name "hunspell")
          
        ;; from any file, one can select a different language dictionary with ==M-x ispell-change-dictionary==
        (setq ispell-local-dictionary "en_US")
          
        ;; For saving new words to the personal dictionary, don't infer it from the locale, otherwise it will be saved to the default
        (setq ispell-personal-dictionary "~/.hunspell_personal")
          
        (require 'ispell)
        #+end_example
    - emacs (folder) ? ::
      + clone of ==~/.emacs.d/== ? :: should contain emacs.d content, ones that can't be installed
    - git ::
      + advanced configs, such as direnv
      + preferably use git submodules when dealing with embedded repos, and maybe use subtree and worktrees when appropriate
  + private ::
    - added as a private repo with git submodules
- profiles ::
  + allows easy selection of given profile: suppose one needs to configure a very light basic environment (==basic==), an more heavier environment that is still missing personal stuff, but with a working docker environment: (==basic+common==), or a full personal profile that contains all "dmahoro" environment (==basic+common+private+academic==), etc.
  + when a profile is configured meaning the structure is there, the env set, bin, etc. then one can stow that profile, for example ~stow common~
  + install.sh ::
    - so that can setup the selected profile, and also have the same basic folders organisation for all profiles  ::
      + all profiles have the same basic folder organisation, and each content will expand from it:
        - opt ::
        - emacs ::
        - repos ::
        - etc. ::
    - other profiles have this basic files structure, plus further customisation
    - "custom" profile ::
      - if select a specific profile, it might install others:
        + common :: basic+common
        + academic :: dmahoro-private
        + private :: dmahoro-academic
        + dmahoro :: all
  + basic ::
    - default environment installed if no particular one specified
    - basic profile to bootstrap a lightweight and ready-to-go environment, eg: for a docker environment to use for tests
  + common ::
    - less lightweight than basic and close to full working environment, but still not too cluttered to be described as a "light" environment
  + dmahoro ::
    - "configs": ==basic + common + academic + private== (all)
    - env :: 
    - opt :: add further full profile for dmahoro "dev" for example, with c++/cmake/java/docker/etc.
    - repos :: add complete list of repos
      + org :: memacs
    - private ::
      + set through profile 'private'
      + folder containing private submodules, some with different remote links (direnv ?), but in any case need to set a ==gitignore== to adapt git configs to target different remotes for example
      + see private for content structure pro
      + work ::
        - company_a ::
        - company_b ::
        - etc. :: 
  + private ::
    - profile for private stuff =>
      + *DON'T commit keys/tokens/passwords and create SECURITY BREACHES*
      + *DON'T push on public profile*
      + dev-repos ::
    - repos-private ::
      + bizz ::
        - for private projects with "for-profit" intent
        - proj-a ::
          + dev :: for repos
          + org :: for org stuff
        - proj-b ::
        - etc.
      + work ::
        - company_a ::
          + dev :: for repos
          + org :: for org stuff
  + "custom" ::
    - alias for "common", but with different $USER value (is it even possible ? $USER is set at installation right ?)
  + can create others whenever needed
*** questions
- target structure ::
  + should be different than the dotfiles structure ? => how will updates work when wants to change something and push it to dotfiles repo ?
** issues (while working on dotfiles)
*** issues when testing dotfiles in an isolated (containerised) environment (podman here):
- vim in containers ::
  + not pre-installed, so need to install it first
  + vimrc:
- zsh and podman ::
  + when running sandbox, theme loading gets stucked, eg: stucked in "Installing spaceship-prompt/spaceship-prompt!"
  + no definitive fix found so far, but workaround ::
    1. in zsh shell, remove spaceship-prompt/spaceship-prompt using antigen: ~antigen purge spaceship-prompt/spaceship-prompt~
    2. still in zsh shell, update antigen plugins: ~antigen update~
    3. should do the trick
- running podman in rootless/rootful environment ::
  + by default, podman runs a rootless environment, so no use to run a command that may change the state of the container's system such as ~apt~
  + to be able to install packages, need to run podman rootful (run podman as root or sudo from host: ~sudo podman run~)
  + in rootful, sudo is not installed, so might need to install it if needed
  + not many user environment variables predefined, eg: $USER, that is needed by $TARGET_FOLDER. So, need for a way to do that, by using containerfile for example
- missing environment variables in container :: eg: "$user"
  + use containerfile to set environment variables
- podman container environment for dotfiles testing :: default root user, or custom user
  + required options:
    - run as rootful from host: (~sudo podman run~), since dotfiles configs install tools and change the state of the container
  + option 1 :: run as default "root" user
    - consequences (good and bad):
      + no need to install sudo, which is not good since these dotfiles are oriented to usual linux user environment, which is sudo-based
    - steps to workaround configs issues:
      + silence out (comment) "keep-alive" part which is using sudo (~if sudo -v; then etc.~)
      + cancel out "sudo" wherever defined in the dotfiles: fortunately all dotfiles commands to run go through one function: ==dotfiles/configs/basic/bin/functions/utils.sh:execute_command==, so can filter out "sudo" from there:
        #+begin_example
        if [[ -n "$command_to_run" ]]; then
          eval "$command_to_run"
          if [[ "$command_to_run" == *"sudo"* ]]; then
            # thecmd=${command_to_run: 5} // remove since not specific enough
            thecmd=$(echo "$command_to_run" | sed -e 's/[[:space:]]*sudo[[:space:]]*//g')
            echo "the command to run: $thecmd"
            eval "$thecmd"
          fi
          #eval "$command_to_run"
        fi
        #+end_example
    - install required through containerfile:
      #+begin_example
      FROM debian:bookworm
      ENV USER=root
      RUN apt update && apt install -y vim git && mkdir repos && cd repos && git clone https://github.com/horamaAI/dotfiles.git
      #+end_example
  + option 2 [PREFERRED] :: run as pre-defined user
    - consequences:
      + use containerfile to define a user different than default root:
        - without any further configs such as configuring UIDs and GIDs, even if running in rootful, the user won't still be able to install commands since only root inherits the privileges of the host's UID, and root user is the only one allowed to do so anyway
        - can overcome issue by installing sudo (from the containerfile), that will allow the default user to switch to root to install tools
    - containerfile:
      #+begin_example
      FROM debian:bookworm
      ARG CONTAINER_USER=sandboxuser
      # for container to know it's one (useful for containerised development and troubleshooting)
      ENV RUNNING_IN_DOCKER true
      ENV USER $CONTAINER_USER
      ENV HOME /home/$CONTAINER_USER
      WORKDIR $HOME

      RUN apt update && apt install -y vim git
      RUN mkdir -p $HOME/repos && cd $HOME/repos && git clone https://github.com/horamaAI/dotfiles.git
      RUN apt -y install sudo
      RUN adduser --system --group $CONTAINER_USER \
        && echo "${CONTAINER_USER}:${CONTAINER_USER}" | chpasswd \
        && usermod -aG sudo $CONTAINER_USER
      # give to defined normal user ownership of the home folder
      RUN chown -R "${CONTAINER_USER}:${CONTAINER_USER}" $HOME
      USER $USER
      #+end_example
*** stowing is kinda ugly though, and maybe prone to bugs ?
[2025-02-01 Sat 18:48]
- what if ::
  + proposition 1 ::
    - keep list of generated dotfiles (eg: .zshrc),
    - back-up existing one (by moving to name: original name, and appending: ==.original-backup==, eg: .zshrc.original-backup)
    - copy file to target (eg: HOME)
    - advantage (alleged):
      + when comparing current state of environment with committed one (for example when added a tool, but didn't add it yet on dotfiles repo), one can compare the dotfiles in the stored list: ~diff local_dotfile VS dotfile_repo_counterpart~
      + in that way, can for example implement a weekly verification of repo's required updates
*** Testing dotfiles environment
[2025-01-26 Sun 20:28]
- parsing json/yaml using jq and yq ::
  + fetch content from multiple fields :: eg, fetch content of fields: ~{ .command, .command_for_test }~
    1. simplest way: ~jq '.command_entries[] | .command, .command_for_test'~, but then how to transform the result into an associated array
    2. feedback on experimented commands:
       - main issues:
         + if transformed directly as an associative array directly from jq, then results are wrapped into double quotes (jq returns a string)
         + in case data is missing, for example for .command_for_test which is nullable, how to replace 'null' into empty string
       - what finally worked ::
         + pipe each field to @sh (wraps in single quotes), and then trim double quotes at the edge: ~declare -A ffs="($(yq '.' configs/basic/packages/apt.yaml | jq --arg buff '' '.command_entries[] | "[" + (.command | @sh) + "]=" + (.command_for_test // $buff | @sh)' | tr -d \"))"~
       - things tried:
         + use default replacement when null or empty: ~(.nullable_field // [replacement])~, eg: ~yq '.command_entries[] | .command_for_test // "toto"' configs/basic/packages/apt.yaml~
           - if need special formatting, for eg insert empty quotes as replacement, then better to use args definition with jq:  ~yq --arg buff '' '.command_entries[] | .command_for_test // $buff' configs/basic/packages/apt.yaml~, will replace with empty string, including the single quotes
         + return results that are interpretable by the shell, eg: array of tab separated data (not raw string): ~yq --arg buff 'xoxo' '.command_entries[] | [.command, .command_for_test // $buff, .description] | @tsv' configs/basic/packages/apt.yaml~ -> pro: less manual parsing, big con: flat array, not formatted as associated array
           #+begin_example
           ```
           "apt install\tapt list --installed | grep -q \tinstall via debian Advanced Package Tool"
           "dpkg -i\txoxo\tdebian package manager"
           ```
           #+end_example
         + can also use ~@sh~ in place of ~@tsv~ to return shell interpretable data: ~yq --arg buff 'xoxo' '.command_entries[] | [.command, .command_for_test // $buff, .description] | @sh' configs/basic/packages/apt.yaml~, will wrap the piped data into single quotes directly usable by the shell. -> has no con in itself really, just that if one is not careful, the result can still be encased into a string and thus be hard to parse again into an associative array
           - eg: this complex parsing is trying to tweak a result from jq to be formatted as we want (array) ~read -A allo <<< $(yq --arg buff '' '.command_entries[] | [.command, .command_for_test // $buff, .description] | @sh' configs/basic/packages/apt.yaml | tr -d \'\" | tr ' ' '_' | tr '\n' ' ' | sed 's/[ \t]*$//')~
             + however, the issue is jq that returns a faulty array from the beginning (single quote separated array, which is also considered as a single string), and can be hard to parse again if the starting result is already wrong (hard then to know which space is from original array's items, or is one used to separates items)
             #+begin_example
             ```
             /apt_install_apt_list_--installed_|_grep_-q__install_via_debian_Advanced_Package_Tool/
             /dpkg_-i__debian_package_manager/
             ```
             #+end_example    
         + other more example of very complex jq formatting tweaks that still landed strings, or other unwanted results:
           #+begin_example
           $ yq '.' configs/basic/packages/apt.yaml | jq --arg buff '""' '.command_entries[] | .command + "=" + (.command_for_test // $buff)'
           ```
           "apt install=apt list --installed | grep -q"
           "dpkg -i=\"\""
           ```

           # wtf, why ? just why ? xD
           $ yq '.' configs/basic/packages/apt.yaml | jq '.command_entries[] | {(.command): (.command_for_test // "")} | to_entries | map("\(.key)=\(.value)")'
           ```
           [
             "apt install=apt list --installed | grep -q"
           ]
           [
             "dpkg -i="
           ]
           ```

           $ yq '.' configs/basic/packages/apt.yaml | jq '.command_entries[] | {(.command): (.command_for_test // "")} | to_entries'
           ```
           [
             {
               "key": "apt install",
               "value": "apt list --installed | grep -q"
             }
           ]
           [
             {
               "key": "dpkg -i",
               "value": ""
             }
           ]
           ```
           #+end_example
- while adding bash tests for proper installation verification (using [[https://github.com/bats-core/bats-core?tab=readme-ov-file][bats]]) ::
  + store installed components to test if everything went well ::
    - solutions (proposed):
      + storage ::
        - [OK] global associative array :: of ==command->[packages]== is exported at superscript level,
          + ==command== is the command to test if *installation went properly*, not the command that was used to install
          + to allow adding to this super global variable, need to source subscripts, than running it in an independent shell
        - could be a simple 1D associative array (element is a space separated string of packages) instead of a 2D one (associative array of array of packages) ? 
      + ==execute_install_command== ? ::
        - prop1: takes as 1st *mandatory* argument the associative array of ==command->[packages]==, and add to it the new installed elements
        - prop2: same as prop1, but as 3rd optional argument (possible to do if arguments are grouped using quotes, eg: ~execute_install_command "arg1" "arg2_1 arg2_2" "arg3" "etc"~)
          + pros: since optional, can just skip storage
          + cons:
            - ~if $# -gt 3, then~;
            - does subscripts handling always proper and modify the right array ?;
            - concats or overwrites ?
        - [OK???] prop3 :: return what installed this turn
          + pros:
            - no additional if-then, or arguments for that matter;
            - always returns, up to you to use or not
          + cons ::
            - key of associative array when concatenating ? :: ~asso_array[akey]+="a new value"~ seems to work
      + ==execute_install_command== ? ::, takes a 1st *mandatory* argument, which is the associative array of ==command->[packages]== to add new elements to
    - to test that installations, other stuff and everything went well
    - super global variable (eg: ==INSTALLED_APPS==): for those tests purpose, one needs for example to collect installed tools/apps from various subscripts, and use them where the tests are defined, eg: ~configs/basic/tests/test.bats~
    - hurdle: per any subscript that installs anything, it needs to return what was installed to parent (recursive too: collect everything installed by sub-subscripts, and return all to parent)
    - files structure:
      #+begin_example
      + profiles/basic/basic.sh // declares global variable 'INSTALLED_APPS'
      +   // call to 'execute_install_command' (configs/basic/bin/functions/utils.sh)
      +   // => can run execute_install_command, and if runs into an error, then WARN, or ERROR, otherwise store installed in the associated list
      +   execute_install_command "apt" "sudo apt install ${apt_essentials[*]}"
      +   execute_install_command "npm" "sudo npm install -g" "${npm_essentials[*]}"
      +   source configs/basic/packages/setup.sh
      +     // sourced, so since in current shell, then can theoretically update associated list of installed tools
      +     // otherwise, if setup.sh is run as bashed into a subshell, in that case to update content in this parent script, one can return from subshell, and retrieve values from parent shell
      +     process_commands_in_yamls yamlscmds // configs/basic/bin/functions/utils.sh
      +       for cmd_file in "${yamls_cmds[@]}"; do
      +         parse_command_entries_in_yaml and add apps to install into $commands_list
      +       for cmd in "${commands_list[@]}"; do
      +         execute_install_command "read from yaml" "$cmd"
      + // same for other profiles: ~profiles/*~
      #+end_example
    - other functions used:
      + process_commands_in_yamls: as in ~process_commands_in_yamls yamlscmds~, used to read from yaml and execute install commands read from it
    - structure of test:
      - ==for each pkg in packages, do if 'command_for_test pkg', then returns/print OK/check; otherwise KO/cross==
    - how ::
      - in schema, add field "command_for_test" that is run to test that installation of referenced package finished properly
  + install commands and their validation counterparts ::
    - apt :: use apt-mark and grep on tested package name. Nice to utilise sequentially on the list of installed packages
      + ~apt-mark showinstall | grep -q "^bats" && echo "installed" || echo "not"~
    - npm :: test only globally installed. For local ones can check folder packages.
      + ~npm list -g | grep pajv~
** Test/emulate/simulate
- required ::
  + podman
  + all steps should be found in and run from folder ~configs/common/containers~ (TODO)
- steps ::
  1. pull debian sandbox: ~podman pull docker.io/library/debian:bookworm-slim~
  2. build a Containerfile to configure the image build process, eg:
     #+begin_example
     FROM debian:bookworm-slim
     ARG CONTAINER_USER=sandboxuser
     # Set the working directory in the container
     WORKDIR /home/$CONTAINER_USER
     RUN addgroup -S $CONTAINER_USER && adduser -S $CONTAINER_USER -G $CONTAINER_USER
     USER $CONTAINER_USER
     CMD ["whoami"]
     #+end_example
  3. run debian container: ~podman run -it debian:bookworm-slim~
- podman commands :: (some, most used ones)
  + ~sudo podman images -a~
  + ~sudo podman ps -a~
  + ~sudo podman run --rm -it test:latest~
  + ~sudo podman rmi --all~
  + ~sudo podman rmi a66502a66ac3~
  + ~sudo podman build -t test:latest .~
  + ~sudo podman top~

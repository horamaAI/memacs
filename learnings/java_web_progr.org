# -*- mode: org -*-
#+title: Java web programming learnings
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+TAGS: Java


* JAVA
** Notes
- Targeted JAVA version :: JAVA 17
- IDE used : IntelliJ ::
  + pros :: does lots of stuff for us from elements that are hinted by the dev : (install a small cli java compiler when there is none defined, update external libraries, etc.)
** Compile and run
- JRE :: java runtime environment, that makes it able for java applications to run.
  + The jre is cross platform, it takes standard 'bytecodes' (compiled classes that are OS agnostic), and through the JVM (Java Virtual Machine) and additional standar java libraries, adapt those bytecodes to the local environment.
- JDK :: Java development kit: JRE + compiler, debugger, javadoc, keytool, etc.
- flow :: *.java --[JDK]--> *.class --[JRE]--> execute
- can check project's 'module settings' :: at any moment, with right click -> 'open module settings'
  + to check the application structure, dependencies, paths, etc.
- comments ::
  + usual comments :: line comment (==//...==), block comment (==/*...*/==)
  + javadoc comments :: ==/**...*/== : same as block comments, but can be generated as javadocumentation
** Fundamentals
*** Java fundamentals and structural assumptions
**** Structure and conventions
+ naming conventions ::
  - packages ::
    + all lowercase,
    + use of reverse domain name notation to assure global *uniqueness* (there is an authority that makes sure the domain name is not used by someone else) : [domain_extension].[domain_main_name[.more_extension]*][...], eg : org.mydomain
    + add further qualifiers to assure uniqueness within company/group (eg: all code related to searching within domain 'mydomain' can be added to package ==org.mydomain.search==, ie. ==package org.mydomain.search;==)
      - same, the dev group in the sales department could use the following reversed dns ==org.mydomain.sales==
      - furthermore, if the devs in the sales department created an app that manages the sales account, they could use 'accounts management' in the reversed dns ==org.mydomain.sales.accountmanagement== => this avoids collisions in case another department create a sales account application.
  - type names are qualified by their package :: package org.mydomain.sales, qualifies class 'A' that is declared within it, and then, type name of A is now org.mydomain.sales.A (now they're globally unique)
    + when qualified, the executable part of the code is also qualified, ie: instead of running in cli ==java Main==, just run the qualified version ==java org.mydomain.sales.Main==
  - variables naming conventions :: only letters and numbers, no starting with number, camelCase (not start with uppercase)
  - classes :: same as variables, but first letter capitalized, name of class must be the same as file name :: class Toto => file Toto.java
  - methods :: same as variables
  - enums :: enum class naming convention same as usual classes (first char uppercase, camelCase), values: all in uppercase
*** Variables, types, operators data type conversions, and operators arithmetics
[2023-11-28 Tue 19:32]
**** Operators and types
[2023-11-28 Tue 19:37]
- Variables :: named area of storage (Java strongly typed language)
- primitive types ::
  + primitive types are stored *by value* (directly store the *values* when assigning, in contrast to classes that store references to instantiated objects). They represent only data, they're not able to provide methods for operating on that data
  + chars :: single unicode char, eg: 'u' or '\u00DA' (for 'u' with accent: \u followed by 4digits hex value of char)
  + integer :: byte (8bits), short (16bits), int (32bits), long (eg: 9L)
  + decimal :: float (32bits, eg: 3.14f), double (64bits, eg: 3.14 or 3.14d)
  + boolean :: true/false (primitive)
    - note ::
      + xor operator ==^== is true only when the two operands are differents (0^1 or 1^0)
      + conditional logical operators (&& and ||) evalueate the right side only when needed (in case of ||, only evaluate right hand side when left is false)
  + byte[] for binary files :: eg, a photo can be referenced as type ~private byte[] aPhoto;~
- ==var== "type" :: type then inferred with first assignment, no need then to explicitly define the type of the variable
  + constraints :: need to be assigned when declared, and variable is statically typed (cannot change the type of assigned value), therefore need for cast when assigning a non matching value
- ==final== :: constant variable/attributes/classes/methods
- ==static== :: keyword set what's defined to only one instance of object/class/method/etc., and have persistent lifetime (object is associated to the class), 'static' indicates that a particular member is not an instance, but rather part of a type
  + static variables get loaded when class is loaded by ClassLoader, and removed when Classloader used is garbage collected
  + static methods *only* work with static variables
  + "static import statement" ::
    - "import statement" :: allows a type name to be used without being package-qualified (give the full package path: ~package com.example.etc~)
    - "static import statement" :: used with static methods, allows method name to be used without being class qualified
      #+begin_src java
      // instead of importing using : import com.example.something.AClass;
      // use static keyword with the full path to the static member
      import static com.example.something.AClass.staticMember;

      staticMember; // and now the static member can be called without the call to the class (without "qualifying" the member by its class)

      // can do even better by referencing all static members of class AClass:
      // import static com.example.something.AClass.*;
      #+end_src
  + static initializer :: run only once, before type's first use (can be used for example for using connection services)
    - has access to static members only
    - static keyword preceded
    - and *out of any constructor or method*
      #+begin_src java
      public class A {
          private int member1;
          private static boolean statMember;

          static { // will run only once, before class A is used
              AdminService admin = new AdminService(); // dummy service that hypothetically check if there is no restriction exists based on some implementation
              admin.connect();
              statMember = admin.anyRestriction() ? false : true;
              admin.close();
              }

          public A(int member1) {
              this.member1 = member1;
              }

          }
      #+end_src
- operators ::
  + operators precedence :: left to right when equivalent or when tied
    - precedence order :: postfix, prefix, multiplicative (==* / %==), additive (==+ -==)
      - table ::
        +-----+----------+--------------+-------------+
        | 16  | ()       |parentheses   |left-to-right|
        +-----+----------+--------------+-------------+
        |     | []       |   array      |             |
        |     |          |  access      |             |
        +-----+----------+--------------+-------------+
        |     |  .       |  member      |             |
        |     |          |  access      |             |
        +-----+----------+--------------+-------------+
        | 15  | ++       |    unary     |left-to-right|
        |     |          |post-increment|             |
        +-----+----------+--------------+-------------+
        |     | --       |    unary     |             |
        |     |          |post-decrement|             |
        +-----+----------+--------------+-------------+
        | 14  |  +       |  unary plus  |right-to-left|
        +-----+----------+--------------+-------------+
        |     |  -       | unary minus  |             |
        +-----+----------+--------------+-------------+
        |     |  !       |unary logical |             |
        |     |          |     NOT      |             |
        +-----+----------+--------------+-------------+
        |     |  ~       |unary bitwise |             |
        |     |          |     NOT      |             |
        +-----+----------+--------------+-------------+
        |     | ++       |    unary     |             |
        |     |          |pre-increment |             |
        +-----+----------+--------------+-------------+
        |     | --       |    unary     |             |
        |     |          |pre-decrement |             |
        +-----+----------+--------------+-------------+
        | 13  | ()       |     cast     |right-to-left|
        +-----+----------+--------------+-------------+
        |     | new      |    object    |             |
        |     |          |   creation   |             |
        +-----+----------+--------------+-------------+
        | 12  |* / %     |multiplicative|left-to-right|
        +-----+----------+--------------+-------------+
        | 11  | + -      |   additive   |left-to-right|
        +-----+----------+--------------+-------------+
        |     |  +       |    string    |             |
        |     |          |concatenation |             |
        +-----+----------+--------------+-------------+
        | 10  |<< >>     |    shift     |left-to-right|
        +-----+----------+--------------+-------------+
        |     | >>>      |              |             |
        +-----+----------+--------------+-------------+
        |  9  |< <=      |  relational  |left-to-right|
        +-----+----------+--------------+-------------+
        |     |> >=      |              |             |
        +-----+----------+--------------+-------------+
        |     |instanceof|              |             |
        +-----+----------+--------------+-------------+
        |  8  |    ==    |   equality   |left-to-right|
        +-----+----------+--------------+-------------+
        |     |    !=    |              |             |
        +-----+----------+--------------+-------------+
        |  7  |    &     | bitwise AND  |left-to-right|
        +-----+----------+--------------+-------------+
        |  6  |    ^     | bitwise XOR  |left-to-right|
        +-----+----------+--------------+-------------+
        |  5  |    |     |  bitwise OR  |left-to-right|
        +-----+----------+--------------+-------------+
        |  4  |    &&    | logical AND  |left-to-right|
        +-----+----------+--------------+-------------+
        |  3  |    ||    |  logical OR  |left-to-right|
        +-----+----------+--------------+-------------+
        |  2  |    ?:    |   ternary    |right-to-left|
        +-----+----------+--------------+-------------+
        |  1  | =   +=   |  assignment  |right-to-left|
        |     |    -=    |              |             |
        +-----+----------+--------------+-------------+
        |     |*=   /=   |              |             |
        |     |    %=    |              |             |
        +-----+----------+--------------+-------------+
        |     |&=   ^=   |              |             |
        |     |    |=    |              |             |
        +-----+----------+--------------+-------------+
        |     | <<=  >>= |              |             |
        |     |   >>>=   |              |             |
        +-----+----------+--------------+-------------+
        |  0  |    ->    |    lambda    |right-to-left|
        |     |          |  expression  |             |
        |     |          |    arrow     |             |
        +-----+----------+--------------+-------------+
  + operator 'instanceof' :: ~(object) instanceof (type)~, checks if object is of type 'type' (note: instanceof is still an operation, and hence imply a cost, so try to reduce this with better design)
- Type conversion ::
  + implicit :: performed by compiler (eg: long valLong = valInt; // where valInt is explicitly declared as int, said as "widening conversion")
  + explicit :: with cast operator (eg: int valInt = (int) valLong; // where valLong is explicitly declared as long, careful of *side-effects*: precision loss, and compiling errors)
- conditional logic and operators ::
  + ==switch default== cases :: only supported on primitive types: byte, char, short, int, long
    - format :: ==switch(val) {case k0: ...; break;...;default:...;break;}
- Non primitive types ::
  + non primitive types do not directly hold object values, but rather hold references to values => new instances of the objects are created
    - eg = doing ~String str = "I";~ and then ~str += ' Love'; str += " you"~, will create 3 string instances : "I", "I Love", "I Love you", and then str will reference the 3 strings in order until the last => *BE CAREFUL*
    - can use StringBuilder for more efficiency
  + equality operator =='=='== DOES NOT check equality of values, but rather if the operands are pointing to the same reference
  + strings ::
    - 
  + arrays :: format : ==type[] = new type[nElements];==, or with list initialization: ==type[] = {ele1, ..., eleN};==
    - size of array :: ==arrayVar.length;==
*** Methods, Class, Objects
[2023-11-29 Wed 14:05]
**** Notes
[2023-12-02 Sat 02:14]
- members of class (its 'fields') can also be called its 'states'
- default access modifiers :: 'package-private': members are only visible within the package (inside the same package to which the class belongs)
- default constructors in java will fill default values where possible (primitive types and default constructors for embedded object)
  + *careful* :: java generates default constructors only when none is provided, thus if custom constructors are provided, then all the different constructors have also to be provided for the different type of signatures that will be needed
  + when constructors are provided, the constructor with no arguments is then called the default constructor
- "chained constructors": embedded constructors calls :: to avoid boilerplates and use available constructors to cascade all the parameters until the top (no order in the constructors declaration needed)
  #+begin_src java
  public class A {
      int member1;
      int member2;
      public A(int member1, int member2) {
          this(member1);
          this.member2 = member2;
          }
      }
      public A(int member1) {
          this.member1 = member1;
          }
      }
  #+end_src
- "initialization blocks" :: code that runs during object creation (not related to default constructor, works as completely separate (but interdependent))
  + initialization order :: field initializers -> initialization blocks -> constructors
  #+begin_src java
  public class A {
      int n = 5;
      boolean[] arrBool = new boolean[n];
      int member1;
      
      { // initialization block
          for(int i = 0; i < n; i++) {
              arrBool[i] = true;
          }
      }
      public A(int member1) {
          // initialization block above will run
          this.member1 = member1;
          }
      }
  #+end_src 
- null in java : ==null==
- "accessors" and "mutators" :: eg: getSmthing(), setSmthing(smthing)
- same as all non primitive types, classes instanciations (using ==new==) allocate new memory the size of the class specified. So, each time the variable is re-assigned with 'new', a new instance of the class is created, and the reference of the variable is changed to the new object, the old one being lost if not referenced anywhere else.
**** Methods
- Method arguments :: in java, every non primitive objects are references to objects. So when declaring a new object, it's just a reference to an instance. Furthermore, when calling a method, this method will create copy references of the arguments
  + wrong modifications of objects :: where changes have no effect outside of the method, as may be intended
    #+begin_src java
    // file A.java
    public class A {
      int i;
      public A(int i) {
          this.i = i;
      }

      static void swap (A a1, A a2) {
          A buff = a1; // here, a new reference 'buff' is pointing to the same instance as 'a1'
          a1 = a2; // the reference a1 is a new local reference (reference copy of the content passed as argument to method swap). So a1 will point to the same content as the reference used when calling method swap. new copy reference a1 == 20
          a2 = buff; // same as for a1, the new local copy reference a2 will then point to the content of reference buff, ie. a2 will point to the same content as buff <=> a2 == 10, but the content of the calling reference used on 'swap' will still point to the same content as before (no swap outside of the method)
      }
    }

    // Main
    public class Main {

      public static void main(String[] args) {
          A a1 = new A(10);
          A a2 = new A(20);

          A.swap(a1, a2); // when calling swap, the method will create copy reference, in that case the content is unchanged, ie. a1.i == 10; a2.i == 20
      }
    }
    #+end_src
  + right way of applying changes outside of the method :: changes apply on the *content* of the calling references (using setters and getters)
    #+begin_src java
    // file A.java
    public class A {
        // same as above, but with accessors and mutators
        ...
        static void swap (A a1, A a2) {
          A buff = a1.aGetter(); // buff member is a new reference to the content of copy reference a1
          a1.aSetter(a2); // here the changes apply on the *content* of the instance referenced by a1, ie. a1 points to object where the content is modified to 20 <=> a1.i == 20, and applies also outside of the method
          a2.aSetter(buff); // same as above, a2.i == 10
      }
    }

    // Main
    public class Main {

      public static void main(String[] args) {
          A a1 = new A(10);
          A a2 = new A(20);

          A.swap(a1, a2); // the content of the instances referenced by a1 and a2 were properly swapped: a1.i == 20; a2.i == 10;
      }
    }
    #+end_src
- Overloading :: when there is no signature for an overladed method that matches the one, the java compiler will cope: eg: if exists signature ~method(int)~, and one passes ~method(short)~, then the short can be promoted as an int to match the existing signature.
  + for more details about the steps of method selection at compile and run time, see [[https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12][dedicated oracle page]]
    - runtime for overriding, and compile time for overloading
**** Wrapper classes, enums, and records
[2023-12-02 Sat 19:35]
- primitive wrapper classes :: are classes that can hold primitive data values, *and* also provide methods (since they're classes), and enable compatibility with richer aspects of java type system
  + each primitive types have wrapper classes :: eg: Integer is the wrapper classes for integers int
  + "boxing" :: process to convert primitive types to their wrapper classes (often done implicitly by the compiler, and creates a new *copy* of the source primitive type, it doesn't just create a reference to the value)
  + "unboxing" :: the opposite of boxing, create a primitive type from a wrapper (same, creates a new copy)
- enums :: useful for defining a type with a list of *finite* valid values (use of keyword ==enum==)
  + enum support equality tests with content, not with reference
  + enum values are ordered from first value as lowest to last value as highest, so value can be quantitatively compared (relative comparisons with method ~compareTo~ that returns a negative, 0, or positive value)
  + supports ~switch cases~, and enum switch case labels must be unqualified (~ENUMVALUE~, instead of ~EnumClass.ENUMVALUE~)
  + enums are classes: explicit inheritance of java's ~Enum~ class, can have members, constructors, methods, etc.
    - main difference with usual classes :: enum types values are instances, meaning if the enum type has other member types, these are considered as instances, an can for example use constructor defined in the enum class
      #+begin_src java
      public enum Weekends {
          SATURDAY("Let's have fun!"), // enum values are separated by commas, not semicolons
          SUNDAY("Let's rest!"); // when finished enumerating values, then semicolons

          public String getTitle() {return title;}
          private:
              Weekends(String title) {
                  this.title = title;
              }
              String title;
          }
      // Main
      // ...
      Weekends day1 = Weekends.SATURDAY;
      Weekends day2 = Weekends.SUNDAY;
      assertTrue(day2 == Weekends.SUNDAY); // Yaayy!!
      assertFalse(day1 == day2); // Yaayy!!
      #+end_src
- records (or data-only classes) :: classes that only store data: useful to carry data around for example (data transportation)
  + help reducing boilerplates code (for example constructors implementation (particularly when complex models are being constructed), getters, and other common methods (equals, hashCode, toStrings, etc.))
  + use of keyword ==records== :: when keyword used, compiler automatically :
    - generate code (constructors, getters, equals, hashCode, etc.),
    - and apply *restrictions* (*immutability* being the main)
  #+begin_src java
  public record A (/* arguments as in methods : [type identifier], ... */String name, int age) {} // that's all
  // Main:
  // ...
  A a = new A(Toto, 12);
  A a2 = new A(Tata, 12);
  String nameA = a.name(); // OK, since generated by compiler
  // syso(a); also OK, since toString also generated by compiler
  assertFalse(a.equals(a2)); // same, also OK since equals is generated too and compares all the values of the objects
  #+end_src
*** Algorithms and standard library
**** Basics
- class 'Object' main methods  ::
  + clone :: create a duplicate instance of the source
  + toString :: by default prints reference numbers, not content (need to override)
  + equals :: compare content of objects for equality. By default, same as ~==~ and compare equality of references, not the content => needs for specialization (overriding Object's default equals) within the class:
    #+begin_src java
    public class A {
        private int member;
        A(int member) {
            this.member = member;
            }
        public boolean equals(Object o) {
            if (!(o instanceof A))
                return false;
            return this.member == ((A)o).member;
            }
        }
    #+end_src
  + getClass :: returns type information of the source
  + hashCode :: objects with same content have equal hash code, but different objects do not need to return different hash codes
    - hashCode algorithm contract ::
      1. same object must consistently return the same value (provided not modified meanwhile, and hash value can change through different execution)
      2. if objects are equal according to the equals(Object) method, hashCode() method on each of the two objects must produce the same value
      3. if two objects are unequal according to the equals(java.lang.Object) method, calling hashCode method on each of the two objects doesn’t need to produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables
- exceptions :: ~printStackTrace()~
- Wrapper classes :: converting to/from other primitive types (eg: ~Double.parseDouble(doubleAsString);~), extracting values from strings (for eg when strings contains integers), finding max/min values, etc.
- enums :: ~values~ (returns an array that contains all the enum values), ~valueOf~, etc.
- foreach :: ==for(loop-variable : array)==
- parsing ::
  + parse string as double :: Double.parseDouble(str);
- strings ::
  + strings are the same :: ==str1.equals(str2)==
    - can still use equality operator through "interning strings" (method ==str.intern()==) :: intern checks if no other string *reference* does not have the same content as str, and if it exists, then a new object won’t be created and the new reference will point to this other string
      #+begin_src java
      @Test
      public void whenIntern_thenCorrect() {
          String s1 = "abc";
          String s2 = new String("abc");
          String s3 = new String("foo");
          String s4 = s1.intern();
          String s5 = s2.intern();
          
          assertFalse(s3 == s4);
          assertTrue(s1 == s5);
      }
      #+end_src
      + *BE AWARE OF OVERHEADS!!!** with interning
  + useful String methods :: length, charAt, substring, replace, concat, toLowerCase, split (with separator given as regex ~str.split(",")~), format, contains, endsWith, compareToIgnoreCase, lastIndexOf, valueOf (convert primitive type to string, can also be done implicitly, eg : ~String res = 10 + " is an integer"~)
  + StringBuilder ::
    - provides mutable string buffer :: efficient, add new content with ==append==, add new content within with ==insert==
    - however :: need to extract string at the end with ==toString==, but can still keep using the string builder
      #+begin_src java
      String str = "toto";
      int n = 1;
      Stringbuilder strBuilder = new StringBuilder(40);
      strBuilder.append("I");
      strBuilder.append(" say");
      strBuilder.append(" I am ");
      strBuilder.append(str);
      strBuilder.append(" number ");
      strBuilder.append(n);
      String msg = strBuilder.toString(); // msg = I say I am toto number 1
      int pos = strBuilder.indexOf(" I am"); // can still work on the string builder
      String addendum = " will you tell him";
      strBuilder.insert(pos, addendum);
      msg = strBuilder.toString(); // msg = I say will you tell him I am toto number 1
      #+end_src
- CLI IO interactive ::
  + IO from cli :: object ==Scanner==
    #+begin_src java
    import java.util.scanner;
    ...
    Scanner scanner = new Scanner(System.in);
    scanner.nextLine(); // reads user input until end of key or EOF
    ...
    #+end_src
**** Streams
[2023-12-05 Tue 12:51]
- filter, foreach, anyMatch, collect :: eg:
  #+begin_src java
  // filter
  List<AircraftTarget> targets; // suppose it is initialized with latitudes and longitudes (integers)
  var aircraftInRange = targets.stream()
      .filter(a -> {
              var distance = (int) Math.sqrt((originLat - a.lat()) * (originLat - a.lat()) +(originLon - a.lon()) * (originLon - a.lon()));
              return distance <= range;}).foreach(System.out.println);

  // find if exists with 'anyMatch'
  public boolean hasAppointment(LocalDate date) {
      return appointments.stream().anyMatch(appointment -> appointment.getAppointmentDateTime().toLocalDate().equals(date));
      }

  // filter and collect
  public List<PatientAppointment> getUpcomingAppointments() {
      return appointments.stream().filter(appointment -> appointment.getAppointmentDateTime().toLocalDate().isAfter(today)).collect(Collectors.toList);
      }
  
  #+end_src
  
*** Annotations
[2023-12-03 Sun 00:35]
**** Notes
- useful to extend basic type system to incorporate extended infos about types within those types
- this allows tools and other code to act on context and intent based on the extended annotations :: eg: XML and JSON processors use annotations to simplify mapping between the java types and their respective representations
- annotations are special types that act as metadata. These metadata can be interpreted by different tools (compiler, IDE, etc.), execution environments, and even other programs (those that generate documentation for example)
- can even use annotations within the program, by writing programs that interpret needed annotations
- annotations are preceded by ==@== :: @Override (used by the java core platform), @Deprecated (to say that the marked element should no longer be used, and the compiler will generate warnings when used, but will still work), @SuppressWarnings (to indicate to the compiler to not generate certain kind of warnings, eg: to suppress deprecated compiler warnings: ~@SupressWarnings("deprecation")~)
- annotations can be used anywhere, so it's always good to reduce their scope so that one doesn't miss anything, eg for the case of SuppressWarnings, better to place ~@SupressWarnings("deprecation")~ on the deprecated method, instead of its whole class
  
** Definitions
[2023-12-13 Wed 11:58]
- artifact :: software artifact is an item that is produced during the development process. This can be a data model, a prototype, workflow diagram, a design document, or a setup script
- artifactId :: name of jar without version
- Beans :: essentially just classes, POJOs used inside the application context, replaces keyword ==new==
- Class vs Object :: object is an instance of a class, and a Class is its blueprint or template from which the object is created
- Classloader :: object that is responsible for loading classes
- Classpath :: parameter in the Java Virtual Machine or the Java compiler that specifies the location of user-defined classes and packages
  + the JVM finds and loads classes lazily (it loads the bytecode of a class only when the class is first used). The classpath tells Java where to look in the filesystem for files defining these classes
- Controllers :: files that expose the REST endpoints for registering and retrieving models details
- Encapsulation :: hiding the implementation of the details about methods, members variables, etc. inside a class
- Fields :: same as saying class members
- Hibernate :: Java framework that facilitates the growth of Java applications to interact with the database, automatizes db interactions
- JPA :: Java Persistence API, application programming interface specification that describes the management of relational data in enterprise Java applications
- MVC :: Model View Controller, requests are routed to a Controller that is responsible for working with the Model to perform actions and/or retrieve data
  + user -(uses)-> *controllers*
  + *controllers* -(manipulates)-> *model*
  + *model* -(updates)-> *view*
  + *view* -(is what seen by)-> user
- overloading vs overriding :: former: changing the signature of a method with different types of arguments, the latter: use in inheritance context, sets which method will be called, the base or the derived
- REST :: (Representational state transfer), software architectural style, defines a set of constraints for how the architecture of a distributed, Internet-scale hypermedia system, such as the Web, should behave
  + REST structures data in *XML, YAML, or any other format that is machine-readable, but usually JSON is most widely* used
- Spring Data JPA :: component of the Spring Framework, to significantly lessen the amount of boilerplate code needed to execute data access layers for multiple persistence stores
  + Hibernate is a JPA implementation, while Spring Data JPA is a JPA Data Access Abstraction
  + with Spring Data, you probably utilize Hibernate, Eclipse Link, or any other JPA provider
* Spring framework, and spring boot
[2023-12-04 Mon 22:52]
** Fundamentals
[2023-12-09 Sat 17:26]
- spring framework :: Inversion of control (IOC, see dependency injection (DI) solid principle) container, conceived to replace or reduce earlier complex configurations of earlier Java Enterprise Edition "EJBs" (Enterprise JavaBeans, spring was made to handle how to work better with EJBs, or without them all together)
  + DI :: allows to remove hard coded wiring in application and use framework to inject dependency resources where they're needed
  + spring ::
    - lightweight, easy to use framework built around reducing complexities around JEE and providing enterprise development without EJBs (can be used with or without EJBs, now it's mostly used without them: spring allows to do enterprise development without using application server).
      + mostly, before spring, either people weren't fully using enterprise features or were using more complex and harder to use application server
      + before spring, one would use design patterns from JEE blueprints for ex to help making better code and repeatable processes but which sometimes would make code brittle and untestable, eg: recompile code when moving to different environment. With spring we have WORA (write once run anywhere)
    - POJO (Plain Old Java Object) based :: any code written in spring can be written without using spring: spring is just doing things POJO based and interface driven
    - use of AOP (Aspect Oriented Programming) and proxies :: to apply things like transactions to the code to get cross cutting concern out of the application => code should be smaller and more lightweight from using spring
    - built around best practices :: spring makes us use best practices without realizing (singletons, factories, abstract factories, templates methods, etc.)
- what's spring trying to solve ::
  + increases :: testability, maintainability, scalability, decoupling;
  + reduces :: code complexity;
  + is business focused :: spring does the part of configuration code and lookup code for us and allows us to focus on the business
    - eg of business focused advantage :: with JDBC would do verbose instructions to manage database (Connection, PreparedStatements, etc.), and exceptions handling (try catch, etc.), but spring does everything for us and injects result into our code => A car is needed, then get us a car, don't spend to much time on the technical. Instead of implementing ourselves the fetching, configuration, etc. inside the method ~getById()~, with spring we can just directly use what spring injects:
      #+begin_src java
      public Car getById(String id) {
          return getEntityManager().find(Car.class, id); // No need for manager, connection, try catch, etc., not even in the base interface
          }
      #+end_src
  + interface-based driven development :: more focused, easy to tests
  + helps doing annotations or xml-based development :: as well as the java configurations
  + how it works ::
    - everything POJO
    - can be seen as a glorified hash map, an application context :: spring application context is the configured spring container will all the dependencies wired up within it (but not only though, spring is not just creating a hash map and putting all objects in it)
    - can be used as a registry
- download/install spring ::
  + no direct download for compiled jars, maven is still needed to download spring tools
  + maven modules repository :: https://mvnrepository.com/
  + maven repo has src, javadocs, binaries available for download:
    - in pom.xml, add spring context dependencies:
      #+begin_src xml
      <dependencies>
        <dependency>
          <groupId>org.springframework</groupId> <!-- org.springframework.boot for springboot -->
          <artifactId>spring-context</artifactId>
          <version>5.2.0.RELEASE</version> <!-- check on maven/spring website needed version -->
        </dependency>
      </dependencies>
      #+end_src
  + springboot: all ready to use
    
** Configurations
[2023-12-10 Sun 01:53]
*** java configuration
:PROPERTIES:
:CUSTOM_ID: JavaConfigs
:END:
**** Notes
- java configuration has no xml application context :: no xml file containing configurations. A context is still there, but just not configured in xml
- Application configuration file :: java class file that is the start of application context, the file where we start configuring the context of the application
  + 'AppConfig.java' file name is widely used :: but doesn't need specific name
    - can be placed one level up from specific folder such as model, service, repository, etc.: ==src/java/main/com/examples/AppConfig.java== (supposing service folder is in ==src/java/main/com/examples/service==)
- @Configuration :: to set start of configuration context
  + any methods defined in classes with @Configuration can return beans definitions that get stored in the spring context
  + file with configuration annotation replace xml files for the xml configuration for example
  + @Configuration is a *class level* annotation at the top of the class:
    #+begin_src java
    @Configuration
    public class AppConfig {

        @Bean(name = "customerRepository") // 'name' is optional, it registers with the name "customerRepository" the bean created for the class CustomerRepository
        public CustomerRepository getCustomerRepository() {
            return new HibernateCustomerRepositoryImpl();
            }
        }
    #+end_src
- Setters injection :: injection with setter method calls inside of a bean
  #+begin_src java
  @Bean(name = "customerRepository")
  public CustomerRepository getCustomerRepository() {
      return new HibernateCustomerRepositoryImpl();
      }
  }
  @Bean(name = "customerService")
  public CustomerService getCustomerService() {
      CustomerServiceImpl customerService = new CustomerServiceImpl();
      customerService.setCustomerRepository(getCustomerRepository());
      
      return customerService;
      }
  }
  #+end_src
- constructor injection :: same as setter injection, but with constructor :)
  #+begin_src java
  @Bean(name = "customerRepository")
  public CustomerRepository getCustomerRepository() {
      return new HibernateCustomerRepositoryImpl();
      }
  }
  @Bean(name = "customerService")
  public CustomerService getCustomerService() {
      CustomerServiceImpl customerService = new CustomerServiceImpl(getCustomerRepository());

      return customerService;
      }
  }
  #+end_src
- process of using spring java configuration :: need to call application context to use spring
  #+begin_src java
  public class Application {
      public static void main(String args[]) {

          ApplicationContext appContext = new AnnotationConfigApplicationContext(AppConfig.class); // ApplicationContext from org.springframework.context, and set it to use annotations (java configuration, using class AnnotationConfigApplicationContext), and loads configs set in class AppConfig (remainder: can be any name, but AppConfig is the widely used)

          }
      }
  #+end_src
  + process in few words :: when AnnotationConfigApplicationContext is ran, spring will create a basic registry of configurations set in the config file (for example, with configurations such as ones given in section "Setters injection", it will create a registry with 2 beans in it: "customerService", and "customerRepository")
  + fetching a bean :: with method "getBean". Preferably choose the one that does type casting ==getBean(Class<T> aClass)-> T==, but give it the desired target class so it doesn't need a cast
    - can call desired bean by name, with the name set on argument 'name' of @Bean
    - pass as second argument the class instance for casting
    #+begin_src java
    public class Application {
        public static void main(String args[]) {

        ApplicationContext appContext = new AnnotationConfigApplicationContext(AppConfig.class);

        CustomerService customerService = appContext.getBean("customerService", CustomerService.class); // thanks to setters injection, will also instantiate customerRepository bean
        // precise CustomerService.class so that getBean using casting doesn't really need to do a cast
        // no need to change anything when using constructor injection since everything is done in the service and repository classes, and some fix in the config class

        }
    }
    #+end_src
**** Bean scope
[2023-12-10 Sun 22:31]
- scopes :: used to configure beans in application, *scope != patterns*, 5 scopes available in spring:
  + valid in any configuration ::
    - singleton (spring default bean scope) :: ~@Scope("singleton")~ (or ~BeanDefinition.SCOPE_SINGLETON~ if you want to avoid typos) single instance per spring container or application context; technically not per JVM since can have more than one spring container spun up in a JVM
      + without maven, spring might require AOP jar, but with maven it's a transitive dependency and AOP will already be available in the project
        #+begin_src java

        @Bean(name = "customerRepository")
        @Bean(value = BeanDefinition.SCOPE_SINGLETON) // prefer available BeanDefinitions over writing scope yourself, you might type in typos
        public CustomerRepository getCustomerRepository() {
            return new HibernateCustomerRepositoryImpl();
            }
        }
        #+end_src
    - prototype :: guarantees new bean per request (opposite of singleton), ~@Scope(value = BeanDefinition.SCOPE_PROTOTYPE)~
  + valid in only web-aware spring projects with for example spring MVC (model-view-controller) ::
    - Request :: returns a bean per http request
    - Session :: returns a bean per http session (will live as long as session is alive)
    - Global (or "GlobalSession") :: returns a bean per application (once accessed, stays alive for the duration of the application, not just the visit on that application: similar to singleton but with the entire life cycle of the application on the server (for example until server gets undeployed or rebooted))

**** Autowiring
[2023-12-11 Mon 08:51]
- Autowiring :: used to reduce the wiring up and configuration of code. "convention over configuration"
- needed ::
  + add ~@ComponentScan({com.example})~ to configuration file: the arguments are an array of package structures that need to be scanned for beans to autowire, eg: ==com.example== indicates a place where should start looking for autowired annotations
  + to use autowiring, just mark whatever bean you want with ~@Autowired~
    - can choose by name, and it will look for @Bean name
    - can choose by type, and it will use instance type
- one advantage of java configuration over xml configuration for autowiring :: is that one can mix selections, eg: can set a bean defined as autowired with another bean into it, and spring will know how to use them
- 'Stereotype annotations' ::
  + @Component :: similar to @Bean
  + @Repository :: used to denote a class being used as a repository object
  + @Service :: where should put business logic handling (not related to web service or microservice)
  + @Controller :: where to put web or microservices for the application
- examples ::
  #+begin_src java
  // example 1: with partial autowiring (without @ComponentScan)
  public class CustomerServiceImpl implements CustomerService {

      private CustomerRepository customerRepository;

      // default constructor
      public CustomerServiceImpl() {
          // ...
      }

      // other methods and constructors: ...

      @Autowired // will automatically inject CustomerRepository bean into the setter
      public void setRepository(CustomerRepository repo) {
          this.customerRepository = repo;
          }
      }
  //...
  @Configuration
  public class AppConfig {
      @Bean(name = "customerRepository")
      @Scope(value = BeanDefinition.SCOPE_PROTOTYPE)
      public CustomerRepository getCustomerRepository() {
          return new HibernateCustomerRepositoryImpl();
      }

      @Bean(name = "customerService")
      public CustomerService getCustomerService() {
          CustomerServiceImpl customerService = new CustomerServiceImpl(); // will use default constructor, and thanks to 'autowired', will also run the CustomerService repository setter
          return customerService;
      }
  }


  // example 2: with full autowiring
  @Service("customerService") // set as a service with stereotype @Service
  // can even change scope at class level: @Scope(value = BeanDefinition.SCOPE_PROTOTYPE)
  public class CustomerServiceImpl implements CustomerService {

      private CustomerRepository customerRepository;

      // default constructor
      public CustomerService() {
          // ...
      }

      // constructor with argument:
      // possible to change autowiring at constructor level, since in AppConfig is not hard-code with which type of dependency injection is to be used, just setting @Autowired will know what method to use for dependency injection
      // @Autowired
      public CustomerService(CustomerRepository customerRepository()) {
          this.customerRepository = customerRepository;
      }

      // other methods and constructors: ...

      @Autowired // stays autowired to automatically inject CustomerRepository bean into the setter
      public void setRepository(CustomerRepository repo) {
          this.customerRepository = repo;
          }
      }

  @Repository("customerRepository")
  public class HibernateCustomerRepositoryImpl implements CustomerRepository {
      // constructors, methods, and others ...
  }

  //...
  @Configuration
  @ComponentScan({"com.example"})
  public class AppConfig {
      // no longer needed since CustomerService and CustomerRepository are now autowired
      /*
      @Bean(name = "customerService")
      public CustomerService getCustomerService() {
          CustomerServiceImpl customerService = new CustomerServiceImpl(); // will use default constructor, and thanks to 'autowired', will also run the CustomerService repository setter
          return customerService;
      }
      @Bean(name = "customerRepository")
      @Scope(value = BeanDefinition.SCOPE_PROTOTYPE)
      public CustomerRepository getCustomerRepository() {
          return new HibernateCustomerRepositoryImpl();
      }
      ,*/

  }

  #+end_src
**** Some annotations
- @Bean (java configuration analog of the XML <bean/> element) :: to define spring beans at *method level*, returns instance of a bean, and the bean is registered inside of spring and available for use inside of the spring application
  + by default beans are singletons
  + arguments ::
    - name :: bean name, optional, but useful when doing autowiring will autowire by name to variable names
- @Component :: similar to @Bean, but can also be applicable at class level
- @ComponentScan({"com.example"}) :: to add to configuration file for autowiring. The arguments are an array of package structures that need to be scanned for beans to autowire
- @Column(name = "ADR_ID") :: map member field to the column in the database
- @Configuration :: to define configuration *class*
- @Document :: annotation used for the same purpose as @Entity annotation in JPA
- @Entity(name = "sessions") ::
  + Entities in JPA are nothing but POJOs representing data that can be persisted in the database
  + @Entity, at class level, link to database table (entity sessions in this case)
  + must ensure that the entity has a no-arg constructor and a primary key (helps in serialization/deserialization happening when plugging controllers to marshal data into/out of JSON)
  + if you have to serialize an entity with the @Entity annotation in JSON String format using Jackson library (directly or indirectly), the JPA entity will be serialized with all the fields, and ==hibernateLazyInitializer== and ==handler== as extra fields. So, if not ignored, these fields will be serialized in JSON format. To avoid this unnecessary serialization, you have to annotate with ~@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})~ on JPA/Hibernate entity, which will tell Jackson library that "Serialized JSON should not have these fields:
    #+begin_src java
    @Entity(name = "sessions")
    @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
    public class Session {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long session_id;
        private String session_name;
        private String session_description;
        private Integer session_length;

        @ManyToMany
                @JoinTable( name = "session_speakers",
                        joinColumns = @JoinColumn(name = "session_id"),
                        inverseJoinColumns = @JoinColumn(name = "speaker_id")
                )
        List<Speaker> speakers;

        //...
        }
    #+end_src
- @GeneratedValue(strategy = GenerationType.IDENTITY) :: to generate unique id (very often used in combination with ==@Id== annotation)
- @Lob :: to define annotation for a large object type (binary file for eg)
  + ~@Type(type = "org.hibernate.type.BinaryType")~ (or ~@JdbcType(VarbinaryJdbcType.class)~ for hibernate 6+) :: is also used in combination with lob to get spring JPA to stream the binary data into a field
    - without it, might get an exception when JPA queries the data and tries to push it into the 
    #+begin_src java
    @Lob
    @Type(type = "org.hibernate.type.BinaryType")// or @JdbcType(VarbinaryJdbcType.class) or @JdbcTypeCode(Types.VARBINARY) for hibernate 6+, 
    private byte[] speaker_photo;
    #+end_src
  + need property in application properties file, for JDBC driver of local database to be able to create a lob properly on the java side :: ~spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true~
- @RequestBody :: maps the HttpRequest body to a transfer or domain object, enabling automatic deserialization of the inbound HttpRequest body onto a Java object
- @SpringBootTest :: creates an application context to be used in a test
**** Spring MVC
[2023-12-14 Thu 11:56]
- Controllers ::
  + @Controller, @RestController :: both to annotate spring controllers, latter introduced to simplify the creation of RESTful web services and is a convenient annotation that combines @Controller and @ResponseBody (with '@RestController', no need to annotate every request handling method of the controller class with @ResponseBody, that usually tells a controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object)
  + @GetMapping, @PostMapping :: annotation for mapping HTTP GET/POST requests onto specific handler methods
  + @Pathvariable :: to handle template variables in the request URI mapping, and set them as method parameters (will extract the templated part of the URI, represented by the variable in braces, eg: {id})
  + @RequestBody :: maps the HttpRequest body to a transfer or domain object, enabling automatic deserialization of the inbound HttpRequest body onto a Java object: takes all attributes in JSON payload and marshal them in an object
  + @RequestMapping :: used to map web requests to Spring Controller methods
    - options ::
      + @RequestMapping(value = "{id}", method = RequestMethod.DELETE) :: request mapping to specify an id, and the http verb DELETE presented with this API endpoint, HTTP DELETE request method deletes the specified resource, but still need to do it in the persistence
  + @ResponseStatus :: by default, return type of request is always 200s, even as response status for creation calls (which should return status 201) => need to override and send custom status with @ResponseStatus, eg: ~@ResponseStatus(HttpStatus.CREATED)~
  + Notes ::
    + when controllers return a list of objects, the list is passed over to jackson, which is a serialization library which turns object into JSON and return them back to the caller
  + eg ::
    #+begin_src java
    package com.myapplications.conferencedemo.controllers;

    import com.myapplications.conferencedemo.models.Session;
    import com.myapplications.conferencedemo.repositories.SessionRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.*;

    import java.util.List;

    @RestController
    @RequestMapping("/api/v1/sessions")
    public class SessionsController {

        @Autowired
        private SessionRepository sessionRepository;

        @GetMapping
        public List<Session> list() {
            return sessionRepository.findAll();
        }

        @GetMapping
        @RequestMapping("{id}")
        public Session get(@PathVariable Long id) {
            return sessionRepository.getReferenceById(id);
        }

        @PostMapping
        @ResponseStatus(HttpStatus.CREATED) // return status 201
        public Session create(@RequestBody final Session session) {
            return sessionRepository.saveAndFlush(session); // save alone doesn't commit until flushed
        }

        // could also do: ~@RequestMapping(value = "{id}", method = RequestMethod.DELETE)~, but better composed all in one solution:
        @DeleteMapping("{id}")
        public void delete(@PathVariable Long id) {
            // also need to check for children records before deleting, cascading
            sessionRepository.deleteById(id);
            }

        @RequestMapping(value = "{id}", method = RequestMethod.PUT)
        public Session update(@PathVariable Long id, @RequestBody Session session) {
            // it's a put, so expecting ALL attributes to be passed in, and ALL will be updated. Patch is the one that edits part of the elements
            // TODO add validation that all attributes are passed in, otherwise return status 400 bad payload
            Session existingSession = sessionRepository.getReferenceById(id);
            BeanUtils.copyProperties(session, existingSession, "session_id"); // 3rd argument is to ignore property "session_id" when copying, otherwise id will be updated with null
            return sessionRepository.saveAndFlush(existingSession);
            }
    }
    #+end_src  
- Dto :: for "Data Transfer Object", carries data between processes to facilitate communication between two systems (like an API and a server) without potentially exposing sensitive information
  + source :: https://www.baeldung.com/java-dto-pattern
  + context :: OOP environments rely on "calls.", each one a bit like a data lookup, thus requiring both time and processing speed. If programmer not careful, calls can also expose sensitive data, eg :: employee addresses, account numbers, social security numbers, etc.
    - a Dto can help send only the required information, not everything in the database
    - Dtos are objects that carry data between processes in order to reduce the number of methods calls
    - purpose is to reduce roundtrips to the server by batching up multiple parameters in a single call => reduces the network overhead in such remote operations
    - other benefit is the encapsulation of the serialization's logic
      + serialization :: mechanism that translates the object structure and data to a specific format that can be stored and transferred
    - DTO should just contain data, not business logic
    - how to use Dtos ::
      + DTOs normally are created as POJOs (Plain Old Java Objects)
        - only contain storage, accessors and eventually methods related to serialization or parsing
        - data is mapped from the domain models to the DTOs, normally through a mapper component in the presentation or facade layer
          + front (html, json, etc.) exchange with presentation layer ::
            - presentation layer ::
              + Dto only point communicating with front
              + to request data, Dto goes through *only* the mapper and gathers only the data required for the front
              + Dto can gather content of different models, eg :: Dto (userName, roleName), combines data from two models: User, and Role
- BindingResult :: general interface that represents binding results, extends the interface for error registration capabilities, allowing for a Validator to be applied, and adds binding-specific analysis and model building 

**** Some interfaces and classes (with some methods)
[2023-12-13 Wed 14:28]
- JpaRepository<T,U> :: eg: ~public interface SessionRepository extends JpaRepository<Session, Long>~; findAll, getById, getReferenceById (returns a reference to the entity with the given identifier), etc.: T: template type, U: type of unique identifier (int, double, Long, etc.)
-  :: 

*** xml configuration
- Notes ::
  + why still use xml :: first method available in spring, some things still easier with xml, better separation of concerns (for eg when configuration code is moved in a separate file)
  + applicationContext.xml :: root of an application configured for spring using xml
    - name doesn't matter :: configuration file doesn't have to be named applicationContext.xml, it's just how it's usually done
      + by default though, without an extra configuration, spring will look for a file named applicationContext.xml
    - should be placed in default "resources" folder :: ==src/main/resources/applicationContext.xml==
    - same as java configuration ::
      + spring context is a sort of HashMap of objects (spring defines the hash map inside applicationContext.xml, or AppConfig.java for java configuration. The hash map is a name-value pairing)
      + application context can simply be a registry (can lookup beans out of defined context)
    - exists defined namespaces :: dictionary for the properties to aid in creating configuration/validation for beans inside an application, eg: ~<beans>, <beans/property>, <beans/util>~, etc.
- applicationContext.xml in details ::
  + xml application context snippet ::
    - basic ::
      #+begin_src xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:context="http://www.springframework.org/schema/context"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
                              http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/context
                              http://www.springframework.org/schema/context/spring-context.xsd">

      </beans>
      #+end_src
    - with more elements ::
      #+begin_src xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:context="http://www.springframework.org/schema/context"
             xmlns:p="http://www.springframework.org/schema/p"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
                              http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
                              http://www.springframework.org/schema/context
                              http://www.springframework.org/schema/context/spring-context-3.1.xsd">

          <context:property-placeholder properties-ref="deployProperties"/>

          <!-- Activates various annotations to be detected in bean classes -->
          <context:annotation-config/>

          <!-- Imports logging configuration -->
          <import resource="trace-context.xml"/>

          <!-- Imports Spring Data & MongoDB configuration -->
          <import resource="spring-data.xml" />

          <!-- Imports SpringMVC configuration -->
          <import resource="mvc-dispatcher-servlet.xml" />

          <bean id="deployProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"
                p:location="/WEB-INF/spring.properties"/>

      </beans>
      #+end_src
  + to optimize IoC when using beans, it's better to :: define class and use interface, eg:
    - careful on how you name your setter methods, it has an impact on how it's referenced from the application context file
    #+begin_src xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans.xsd">
      <bean
          name="customerRepository"
          class="com.example.repository.CustomerRepositoryImpl" /> <!-- attribute class to define class to use -->

      <bean
          name="customerService"
          class="com.example.service.CustomerServiceImpl"> <!-- define class -->
           <!-- 'name' for the name of the setter to use -->
           <!-- 'ref' to refer to the customerRepository bean, but there is also other attributes such as 'value' to directly put a value in the bean -->
          <property name="customerRepository" ref="customerRepository" /> <!-- will call setter setCustomerRepository in CustomerService -->
          <!-- CAREFUL: if for any reason one wants to change the name of the setter to for example setRepository, 'name' needs to take the value name="repository" -->
      </bean>
    </beans>
    #+end_src
  + using xml application context :: similar to using java configuration, but with ==ClassPathXmlApplicationContext== in place of AnnotationConfigApplicationContext, with the name of the application file as argument (since app context file is in the 'resources' folder, no need to give the whole path)
    #+begin_src java
    public class Application {
    public static void main(String args[]) {

        ApplicationContext appContext = new ClassPathXmlApplicationContext("applicationContext.xml");

        CustomerService customerService = appContext.getBean("customerService", CustomerService.class); // the xml setters injection will also instantiate the customerRepository bean
        // no need to change anything when using constructor injection since everything is done in the service and repository classes, and some fix in the config class

        }
    }
    #+end_src
  + Autowiring :: for spring to autowire beans and reduce the configuration steps
    - 4 types possible to autowire beans ::
      + byType :: allows autowiring *if exactly one bean* of the property type exists in the container, eg: if have 2 two 'Car' objects exist in the container with different names, then fatal exception
      + byName :: can choose by the name of the object that is to be wired
      + constructor :: similar to byType, but applies to constructor arguments
      + 'no' :: for no autowiring, is specified to no, then it won't be autowired at all
    - eg :: byType, byName
      #+begin_src xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
                              http://www.springframework.org/schema/beans/spring-beans.xsd">
        <bean
            name="customerRepository"
            class="com.example.repository.CustomerRepositoryImpl" />

        <bean
            name="customerService"
            class="com.example.service.CustomerServiceImpl"
            autowire="byName">
            <!-- no call to constructor (with constructor-arg neither with autowire="constructor")  -->
            <!-- byType will bean customerService, and inject customerRepository bean too -->
            <!-- byName: since we're referring to customerService, and there exists a bean name customerRepository, the autowiring will use the setter injection setCustomerRepository in CustomerServiceImpl -->
            <!-- works similarly to using verbose definition with property: <property name="customerRepository" ref="customerRepository" />:
                 'name' for the name of the setter to use
                 'ref' to refer to the customerRepository bean
                 + if no setter 'setCustomerRepository' (since repository bean name is customerRepository) exists, then it will fail: runtime exception 'NullPointerException' because it can't autowire the bean correctly
                 + but will succeed if byType because it won't lookup the name, but the class type, and will find it (CustomerRepositoryImpl)
             -->
        </bean>
      </beans>

      #+end_src

  + use setter injection and constructor injection together :: (setter injection is better for existing code though)
    - constructor injection is index based :: (whereas setter injection is name based) ~<constructor-arg index="0" >~ (0 based constructor for 1 arg constructor), eg:
      + java class definition with constructors ::
        #+begin_src java
        public class CustomerServiceImpl implements CustomerService {

            private CustomerRepository customerRepository;

            // no args constructor
            public CustomerServiceImpl() {
                // ...
            }

            // one arg constructor
            public CustomerServiceImpl(CustomerRepository repo) {
                this.customerRepository = repo;
            }
            
            // other methods and constructors: ...

            public void setRepository(CustomerRepository repo) {
                this.customerRepository = repo;
                }
            }
        #+end_src
      + application context file ::
        #+begin_src xml
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans
                                http://www.springframework.org/schema/beans/spring-beans.xsd">
          <bean
              name="customerRepository"
              class="com.example.repository.CustomerRepositoryImpl" />

          <bean
              name="customerService"
              class="com.example.service.CustomerServiceImpl">
              <constructor-arg index="0" ref="customerRepository" /> <!-- call to one argument constructor -->
              <!-- same can be achieved by autowiring, with autowire="constructor" and of course delete/comment constructor-arg above -->
          </bean>
        </beans>
        #+end_src
      
  + when compiled :: applicationContext.xml is copied to the folder for build files (build java files goes to folder 'target/classes' or 'build/classes', the classpath), ie. target/classes/applicationContext.xml

*** Advanced bean configuration
**** Bean Processors ("init method")
- steps :: instantiation -> Populate properties (read from property files, injected from other resources, etc.) -> BeanNameAware (framework sets the bean name and make it aware to other resources, and then can set that as a BeanFactoryAware context) -> BeanFactoryAware -> Pre-initialization using BeanPostProcessors (from there, one can intialize the bean utilizing properties that were just set and then can call an init method InitializeBean) -> InitializeBean -> initMethod -> Post-Initialization - BeanPostProcessors
- adding init method :: post construct, pre destruct, etc.
  + import dependency to pom :: annotation needed for post contruct API calls
    #+begin_src xml
      <dependencies>
        <dependency>
          <groupId>javax.annotation</groupId> <!-- org.springframework.boot for springboot -->
          <artifactId>javax.annotation-api</artifactId>
          <version>1.3.2</version> <!-- check on maven/spring website needed version -->
        </dependency>
      </dependencies>
    #+end_src
  + eg :: use of post construct, will always run after constructor, can be handy for logging or any further configurations instructions needed after constructing object
    - don't put things that do not belong in post construct, eg: open/close database connection; let this be handled by spring, not by the dev
    #+begin_src java
    public class CustomerServiceImpl implements CustomerService {

        private CustomerRepository customerRepository;

        public CustomerServiceImpl() {
            // ...
            }

        @PostConstruct // 
        private void initialize() {
            // ...
            // This part will run after the constructor
            }

        }
    #+end_src

**** FactoryBean (to construct object by building over existing ones)
[2023-12-11 Mon 18:26]
- Notes ::
  + needed to wrap some object construction into further directives for our bean creation
  + factorybean configurations are similar to the init methods, it builds on the factory method design pattern, and its functionality is built to work the same way (code doesn't need to be written as a factory to be used in spring as a factory)
  + great way to integrate legacy code in the application by enforcing a contract in how the code is configured without creating a specific constructor for it: with legacy code one doesn't have the ability to modify constructors due to existing commitments
    - using the pattern enables to establish a contract without modifying the legacy code
  + need to implement FactoryBean: ~implements FactoryBean<T>~, and methods to implement ~getObject, getObjectType~
  + handy to work with static methods inside of a class
- steps :: implement FactoryBean class and methods, add up methods to factory wrapped bean to adapt to new requirements (take static instance and add functionalities around it to be used in the rest of the application)
- eg ::
  #+begin_src java
  package com.example.util;

  public class CalendarFactory implements FactoryBean<Calendar> {

      private Calendar instance = Calendar.getInstance(); // returns static instance Calendar.getInstance() (instead of 'new')

      @Override
      public Calendar getObject() throws Exception {
          return instance;
          }

      @Override
      public Calendar<?> getObjectType() {
          return Calendar.class;
          }

      // add some values to the factory wrapped bean static instance, examples:
      public void addDays(int num) {
          instance.add(Calendar.DAY_OF_YEAR, num);
          }
      }

  // in AppConfig (with java configuration)
  @Configuration
  @ComponentScan({"com.example"})
  public class AppConfig {

      // define 2 beans: the FactoryBean implementation, and 
      @Bean(name = "cal")
      public CalendarFactory calFactory() {
          CalendarFactory factory = new CalendarFactory();
          factory.addDays(2);
          return factory;
      }
      @Bean
      public Calendar cal() throws Exception {
          return calFactory().getObject(); // calls the factoryBean implementation method above
      }
  }

  // and to autowire the bean somewhere:
  @Repository("customerRepository")
  public class HibernateCustomerRepositoryImpl implements CustomerRepository {

      // autowire the new defined bean:
      @Autowire
      private Calendar cal;

      // constructors, methods, and others ...

      public List<Customer> findAll() {
          List<Customer> customers = new ArrayList<~>();

          // ...

          System.out.println("cal: " + cal.getTime()); // the object cal will actually be called from the implementation of FactoryBean, not the Calendar per se. Before the FactoryBean addition, there was no way to reference a calendar object and pass it in this way
          }
  }

  #+end_src

**** SpEL (Spring Expression Language)
[2023-12-11 Mon 18:26]
- with SpEL ::
  + can manipulate object graph :: means once the object is created, one can use the expression language to manipulate that object
  + can evaluate values at runtime :: (and change behavior of code accordingly)
  + can evaluate and manipulate configurations ::
- eg ::
  #+begin_src java
  // model
  public class Customer {
      private String firstName;
      private String lastName;
      private double seedNum;

      // constructors, getters, setters, other methods ...

      public void getSeedNum() {
          return seedNum;
          }
      public void setSeedNum(double seedNum) {
          this.seedNum = seedNum;
          }
      }

  // repository
  @Repository("customerRepository")
  public class HibernateCustomerRepositoryImpl implements CustomerRepository {

      // autowire the new defined bean:
      @Autowire
      private Calendar cal;

      // use spring expression language to grab value out of java.lang.Math library:
      @Value("#{ T(java.lang.Math).random() * 100 }") // ==(java.lang.Math)==: grabs Math object, random returns 0 to 1
      private double seedNum; // initialized with SpEL, and now available at runtime to pass it to the setter in Customer model for example

      // constructors, methods, and others ...

      public List<Customer> findAll() {
          List<Customer> customers = new ArrayList<~>();

          // ...
          Customer customer = new Customer();

          customer.setFirstName("Bryan");
          customer.setLastName("Hansen");
          customer.setSeedNum(seedNum);

          customers.add(customer);

          // ...

          return customers;
          }
  #+end_src

**** Proxies (AOP proxies)
[2023-12-11 Mon 18:27]
- Notes ::
  + Proxies are a great way to inject behavior into code without modifying the underlying code
  + useful when doing framework or library based work, or when dealing with databases and the annotation @Transactional
- eg ::
  + SimplePojo is the class that we want to proxy to
  + Pojo is the interface that one will make calls on through the proxy and allows the calls to be intercepted
  #+begin_src java
  ProxyFactory factory = new Proxyfactory(new SimplePojo());

  factory.addInterface(Pojo.class);
  factory.addAdvice(new RetryAdvice());
  factory.setExposeProxy(true);

  Pojo pojo = (Pojo) factory.getProxy();

  // method call on the proxy!:
  pojo.foo();
  #+end_src

**** Bean Profiles (good to adapt environments)
[2023-12-11 Mon 18:27]
- Notes ::
  + Bean Profiles good to ::
    - adapt to environments :: allow to set up specific code that gets ran only in specific environment, so one can swap out configurations at runtime for example
    - do runtime configuration :: do not overdo it though, use them with moderation and try to develop code that don't change with environment, unless really needed
- eg ::
  #+begin_src java
  // define a profile using @Profile
  @Repository("customerRepository")
  @Profile("dev") // set a profile to use (not predefined)
  public class HibernateCustomerRepositoryImpl implements CustomerRepository {

      @Autowire
      private Calendar cal;

      @Value("#{ T(java.lang.Math).random() * 100 }") // check out SpEL section
      private double seedNum;

      // constructors, methods, and others ...

      public List<Customer> findAll() {
          List<Customer> customers = new ArrayList<~>();

          // ...
          return customers;
          }
      }

  // same
  @Repository("customerService")
  @Profile("dev")
  public class CustomerServiceImpl implements CustomerService {

        // ...
    }

  // go into your IDE run application configuration (in intelliJ: 'Edit configurations'), and use profile option to use (VM options): ~-Dspring.profiles.active=dev~
  #+end_src


** Builds and dependencies
[2023-12-09 Sat 18:38]
*** maven
- pom.xml (Project Object Model) :: fundamental unit of work in Maven. It is an XML file that contains information about the project and configuration details used by Maven to build the project. Contains default values for most projects
  + location :: at same level as 'src' folder (as high as possible)
  + requires ::
    - plugin to use and build version for the application :: below ==<version>==: ==<build/plugins/plugins/version>==
      #+begin_src xml
      <groupId>org.apache.maven.plugins</groupId>
      <groupId>pluralsight</groupId>
      <artifactId>refactoring-solid-java17</artifactId>
      <version>1.0</version>
      #+end_src
  + Notes ::
    - intellij will not tell you (other IDEs do) the source-target of java version to be used with maven, so sometimes you will need to configure the java version source and target (under ==<build/plugins/plugins/configuration>==), eg here for java 11:
      #+begin_src xml
      <configuration>
        <source>11</source> <!-- compiling java version -->
        <target>11</target> <!-- java running target version -->
      </configuration>
      #+end_src
    - maven compiler != java compiler
      
*** gradle
[2023-12-13 Wed 14:28]

** Spring boot
*** Basics
[2023-12-09 Sat 23:12]
- spring boot ::
  + easier for example to wire spring MVC (model-view-controller) to a persistence framework
  + rapid development: quick like ruby on rails, django, and python
  + takes *opinionated* view on how spring app should be constructed, which makes the app fast, but at the expense of control sometimes
  + moved away from container dependence, and made applications to be standalone java apps :: which can be handy for example for cloud development: instead of deploying war files to tomcat containers for example, spring boot embeds tomcat inside of the app and produces a self contained jar files that can be run on their own using java command
  + spring initializer :: https://start.spring.io/
- @SprintBootApplication :: annotation to set entry point (main) as a spring boot application
- spring boot and maven (pom.xml) ::
  + versions used by spring bootfor dependencies in the pom.xml are based on spring-boot-starter-parent versions in pom.xml :: project/parent/version:
    #+begin_src xml
    <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>3.2.0</version>
      <relativePath/>
    </parent>
    #+end_src
    - from intelliJ, to display versions integrated (BOM: bill of materials) with current version of spring-boot-starter-parent :: right click in pom.xml-> sub-section 'Maven' -> 'Show Effective POM'
    - => with spring boot no longer have to worry about versions compatibilities
- *.properties files :: (application.properties, and test.properties)
  + for different properties configurations, such as db connections, url, etc.
  + location :: in respective 'resources' folders ==src/main/resources== and ==src/test/resources==
  + property files' definitions for when more details needed :: https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html
    - some examples ::
      + spring.jpa.show-sql :: to enable logging of SQL statements
      + spring.datasource.url :: JDBC URL of the database (for connections)
      + spring.jpa.hibernate.ddl-auto :: DDL mode, actually a shortcut for the "hibernate.hbm2ddl.auto" property, defaults to "create-drop" when using an embedded database and no schema manager was detected, otherwise, defaults to "none"
- Notes ::
  + spring boot cli :: check out details: https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#cli
  + spring boot starter :: really nice to integrate dependencies (and sub-dependencies) and versions on a project and get it all set in one go
*** Persistence and spring boot
[2023-12-12 Tue 17:39]
**** modeling database relations with spring
- many to many bidirectional ::
  + use of list, need to select owner of the bidirectional database relationship (in java, since a many-to-many relationship doesn’t really have an owner side in the database,), to set join tables configurations, and the configuration on the receiving end)
  + use spring annotations to refer to defined mapping Join table in the persistence (@JoinTable)
     #+begin_src java
    // class Session
     @ManyToMany
     @JoinTable(name = "session_speakers",
                 joinColumns = @JoinColumn(name = "session_id"),
                 inverseJoinColumns = @JoinColumn(name = "speaker_id")
                 )
     List<Speaker> speakers;
     #+end_src
  + to specify the other side of the many to many relation, on the target side, we only have to provide the name of the field, which maps the relationship (the list 'speakers' in the above session definition) => careful on the naming and not messing up the spring persistency registry
    #+begin_src java
    // class Speaker
    @ManyToMany(mappedBy = "speakers")
    private List<Session> sessions;
    #+end_src
  + avoid back serialization :: if not taken care of, when there are linked entities/tables in the database, spring could fetch all the database from one entry point, sometimes even on a cyclical manner. Then, there might be a rendering issue with too much data to display. In that case:
    - either use Dtos,
    - or use further annotations so that Jackson can filter out not needed data
      + eg: in the previous example, Session is the owner entity of the bidirectional relationship, so speaker needs to prevent back serialization to the session entity with the ==@JsonIgnore== :
        #+begin_src java
        // class Speaker
        @ManyToMany(mappedBy = "speakers")
        @JsonIgnore
        private List<Session> sessions;
        #+end_src
*** Customize and override springboot
[2023-12-14 Thu 16:55]
- Notes ::
  + there is an order of precedence that spring and spring boot use to set values ::
    1. using external sources :: cli parameters; JNDI (Java Naming and Directory Interface, a Java API for a directory service that allows Java software clients to discover and look up data and resources via a name); OS environment variables
    2. using internal sources :: servlet (small Java program that runs within a Web server, that receive and respond to requests from Web clients, usually across HTTP) parameters; property files; java configuration. Keep in mind that internal tools can also point to external sources
  + basic order of preference (excluding test configuration setup) ::
    1. cli args
    2. SPRING_APPLICATION_JSON args
    3. Servlet parameters
    4. JNDI
    5. Java system properties
    6. OS environment variables
    7. Profile properties
    8. Application properties
    9. @PropertySource annotations
    10. Default properties
  + rule of thumb ::
    - pick *one internal source* (like properties files) to setup the application defaults;
    - and then pick one external source to provide overrides
    - pros :: this restrains the configurations to one or two places, allows for sensible defaults, and gives the ability to use external sources for sensitive data like credentials and passwords, eg: OS environment variables as external source, and application property files as internal source
      + note and reminder :: application property files are usually in ==src/main/resources==
**** Updating application properties
[2023-12-14 Thu 18:40]
- properties in application.properties are actual overrides of spring boot default properties :: others properties can be found in https://docs.spring.io/spring-boot/docs/1.1.6.RELEASE/reference/html/common-application-properties.html (all sets to defaults values. If url changes, just search for "spring common application properties" and make sure you select the page with 'common')
- updating application properties with internal configuration :: 
  + eg :: ==spring.datasource.url== is set to null, and is coming from 'DataSourceProperties' and 'DataSourceAutoConfiguration' (grouped into DATASOURCE) that spring boot provides in the 'spring data jpa starter'
    - to change for example the port Tomcat is running on (instead of default 8080) :: set ~server.port=5000~ in the application.properties file
- updating application properties with external configuration ::
  + use case eg :: database connection configs are hard coded in application.properties, which is in clear to anyone
    - move secrets to external resources and setup environment variables ::
      + add environment variables to intelliJ :: Run -> Edit configurations -> Application -> YourApplication -> Environment Variables : and add your custom environment variables. In the properties file, you just need to update the values with the content of the environment variables :
      #+begin_example
      // application.properties
      spring.datasource.url=${DB_URL}
      spring.datasource.username=${DB_USER}
      spring.datasource.password=${DB_USER_PSWRD}
      #+end_example
**** Handling different environments
+ aim :: working on an app development locally, and be able to deploy on test server, staging, and production
+ environmental configurations :: create application-{profile}.properties for needed profile of target environment, eg: application-dev.properties, application-prod.properties
  - to specify the profile, need to add it into options parameters at application startup, eg: ~-Dspring.profiles.active=dev~
    + adding needed profile on intelliJ run profile: Run -> Edit configurations -> Application -> VM options; and add targethed option
  - with suffix for targeted deployment environment, spring will use those properties on appropriate environment, instead of the default application.properties file
  - eg of prod application profile ::
    #+begin_example
    # in prod environment, keep logging to errors and warnings, not infos or debug for eg
    # some INFO will still show since the logging level is only set on 'org' package level: logging.level.[ORG*]
    logging.level.org=WARN

    // ...
    #+end_example

**** Settings properties with YAML
[2023-12-15 Fri 09:00]
- similar to usual properties files, need to live on class path, need to be named application.yml
- with spring boot it's possible to mix and match properties and YAML file types
- but better to select one format for properties and stick to it
- for environment configurations (same as application-{profile}.properties), it's possible to set yaml properties with respect to the target environment: application-dev.yml, application-prod.yml, etc.
- eg: move some database settings from application.properties to application.yml file
  #+begin_src yaml
  # file src/main/resources/application.yml
  # yaml format of ~server.port=5000~
  server:
    port: 5000
  #+end_src
*** Setting and using custom application property value inside the java application
[2023-12-15 Fri 09:45]
- inject custom property in application property file :: suppose property ==app.version== set in application.properties:
  #+begin_src example
  # this application version, nothing to do with spring or java
  app.version = 1.0.0
  #+end_src
- controller fetching value from the application.properties ::
  #+begin_src java
  @RestController  
  public class HomeController {

      @Value("${app.version}")
      private String appVersion;
      @GetMapping
      @RequestMapping("/")
      public Map getStatus() {
          return new HashMap<String, String>() {{ put("app-version", appVersion);}};
      }
  }
  #+end_src
- result ::
  #+begin_src js
  {
      "app-version": "1.0.0"
  }
  #+end_src
*** Overriding spring boot with java configurations
[2023-12-15 Fri 11:13]
- create new package ==config== :: (src/main/java/com.example.config), and put java configuration files in there
- use @Configuration :: to tell spring that java class is a configuration class (see further java configurations in [[#JavaConfigs][Java configurations]])
- eg: override with java configs the application property for data sources properties provided by spring data jpa starter ::
  #+begin_src java
  @Configuration
  public class PersistenceConfiguration {
      @Bean
      public DataSource dataSource() {
          DataSourceBuilder builder = DataSourceBuilder.create();
          builder.url("jdbc:postgresql://localhost:5432/conference_scheduling_db");
          return builder.build();// build the datasource before returning
          // since defined with @Bean, spring will look for the bean in the spring context, and replace the previous data source definition (if exists) with the new that was just implemented
      }
  }
  #+end_src
- process ::
  1. when object DataSource is returned by the method, spring tries to check if one doesn't already exist in the spring context
  2. if it does, it will the replace it with the one defined in the java configuration
- pros of using java configuration of application properties ::
  + when further complex need to be done in addition to setting the property, eg: logging when db connection is made (add logging in configuration method), or do other custom instructions (for example, send an email when a transaction is committed, or setup a two-phase transactions, or set transactions between nosql and sql databases, etc.), can add as many layer of instructions as you want
*** Auto-configuration classes
[2023-12-15 Fri 12:42]
- java configuration files can be helpful for creating and using libraties, helpers and utils classes that will be used by other applications ::
  + How to create auto-configurations ::
    1. create classes and annotate them with @Configuration, and add methods to define beans and functionality that needs to be provided to spring boot starter
    2. add declaration to spring.factories (src/main/resources/META-INF/spring.factories), to indicate that you're registering an auto-configuration
       + spring.factories files :: are usually kept in folder resources/META-INF
         #+begin_src example
         // ...
         org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.example.config.MyAutoConfiguration
         // MyAutoConfiguration is a class file MyAutoConfiguration.java. Above is just its qualified name
         // ...
         #+end_src
       + MyAutoConfiguration.java ::
         #+begin_src java
         @Configuration
         public class MyAutoConfiguration {
             @Bean
             public SomeObject aMethod() {
                 // ...
             }
         }
         #+end_src
       + process :: spring boot will inspect jar files on the classpath for the spring.factories file, and then bootstrap the auto-configuration files
- other annotations that spring boot provides that allow setting specific conditions on the auto-configuration ::
  + @ConditionalOnClass :: loads a specific bean under condition, loads only if the jar providing this class is included in the classpath
    - eg: you're building an auto-configuration that is dependent on a postgres jdbc driver. You can specify that at the class level it's conditional on the driver being present. If it is, the auto-configuration will automatically wire up, otherwise it does nothing
  + others :: @ConditionalOnMissingClass, @ConditionalOnBean, @ConditionalOnMissingBean, @ConditionalOnProperty, @ConditionalOnResource, etc.

*** Deploying spring boot applications
[2023-12-15 Fri 13:39]
**** Configs
- Notes ::
  + things to take into consideration when deploying or preparing to deploy a java application ::
    - deploy on cloud environment, on rack servers ?
    - should the app be an executable .jar, or .war ?
    - etc.
- process ::
  + old way of deploying java app :: create war files, and install them on: tomcat, glassfish, or websphere (good old times containers complying with JEE specs)
  + now :: with spring boot, apps are standalone, no need to install them on containers, spring has embedded container inside of the framework => can run java app in standalone mode
    - default container embedded in spring boot :: tomcat, but possible to switch to others such as jetty, or undertow
- switch embedded spring boot container ::
  1. in pom.xml :: find dependency ~spring-boot-starter-web~ which contains embedded tomcat container
  2. switch out tomcat from starter web ::
     #+begin_src xml
     <dependencies>
       <dependency>
         <!-- ... -->
         <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-web</artifactId>
           <exclusions>
             <!-- exclude tomcat dependency from starter web -->
             <exclusion>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-tomcat</artifactId>
             </exclusion>
           </exclusions>
         </dependency>
         <dependency>
           <!-- add jetty container dependency -->
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-jetty</artifactId>
         </dependency>
         <!-- ... -->
     <dependencies>
     #+end_src

**** Creating executables jar
[2023-12-15 Fri 16:11]
***** Deploying for non cloud based environments
[2023-12-15 Fri 22:47]
- 2 ways to create jar files that can be used to run the app ::
  1. use maven to create jar files that can be run with the java command:
     - in intelliJ :: 'Maven' tool box -> 'Execute Maven Goal' ('m' logo, or play symbol in a box logo)
       + maven goal needed :: 'mvn package'
       + out .jar location :: src/target/[your_app_name]-[app_version]-SNAPSHOT.jar
     - to run application in .jar format ::
       1. check that app is not already running
       2. in a terminal: run ==java -jar [your_app_jar].jar==
          - on windows :: to set environment variables, it can differ with respect to which cli you're using (cmd vs powershell). For powershell could set the environment variables by doing:
            #+begin_src powershell
            $Env:DB_URL='jdbc:postgresql://localhost:5432/conference_scheduling_db
            $Env:DB_USER=postgres
            $Env:DB_USER_PSWRD='Admin123456'
            #+end_src
  2. create standalone executable .jar file:
     + configuration ::
       1. slightly tune maven ::
          - in pom.xml ::
            - find spring boot *plugin* (in build part area), and add ==executable== tag ::
              #+begin_src xml
              <build>
                <plugins>
                  <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <configuration>
                      <executable>true</executable>
                    </configuration>
                  </plugin>
                </plugins>
              </build>
              #+end_src
       2. reload maven configs
       3. then again (in intellij): 'Maven' -> maven goal -> mvn package
     + to run application ::
       - no need anymore to run .jar executable with -jar option while running the app ::
         + in linux based OS :: ~./[your_app_jar].jar~
         + in windows :: only runs .exe, so, need to do it the old way: ~java -jar [your_app_jar].jar~
***** Running on a cloud platform
- common cloud supported platforms (that work with spring boot) :: Amazon Web Services, Microsoft Azure, Google Cloud, Heroku, Cloud Foundry
  + HOWEVER :: each of these platforms require setting up different configuration files so that the platform knows how to deploy it on its own infrastructure
    - even though the details might differ, the standalone .jar artifact doesn't
  + for flexibility with deployments :: better to dockerize the application for clustering and portability (most cloud platform support docker)
    - can spin up several instances quickly using tools like docker composed or kubernetes
    - *but* :: with cloud offering platform, be aware of differences in:
      + logging :: can be difficult to track down and use depending on the cloud service (could be better to use a centralized logging service)
      + service integration :: for example, connecting to db or other cloud services, like Redis Queue, might require specific handling that can be different what java and spring configurations propose
      + firewall and security :: can be a hurdle to get all services to talk to each other and also uphold security
- eg, deploying spring boot on heroku ::
  + steps ::
    - 'create new app' -> select deployment method (github, container registry, etc.) -> select deployment method and git branch (manual, auto-deploy on, for example, commit or check-in) -> 'deploy branch', and then 'view' or 'open app' when finished building
    - add further services when necessary :: eg, database
      + dashboard -> resources -> select db serice (eg: postgre)
        - to setup db configs :: dashboard -> settings -> 'reveal config vars' and set as did in app (DB_URL, DB_USER, etc.)
          + hardcoding the url with "localhost" (using java configurations) is not the best choice, since localhost doesn't exist on cloud platforms. Thankfully, some cloud platforms have pre-filled fields available for you. Just make sure to use the same environment variable names
            #+begin_src example
            // on application properties for example:
            spring.datasource.url=${DB_URL}
            // on heroku settings 'config vars':
            DB_URL = postgres://some_connection_adress...
            ${DB_URL}
            #+end_src
        - don't forget to load the database on the cloud so that it is available from there
    - to use api, link :: [name-of-app-on-heroku].herokuapp.com (eg: conferencedemo-heroku.herokuapp.com/api/v1/sessions)
  + debugging on heroku :: dashboard -> 'more' -> view logs
***** Deploying .war executables (will prevent deploying .jar files, so need to pick one, can't have both)
[2023-12-17 Sun 02:29]
- .war :: used to distribute a collection of JAR-files, JavaServer Pages, Java Servlets, Java classes, XML files, etc.
- .war needed to be able to support deploying on a container
- if application is maven-based :: so, need some modifications
  + to pom.xml :: in order to package slightly differently, so that it can be deployed on a container (by default spring boot generates .jar fils with embedded container)
    1. flag embedded container as 'provided' :: will tell maven to not package tomcat or other container embedded in final packaged artifact, maven won't package tomcat starter in the build
       #+begin_src xml
       <dependencies>
         <dependency>
           <!-- ... -->
           <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
           <dependency>
             <!-- add tomcat even though alreay embedded, so can specify as 'provided' -->
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-tomcat</artifactId>
             <scope>provided</scope>
           </dependency>
           <!-- ... -->
       <dependencies>

       #+end_src
    2. tell maven to package the app as a .wat, and not a .jar :: with <packaging> tag, still in pom.xml, at the top, after the app description:
       #+begin_src xml
       <parent> 
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-parent</artifactId>
         <version>3.2.0</version>
         <relativePath/> <!-- lookup parent from repository -->
       </parent>
       <groupId>com.myapplications</groupId>
       <artifactId>conference-demo</artifactId>
       <version>0.0.1-SNAPSHOT</version>
       <name>conference-demo</name>
       <description>Conference scheduling app</description>

       <!-- HERE -->
       <packagin>war</packaging>

       <properties>
               <java.version>17</java.version>
       </properties>
       <dependencies>
         <!-- ... -->
       </dependencies>
       #+end_src
    3. edit java main class :: and make it extend ~SpringBootServletInitializer~, that runs a SpringApplication from a traditional .war archive deployed on a web container
       + when deploying .war file to an external container, it expects a context to be available, together with a web.xml file defining how the app will get deployed
         - spring boot apps don't have web.xml files, the class SpringBootServletInitializer will provide those values and other informations to the external container
    4. maven plugin -> mvn package
    5. careful, .war file is missing environment variables values, DB_URL for example -> use external configuration source, or JNDI values so that urls and credentials are not hard coded in the application
- deploy to tomcat container :: copy application .war file into apache tomcat local folder (==webapps== folder)
  + need tomcat context to run .war :: the context for .war files are the name of the target folder where the app was deployed, eg: for toto.war name (apache automatically extract the .war into a folder with the same name without .war extension):
    ~localhost:8080/toto/api/v1/sessions~ (8080 is the default port opened by tomcat)

** Architecture and structure
[2023-12-13 Wed 14:25]

** Tips when using IDE
[2023-12-10 Sun 01:13]
*** General
[2023-12-10 Sun 01:15]
- creating new project :: create new project -> select project sdk -> select maven/gradle (on the left) as dependencies handler
- when creating a new class with missing package structure :: remember to fully qualify the package name, eg: To create first class 'Toto', enter its fully qualified name: ~com.newproject.model.Toto~; same when 'repository' package is missing: ~com.newproject.repository.TotoRepositoryImpl~
- imported libraries and dependencies are to be found in folder :: ==External Libraries==

*** IntelliJ
- create a new interface/superclass/etc. from a class :: right click in class src -> refactor -> extract -> interface
- iml file (*.iml) :: module file created by IntelliJ that stores information about a development module, which may be a Java, Plugin, Android, or Maven component; saves the module paths, dependencies, and other settings. eg:
  #+begin_src xml
  <!-- eg file : 1-srp/checkpoints/checkpoint-1/before/srp-checkpoint-1.iml -->
  <?xml version="1.0" encoding="UTF-8"?>
  <module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule="true" type="JAVA_MODULE" version="4">
    <component name="NewModuleRootManager" LANGUAGE_LEVEL="JDK_17">
      <output url="file://$MODULE_DIR$/target/classes" />
      <output-test url="file://$MODULE_DIR$/target/test-classes" />
      <content url="file://$MODULE_DIR$">
        <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
        <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
        <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
        <excludeFolder url="file://$MODULE_DIR$/target" />
      </content>
      <orderEntry type="inheritedJdk" />
      <orderEntry type="sourceFolder" forTests="false" />
      <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter:5.8.2" level="project" />
      <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter-api:5.8.2" level="project" />
      <orderEntry type="library" scope="TEST" name="Maven: org.opentest4j:opentest4j:1.2.0" level="project" />
      <orderEntry type="library" scope="TEST" name="Maven: org.junit.platform:junit-platform-commons:1.8.2" level="project" />
      <orderEntry type="library" scope="TEST" name="Maven: org.apiguardian:apiguardian-api:1.1.2" level="project" />
      <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter-params:5.8.2" level="project" />
      <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter-engine:5.8.2" level="project" />
      <orderEntry type="library" scope="TEST" name="Maven: org.junit.platform:junit-platform-engine:1.8.2" level="project" />
    </component>
  </module>
  #+end_src
- to avoid conflicting maven artifacts (when installing and publishing), remember, when copying from another project and it has to be renamed, to update *.iml name file and pom.xml/artifactId
- import generated spring boot zip file :: extract it and import it ->
  Files -> New -> 'Project from existing sources'
- first run :: might ask for classpath module and JRE
- generate getters/setters/toString/etc. :: right click -> generate -> needed method

** Notes
- jar :: Java ARchive, file format based on ZIP file format and used for aggregating many files into one, ready to use by jdk/other applications
  + can use jars for libraries, utils, and helper classes
- SDK :: Software development kit
- Tomcat :: is not an application server, but a web server, lightweight an easy to use
* Gradle
[2024-02-19 Mon 17:11]
** standalone gradle
[2024-02-21 Wed 22:48]
*** Notes
- gradle comes with a built-in task, called ==init==, that initializes a new Gradle project (~gradle init~). The ==init== task uses the (also built-in) wrapper task to create a Gradle wrapper script, ==gradlew==.
- ~gradle init~ prompts various options to select: the type of project to generate (basic, application, library, etc.), the implementation language, the build script DSL (kotlin, or groovy), and the test framework.
*** Basics
[2024-02-25 Sun 01:52]
- gradle uses two main directories to perform and manage its work: the /Gradle User Home directory/ and the /Project Root directory/.
  + gradle user home directory ::
    - by default, the Gradle User Home (==~/.gradle== or ==C:\Users\<USERNAME>\.gradle==) stores *global* configuration properties, initialization scripts, caches, and log files. It can be set with the environment variable ==GRADLE_USER_HOME==.
    - roughly structured as follows:
      - caches :: global cache directory (everything that is not project-specific).
        - 4.8 :: version-specific caches (e.g., to support incremental builds).
        - 4.9 :: version-specific caches (e.g., to support incremental builds).
        - and so forth.
        - jars-3 :: shared caches (e.g., for artifacts of dependencies).
        - modules-2 :: shared caches (e.g., for artifacts of dependencies).
      - daemon :: registry and logs of the Gradle Daemon (program that runs as a background process. Gradle runs on the Java Virtual Machine (JVM) and uses several supporting libraries with non-trivial initialization time. Startups can be slow. The Gradle Daemon solves this problem.)
        - other versions
        - 4.8 ::
        - 4.9 ::
      - init.d :: global initialization scripts (scripts that run before the build starts, for example to set up enterprise-wide configuration, such as where to find custom plugins, set up properties based on the current environment, such as a developer’s machine vs. a continuous integration server, define machine-specific details, such as where JDKs are installed, etc.).
        - my-setup.gradle ::
      - jdks :: JDKs downloaded by the toolchain support.
        - other versions
        - jdk-14.0.2+12
      - wrapper ::
        - dists :: distributions downloaded by the Gradle Wrapper.
          - other stuff ::
          - gradle-4.8-bin ::
          - gradle-4.9-all ::
          - gradle-4.9-bin ::
      - gradle.properties :: global Gradle configuration properties (options that make it easy to configure the Java process that will be used to execute the builds.).
  + project root directory :: contains all source files from the project, contains files and directories Gradle generates such as ==.gradle== and ==build==
    - while ==.gradle== is usually checked into source control, the ==build== directory contains the output of builds as well as transient files Gradle uses to support features like incremental builds.
    - the anatomy of a typical project root directory looks as follows:
      - .gradle :: project-specific cache directory generated by Gradle.
        - 4.8 :: version-specific caches (e.g., to support incremental builds).
        - 4.9 :: version-specific caches (e.g., to support incremental builds).
        - etc.
      - build :: the build directory of this project into which Gradle generates all build artifacts.
      - gradle ::
        - wrapper :: contains the JAR file and configuration of the Gradle Wrapper.
      - gradle.properties :: project-specific Gradle configuration properties.
      - gradlew :: scripts for executing builds using the Gradle Wrapper.
      - gradlew.bat :: scripts for executing builds using the Gradle Wrapper.
      - settings.gradle.kts :: the project’s settings file where the list of subprojects is defined.
      - subproject-one :: usually, a project is organized into one or multiple subprojects.
        - build.gradle.kts :: each subproject has its own Gradle build script.
      - subproject-two :: usually, a project is organized into one or multiple subprojects.
        - build.gradle.kts :: each subproject has its own Gradle build script.
      - etc
**** Multi-project build basics
*** Packaging Executable Archives
**** Packaging Executable Jars
- the ==init== task generates the new project with the following structure: (for a java library project called ==demo==)
  - gradle :: generated folder for wrapper files
    - libs.versions.toml :: generated version catalog
    - wrapper
      - gradle-wrapper.jar
      - gradle-wrapper.properties
  - gradlew :: gradle wrapper start scripts
  - gradlew.bat :: gradle wrapper start scripts
  - settings.gradle.kts :: settings file to define build name and subprojects
  - lib
    - build.gradle.kts :: build script of ==lib== project
    - src
      - main
        - java :: default Java source folder
          - demo
            - Library.java
      - test
        - java :: default Java source folder
          - demo
            - LibraryTest.java
- settings.gradle(.kts) ::
  + ex:
    #+begin_src kotlin
    rootProject.name = "demo"
    include("lib")
    #+end_src
  + rootProject.name :: assigns a name to the build, which overrides the default behavior of naming the build after the directory it’s in. It’s recommended to set a fixed name as the folder might change if the project is shared - e.g. as root of a Git repository
  + include("lib") :: defines that the build consists of one subproject called lib that contains the actual code and build logic. More subprojects can be added by additional include(…​) statements.
  + the build contains one subproject called ==lib== that represents the Java library to build. It is configured in ==lib/build.gradle(.kts)==:
    #+begin_src kotlin
    plugins {
        `java-library` // apply the java-library plugin for API and implementation separation
    }
    
    repositories {
        mavenCentral() // use Maven Central for resolving dependencies
    }
    
    dependencies {
        testImplementation(libs.junit.jupiter) // use JUnit Jupiter for testing
    
        testRuntimeOnly("org.junit.platform:junit-platform-launcher")
    
        api(libs.commons.math3) // the dependency is exported to consumers, that is to say found on their compile classpath
    
        implementation(libs.guava) // the dependency is used internally, and not exposed to consumers on their own compile classpath
    }
    
    tasks.named<Test>("test") {
        useJUnitPlatform() // use JUnit Platform for unit tests
    }
    #+end_src
***** Assembling the library Jar
[2024-02-22 Thu 00:06]
- to build the project, one can just run the ==build== task. However, it's considered good form to use the regular gradle command when a project includes a wrapper script: ~./gradlew build~
  + when building for the first time the wrapper script, there may be a delay while that version of gradle is downloaded and stored locally in the ==~/.gradle/wrapper/dists== folder. Plus, gradle will check if the required dependencies are in the cache (under ==~/.gradle directory==). If not, the libraries are downloaded and stored, and the next time the build is run, the cached versions will be used.
  + the ==build== task compiles the classes, runs the tests, and generates a test report. The html test report is located at ==lib/build/reports/tests/test/index.html==.
- the newly packaged JAR file can be located in directory ==lib/build/libs== with the name ==lib.jar==
- can verify the validity of the archive by running the command ~jar tf lib/build/libs/lib.jar~
- manifest file ::
  + among the results generated by ~jar tf~ is the manifest file ==manifest.mf==, in folder ==META-INF==. The manifest file describes Java Archives, and is a list of key-value pairs, called ==headers== or ==attributes==, grouped into sections. These headers supply metadata that help describe aspects of JARs such as the versions of packages, what application class to execute, the classpath, signature material, etc.
  + a manifest file is added automatically whenever a JAR is created.
  + custom manifest ::
    - suppose we create a custom manifest file ==manifest.txt== containing text: ~Built-By: baeldung~. The manifest can be included, and jar will merge it with the default manifest file when using the ==m== option: ~jar cfm MyJar.jar manifest.txt classes/~
  + a manifest can change depending on which tools is used:
    - for example using maven, the headers can be customised using the pom: this example will indicate who created the manifest, and the package:
      #+begin_src xml
      <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-jar-plugin</artifactId>
          <version>3.3.0</version>
          <configuration>
              <archive>
                  <manifest>
                      <packageName>com.baeldung.java</packageName>
                  </manifest>
                  <manifestEntries>
                      <Created-By>baeldung</Created-By>
                  </manifestEntries>
              </archive>
          </configuration>
      </plugin>
      #+end_src
    - and will generate the following manifest:
      #+begin_src example
      Manifest-Version: 1.0
      Build-Jdk-Spec: 11
      Package: com.baeldung.java
      Created-By: baeldung
      #+end_src
  + entry point and classpath ::
    - if a JAR contains a runnable application then we can specify the entry point. Also possible to provide its classpath. By doing so, one avoids having to specify it when running it.
      + Main-Class :: the package and name of the class with a main method
      + Class-Path :: a space separated list of relative paths to libraries or resources
    - so, for example, if an application entry point is in ==Application.class== and it uses libraries and resources, then it's possible to add the needed headers: ~Main-Class: com.baeldung.Application~ and ~Class-Path: core.jar lib/ properties/~
    - the classpath includes ==core.jar== and all the files in the ==lib== and ==properties== directories. These assets are loaded relative to where the JAR is executed and not from within the JAR itself. In other words, they must exist outside the JAR.
***** Customising the library JAR
- notes ::
  + examples ::
    - include your library JAR version: ~version = "0.1.0"~, in file ==build.gradle.kts==
      + other than the versions, the other informations usually required are the name and group.
        - as a result, the JAR file will contain the version (path ==lib/build/libs/lib-0.1.0.jar==)
        - the name is directly derived from the subproject name that represents the library (==lib== in the example above). In case a different name is needed, then just to change the subproject folder name and the corresponding ==include(...)== statement in file ==settings.gradle(.kts)==
        - the /group/ is used to give the library full coordinates when published. One can then define it directly in the ==build== script by setting the ==group== property similar to how you set the version as shown above.
  + customizing the manifest file :: add one or more attributes to the manifest.
    - configure the ==jar== task in the build script ==build.gradle.kts== ::
      + example, add version and library name to manifest ::
        #+begin_src kotlin
        tasks.jar {
            manifest {
                attributes(mapOf("Implementation-Title" to project.name,
                                 "Implementation-Version" to project.version))
            }
        }
        #+end_src
      + when running gradle task: ~./gradlew jar~, and unpacking the manifest file from the jar: ~ar xf lib/build/libs/lib-0.1.0.jar META-INF/MANIFEST.MF~, the content of the ==META-INF/MANIFEST.MF== should be (depending on your settings as seen above):
        #+begin_src example
        Manifest-Version: 1.0
        Implementation-Title: lib
        Implementation-Version: 0.1.0
        #+end_src
***** Generating sources jar
[2024-02-24 Sat 23:04]
- can generate a sources JAR for your library with ==withSourcesJar()==, which automatically packages source code and creates a variant ==sourceElements== with an artifact ==-sources.jar==, which will be part of the publication.
- in ==build.gradle.kts== ::
  #+begin_src kotlin
  java {
      withSourcesJar()
  }
  #+end_src
- the additional JAR will be produced as part of the ==assemble== or ==build== lifecycle tasks and will be part of the publication. The resulting file is found in ==lib/build/libs== for our case, with a name using the conventional classifier ==-sources==.
***** Adding API documentation
[2024-02-24 Sat 23:12]
- the ==java-library== plugin has built-in support for Java’s API documentation tool via the ==javadoc== task.
  + for ==javadoc== markups (/**...*/), when the ==javadoc== task is run (~./gradlew javadoc~), the generated javadoc can be found for example at ==lib/build/docs/javadoc/index.html==
  + also possible to generate the javadoc through the gradle build script ==build.gradle.kts==:
    #+begin_src kotlin
    java {
        withJavadocJar()
    }
    #+end_src
- the additional JAR will be produced as part of the ==assemble== or ==build== lifecycle tasks and will be part of the publication. The resulting file is found in ==lib/build/libs==, with a name using the conventional classifier ==-javadoc==.
***** Publish a build scan
[2024-02-24 Sat 23:28]
- notes ::
  + publishing a build scan is a handy way to learn more about what the builds are doing behind the scenes. To do so, just run Gradle builds with the ==--scan== flag: ~./gradlew build --scan~.
    - the commands generates a link that, when clicked on, gives which tasks where executed, which dependencies where downloaded and many more details.
***** The Java Plugin
[2024-02-22 Thu 19:17]
***** The Java Library Plugin
[2024-02-21 Wed 23:39]
** Spring and gradle
*** Introduction
- notes ::
  + sources ::
    - https://docs.spring.io/spring-boot/docs/3.2.2/gradle-plugin/reference/htmlsingle/
  + Spring Boot Gradle Plugin provides Spring Boot support in Gradle. It allows packaging executable jar or war archives, run Spring Boot applications, and use the dependency management provided by ==spring-boot-dependencies==
    - gradle's plugin for spring boot :: ~plugins {id("org.springframework.boot") version "3.2.2"}~
  + getting started ::
    - eg ::
      #+begin_src kotlin
      plugins {
        java
        war
        // plugin to enable springboot on gradle
        id("org.springframework.boot") version "3.2.2"
        // plugin to manage dependencies in the Spring Boot application
        id("io.spring.dependency-management") version "1.1.4"
      }
      #+end_src
*** Managing dependencies
**** notes
  + to manage dependencies in a Spring Boot application, one can either apply the ==io.spring.dependency-management== plugin or use Gradle’s native bom support. The primary benefit of the former is that it offers property-based customization of managed versions, while using the latter will likely result in faster builds
**** Managing dependencies with the dependency management plugin
- when applying ==io.spring.dependency-management== plugin, Spring Boot’s plugin will automatically import the ==spring-boot-dependencies== bom from the version of Spring Boot used. This provides a similar dependency management experience to the one that’s enjoyed by Maven users. For example, it allows to omit version numbers when declaring dependencies that are managed in the bom => can declare dependencies in the usual way but omit the version number
  #+begin_src kotlin
  dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
  }
  #+end_src
- customizing managed versions ::
  + the ==spring-boot-dependencies== bom that is automatically imported when the dependency management plugin is applied, uses properties to control the versions of the dependencies that it manages. To customize a managed version, one just needs to se its corresponding property, eg: to customize the version of SLF4J which is controlled by the ==slf4j.version== property: ~extra["slf4j.version"] = "1.7.20"~.
    - Browse the [[https://docs.spring.io/spring-boot/docs/3.2.2/reference/htmlsingle/#appendix.dependency-versions.properties][Dependency versions Appendix]] in the Spring Boot reference for a complete list of these properties.
- using spring boot’s dependency management in isolation ::
  + Spring Boot’s dependency management can be used in a project without applying Spring Boot’s plugin to that project. The SpringBootPlugin class provides a BOM_COORDINATES constant that can be used to import the bom without having to know its group ID, artifact ID, or version:
    1. configure the project to depend on the Spring Boot plugin but do not apply it
      #+begin_src kotlin
      plugins {
        id("org.springframework.boot") version "3.2.2" apply false
      }
      #+end_src
       - The Spring Boot plugin’s dependency on the dependency management plugin means that you can use the dependency management plugin without having to declare a dependency on it. This also means that you will automatically use the same version of the dependency management plugin as Spring Boot uses.
    2. apply the dependency management plugin and then configure it to import Spring Boot’s bom:
      #+begin_src kotlin
      apply(plugin = "io.spring.dependency-management")

      the<DependencyManagementExtension>().apply {
         imports {
             	 mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
         }
      }
      #+end_src
       - The Kotlin code above is a bit awkward. That’s because we’re using the imperative way of applying the dependency management plugin. We can make the code less awkward by applying the plugin from the root parent project, or by using the plugins block as done for the Spring Boot plugin. A downside of this method is that it forces us to specify the version of the dependency management plugin:
         #+begin_src kotlin
         plugins {
          java
          id("org.springframework.boot") version "3.2.2" apply false
          id("io.spring.dependency-management") version "1.1.4"
         }
               
         dependencyManagement {
          imports {
               	  mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
          }
         }
         #+end_src
       - to learn more about the capabilities of the dependency management plugin, please refer to its [[https://docs.spring.io/dependency-management-plugin/docs/current/reference/html/][documentation]].
**** Managing dependencies with gradle’s bom support ::
- gradle allows a bom to be used to manage a project’s versions by declaring it as a ==platform== or ==enforcedPlatform== dependency.
  + a ==platform== dependency treats the versions in the bom as recommendations and other versions and constraints in the dependency graph may cause a version of a dependency other than that declared in the bom to be used.
  + an ==enforcedPlatform== dependency treats the versions in the bom as requirements and they will override any other version found in the dependency graph
  + the ==SpringBootPlugin== class provides a ==BOM_COORDINATES== constant that can be used to declare a dependency upon Spring Boot’s bom without having to know its group ID, artifact ID, or version, as shown in the following example:
    #+begin_src kotlin
    dependencies {
        implementation(platform(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES))
    }            
    #+end_src
- a platform or enforced platform will only constrain the versions of the configuration in which it has been declared or that extend from the configuration in which it has been declared. As a result, in may be necessary to declare the same dependency in more than one configuration.
- customizing managed versions ::
  + when using gradle’s bom support, you cannot use the properties from ==spring-boot-dependencies== to control the versions of the dependencies that it manages. Instead, you must use one of the mechanisms that Gradle provides. One such mechanism is a resolution strategy: SLF4J’s modules are all in the ==org.slf4j== group, so their version can be controlled by configuring every dependency in that group to use a particular version, as shown in the following example:
    #+begin_src kotlin
    configurations.all {
        resolutionStrategy.eachDependency {
            if (requested.group == "org.slf4j") {
                useVersion("1.7.20")
            }
        }
    }
    #+end_src
  + warning :: each Spring Boot release is designed and tested against a specific set of third-party dependencies. Overriding versions may cause compatibility issues and should be done with care.
*** Packaging Executable Archives
[2024-02-21 Wed 00:35]
**** notes 
[2024-02-21 Wed 00:36]
- the plugin can create executable archives (jar files and war files) that contain all of an application’s dependencies and can then be run with ~java -jar~.
**** Packaging executable Jars
- executable jars can be built using the ==bootJar== task.
  + the task is automatically created when the ==java== plugin is applied and is an instance of ==BootJar==.
  + the ==assemble== task is automatically configured to depend upon the ==bootJar== task, so, running ==assemble== (or build) will also run the ==bootJar== task.
**** Packaging executable Wars
[2024-02-21 Wed 00:35]
- executable wars can be built using the ==bootWar== task.
  + the task is automatically created when the ==war== plugin is applied and is an instance of ==BootWar==.
  + the ==assemble== task is automatically configured to depend upon the ==bootWar== task, so, running ==assemble== (or build) will also run the ==bootWar== task.
**** Packaging executable and deployable Wars
[2024-02-21 Wed 00:37]
*** Dependency management plugin
[2024-02-21 Wed 00:25]
*** Gradle directories
[2024-02-21 Wed 00:23]
* Testing
[2023-12-17 Sun 03:51]
** JUnit 5
- User guide :: https://junit.org/junit5/docs/current/user-guide/ (for further documentation, such as each junit .jar use cases)
- JUnit 5 API :: https://junit.org/junit5/docs/5.0.1/api/index.html?overview-summary.html
- Notes ::
  + reminder :: tests design principle (can comment each group to easily locate what’s the testing step being processed):
    - Arrange :: setup and initialize objects and environment
    - Act :: exercise functionality to be tested
    - Assert :: 
  + one of the benefits of unit/component tests are ::
    - tests location tree :: ==src/test==
    - they can be used to build automated regression tests, and system design
    - writing documentation: can refer to unit tests to know the purpose of an application => need to write readable and easy to understand tests (hence better design also required)
  + spring-boot-starter-test contains libraries ::
    - JUnit :: standard for unit testing Java applications
    - Spring Test & Spring Boot Test :: utilities and integration test support for Spring Boot applications
    - AssertJ :: fluent assertion library
    - Hamcrest :: library of matcher objects (also known as constraints or predicates)
    - Mockito :: Java mocking framework
    - JSONassert :: assertion library for JSON
    - JsonPath :: XPath for JSON
  + "Setting up and tearing down tests" :: to setup test objects/methods life cycle with annotations (@BeforeEach, @AfterAll, etc.)
- setup ::
  + manual :: add spring-boot-starter-test to maven config file pom.xml 
  + shortcut for creating a test file in an IDE (intelliJ) :: right click on a class to test -> 'Go to' -> 'test' -> 'create new test'
    - in case junit module is missing, there will be a message 'Junit library not found in the module' -> push button 'fix' to fix :)
    - in eclipse: right click on any java class file -> new -> 'Junit test case'
      
** Some JUnit testing methods
[2023-12-18 Mon 15:20]
- assertEquals(expected, ActualValue) :: if used to compare collections, will compare the addresses and the order (same as ==assertIterableEquals==)
- assertSame(obj1, obj2) :: assert that both references point to same address, or "same object in memory" in case comparing enumerations
- assertTrue(aBoolean) ::
- assertThrows(typeClassExpected, lambdaExpression) :: to test exceptions
  + typeClassExpected :: eg:RuntimeException.class
  + lambdaExpression :: lambda expression that calls the method that should throw the exception to test
  + eg ::
    #+begin_src java
    // meh
    @Test
    void testThrowsException() {
        assertThrows(RuntimeException.class,
                     // DateTimeConverter is a custom defined class with method 'convertStringToDateTime' that catches RuntimeException, add a custom msg, and then rethrows it
                     () -> DateTimeConverter.convertStringToDateTime("9/2/2018 100 pm", LocalDate.of(2018,9,1));
                     );
        }
    // better
    @Test
    void testThrowsException() {
        Throwable error = assertThrows(RuntimeException.class,
                     // DateTimeConverter is a custom defined class with method 'convertStringToDateTime' that catches RuntimeException, add a custom msg, and then rethrows it
                     () -> DateTimeConverter.convertStringToDateTime("9/2/2018 100 pm", LocalDate.of(2018,9,1));
                     );
        assertEquals("Custom error message", error.getMessage())
        }
    #+end_src
** Run logical categories of tests together (group by specific functionality)
[2023-12-18 Mon 18:59]
- @Tag("aFunctionalTag") :: to mark tests to group, can be on class or method level
  + to run by tag :: (intellij) Edit run configuration -> select 'JUnit' field (uppermost one of 'junit' section) -> '+' (to add a new junit running configuration) -> name it -> in field 'Test kind' select 'Tags' -> in field 'Tag expression', add your defined label value or tag ('aFunctionalTag' in our case) -> run from targeted test tag
    - possible to make a complex tag expression :: by using 'not, or, and, etc.'

** Control test method execution (which to (de)activate)
[2023-12-18 Mon 18:20]
- @Disabled :: on a method to disable
- setting how assertions execute :: when first assertion fails, by default all the remaining fail too (later assertion don't report)
  + assertAll :: prevent any short circuiting of assertions
    #+begin_src java
    // parameters need to be lambda expressions
    assertAll(
              () -> assertEquals("Jim", aVar.firstName()),
              () -> assertEquals("Tallyho", aVar.lastName()),
              () -> assertEquals(21, aVar.age()),
              () -> assertSame(AnEnumClass.AVALUE, , aVar.enumValue())
              );
    #+end_src

** Format reporting and output messages for a better rendering and easy to read
[2023-12-18 Mon 17:14]
- create custom message in assertion :: eg:
  + if 3rd parameter is a lambda expression, it will only get evaluated if there is a failure, so that save some computation cost to use 3rd parameter as a lambda
  #+begin_src java
  @Test
  void testConvertTodayDateProperly() {
      LocalDate today = LocalDate.of(2018, 9, 1);
      LocalDateTime result = DateTimeConverter.convertStringToDateTime("today 1:00 pm", today);
      // custom msg as 3rd parameter to assertEquals
      assertEquals(result, LocalDateTime.of(2018, 9, 2, 13, 0), () -> "Failed to convert 'today' string to expected date. 'today' passed was: " + today);
      }
  // better
  #+end_src
- create custom text to display in place of test class and method names :: (with @DisplayName for example), for shorter/clearer name to display and/or give further information about the class or method, eg:
  #+begin_src java
  @Displayname("DateTimeConverter should :") // better to not stray too far from the class name
  class DateTimeConverterShould {
      // ...
      @DisplayName("throw exception if result...")
      void testThrowsException() {
          // ...
          }
      @DisplayName("convert expected input into...")
      void convert() {
          // ...
          }
      // ...
      }
  #+end_src
- create nested tests inside test class :: with @Nested
  #+begin_src java
  @Displayname("DateTimeConverter should :") // better to not stray too far from the class name
  class DateTimeConverterShould {

      // first part of display message will be the same
      @Nested
      @DisplayName("convert string with 'today' keyword ")
      class TodayTest {
          @DisplayName("properly")
          void testConvertTodayDateProperly() {
              LocalDate today = LocalDate.of(2018, 9, 1);
              LocalDateTime result = DateTimeConverter.convertStringToDateTime("today 1:00 pm", today);
              assertEquals(result, LocalDateTime.of(2018, 9, 2, 13, 0), () -> "Failed to convert 'today' string to expected date. 'today' passed was: " + today);
              }
          @DisplayName("regardless of case")
          void testConvertTodayDateProperlyCaseInsensitive() {
              LocalDate today = LocalDate.of(2018, 9, 1);
              // slight change: ToDay, instead of today (lowercase)
              LocalDateTime result = DateTimeConverter.convertStringToDateTime("ToDay 1:00 pm", today);
              assertEquals(result, LocalDateTime.of(2018, 9, 2, 13, 0), () -> "Failed to convert 'today' string to expected date. 'today' passed was: " + today);
              }
          }
      // ...
      @DisplayName("throw exception if result...")
      void testThrowsException() {
          // ...
          }
      @DisplayName("convert expected input into...")
      void convert() {
          // ...
          }
      }
      // ...

  // will output on test tool window:
  // DateTimeConverter should :
  //       throw exception if result...
  //       convert expected input into...
  //       convert string with 'today' keyword
  //           properly
  //           regardless of case
  #+end_src
  
** Tips on how to make unit tests
[2023-12-18 Mon 19:18]
- careful with dependencies, design your code so that dependencies are easy to mock and inject in the target code (follow solid principles, mainly Dependency inversion principle (DIP) and Single responsibility principle (SRP))
- extract business logic to test away from UI code

** Test driven development (TDD)
[2023-12-18 Mon 23:07]
- TDD :: drive your development from tests, instead of implementing features first and testing after. Regular iteration of cycles between writing tests (that fail), implement solution, write another test, make it work, etc.
  + result -> work by frequent switching from test to production code and back, adding functionality with each pass
  + benefits :: strong focus on what needs to be done, very testable code and design produced, helps produce clear interfaces (unit test are clients of the code, using TDD helps designing the code from the client point of view), helps produce clean code (refactoring while implementing, rather than coding first and refactor after)
  + basic process ::
    1. write just enough code to fail, write just enough production code to pass that test (and no more)
    2. "Read, Green, Refactor" rule :: write failing test (red, for non implemented yet method colored in red), implement enough code to make it work (gets green), refactor

** Annotations
[2023-12-18 Mon 11:13]
- @AutoConfigureMockMvc ::
- @BeforeAll :: run once before all methods in test class (@AfterAll will run after all tests have completed)
  + @BeforeEach :: will run once before each of the test methods are run (reverse for @AfterEach)
- @Nested :: to create nested test classes. The annotation must be added at a class level, for each inner class that contains tests
- @Test :: to indicate that method is a junit test method

* project rest user-manager

- Spring Initializr (https://start.spring.io/) to generate a new Spring Boot project. Make sure to include the following dependencies
  * when added dependencies and generated, the resulting ZIP file is an archive of applications is configured with selected choices

- structure of code ::
src/
   main/
      java/
         com.example.myapp/
            controller/
               UserController.java    // expose the REST endpoints for registering and retrieving models details
            dao/
               UserRepository.java    // for CRUDs
            model/
               User.java
            service/
               UserService.java       // business logic
               UserServiceImpl.java
	    aspect/
	       UserAspect.java        // to handle the aspect of logging the method calls
      resources/
         application.properties
   test/
      java/
         com.example.myapp/
            controller/
               UserControllerTest.java
            service/
               UserServiceTest.java
      resources/
         test.properties



#+begin_src org :exports src
Project       : Maven
Language      : Java 11
Springboot    : 3.0.5
Group         : com.peppermint
Artifact      : rest-user-manager
Name          : rest-user-manager
Description   : Simple user input-output manager of users.
Package name  : com.peppermint.rest-user-manager
Packaging     : War
Dependencies :
    Spring Web
    Spring Data MongoDB
    Spring AOP // for Aspect Oriented Programming: programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns, and validating inputs
    Lombok
#+end_src

** Notes
*** Miscs
    - AOP ::
      + source ::
	- https://www.baeldung.com/spring-aop
	- https://www.baeldung.com/spring-aop-annotation
      + AOPs are a way of adding behavior to existing code without modifying that code
      + eg ::
	- method 'afterReturn' which takes one argument of type Object and logs in that value
	#+begin_src org :exports src
	public class AdderAfterReturnAspect {
	    private Logger logger = LoggerFactory.getLogger(this.getClass());
	    public void afterReturn(Object returnValue) throws Throwable {
	        logger.info("value return was {}",  returnValue);
	    }
	}
	#+end_src
    - Mongo ::
      + basic commands (start, stop, status, etc.) :: https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-debian/
	- mongosh :: command to run mongodb in cli (default database: 'test')
	  + switch database :: ==use <db>== // swith to database name 'db'
	  + in database, show content :: ==db.<collection>.find( {} )==
	    - eg :: db.user.find( {} ) // show all content from collection user
      + ==@Document(collection = "<name_of_collection_to_use>")== annotation needed by spring to know which mongodb collection to query :: 

*** dependencies
    - ModelMapper :: provides a drop-in solution when our source and destination objects are similar to each other
*** debugging
- "Failed to Configure a DataSource” Error ::
  + could be a missing property in the applicationcontext file, check if everything is there for spring to connect properly on the corresponding database management system: connectors, driver, driver-class-name, etc.
- java.lang.IllegalStateException: Cannot call sendError() after the response has been committed ::
  + spring is fetching all the database from one entry point, then too much data can't be displayed properly: use Dtos, or use annotations so that Jackson can filter out not needed data
- "no java projects found in the current workspace vscode" :: java project structure not correct
- "Class has been compiled by a more recent version of the Java Environment" :: spring framework not compatible with jre, eg: with jre 11 matches spring framework 2.x.x, not above
- "Illegalstate failed to load applicationcontext" :: occured on test class, added annotation '@SpringBootTest'
  + could be object in unit test not properly instantiated
  + could be issue with already build version => try to rebuild project
    - eg, with vscode :: 'file explorer' -> 'JAVA projects' -> right click on project -> 'rebuild project/all'
- "java.lang.IllegalArgumentException: warning no match for this type name: com.example.demo.service.UserService [Xlint:invalidAbsoluteTypeName]" ::
- "No qualifying bean of type 'org.springframework.test.web.servlet.MockMvc' available" :: could be object MockMvc not properly instantiated. Add  ==@AutoConfigureMockMvc== to enable and configure auto-configuration of MockMvc
- "Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'text/plain;charset=UTF-8' not supported]" :: raw Postman not supported.
  + Solution :: in postman, set 'Headers' of http request to : key: 'Content-type', value: 'application/json'
- error status ::
  + "Internal Server Error" 500 ::
    - "Type definition error: [simple type, class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor]" ::
      + when using 'getOne' method, which is a lazy load operation, thus one gets only a reference (a proxy) to the entity, that means no DB access is actually made
      + if you have to serialize an entity with the @Entity annotation in JSON String format using Jackson library (directly or indirectly), the JPA entity will be serialized with all the fields => with ~hibernateLazyInitializer~ and ~handler~ as extra fields. So, if not ignored, these fields will be serialized in JSON format. To avoid this unnecessary serialization, you have to annotate with ~@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})~ on JPA/Hibernate entity, which will tell Jackson library that "Serialized JSON should not have these fields:
  + "Bad Request" 400 :: check if method exists, format is ok, there is no typo, etc.
  + "Not Found" 404 :: try to check if url path is correct
- conversion of Localdate to json :: add json serialize/deserialize to output dto
  + eg ::
    #+begin_src org :exports src
    @JsonDeserialize(using = LocalDateDeserializer.class)
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    #+end_src

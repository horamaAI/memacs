# -*- mode: org -*-
#+title: Java web programming learnings
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+TAGS: Java
* JAVA
** Notes
- Targeted JAVA version :: JAVA 17
- IDE used : IntelliJ ::
  + pros :: does lots of stuff for us from elements that are hinted by the dev : (install a small cli java compiler when there is none defined, update external libraries, etc.)
** Compile and run
- JRE :: java runtime environment, that makes it able for java applications to run.
  + The jre is cross platform, it takes standard 'bytecodes' (compiled classes that are OS agnostic), and through the JVM (Java Virtual Machine) and additional standar java libraries, adapt those bytecodes to the local environment.
- JDK :: Java development kit: JRE + compiler, debugger, javadoc, keytool, etc.
- flow :: *.java --[JDK]--> *.class --[JRE]--> execute
- comments ::
  + usual comments :: line comment (==//...==), block comment (==/*...*/==)
  + javadoc comments :: ==/**...*/== : same as block comments, but can be generated as javadocumentation
** Fundamentals
*** Java fundamentals and structural assumptions
**** Structure and conventions
+ naming conventions ::
  - packages ::
    + all lowercase,
    + use of reverse domain name notation to assure global *uniqueness* (there is an authority that makes sure the domain name is not used by someone else) : [domain_extension].[domain_main_name[.more_extension]*][...], eg : org.mydomain
    + add further qualifiers to assure uniqueness within company/group (eg: all code related to searching within domain 'mydomain' can be added to package ==org.mydomain.search==, ie. ==package org.mydomain.search;==)
      - same, the dev group in the sales department could use the following reversed dns ==org.mydomain.sales==
      - furthermore, if the devs in the sales department created an app that manages the sales account, they could use 'accounts management' in the reversed dns ==org.mydomain.sales.accountmanagement== => this avoids collisions in case another department create a sales account application.
  - type names are qualified by their package :: package org.mydomain.sales, qualifies class 'A' that is declared within it, and then, type name of A is now org.mydomain.sales.A (now they're globally unique)
    + when qualified, the executable part of the code is also qualified, ie: instead of running in cli ==java Main==, just run the qualified version ==java org.mydomain.sales.Main==
  - variables naming conventions :: only letters and numbers, no starting with number, camelCase (not start with uppercase)
  - classes :: same as variables, but first letter capitalized, name of class must be the same as file name :: class Toto => file Toto.java
  - methods :: same as variables
  - enums :: enum class naming convention same as usual classes (first char uppercase, camelCase), values: all in uppercase
*** Variables, types, operators data type conversions, and operators arithmetics
[2023-11-29 Wed 12:08]
[2023-11-28 Tue 19:32]
**** Operators and types
[2023-11-28 Tue 19:37]
- Variables :: named area of storage (Java strongly typed language)
- primitive types ::
  + primitive types are stored *by value* (directly store the *values* when assigning, in contrast to classes that store references to instantiated objects). They represent only data, they're not able to provide methods for operating on that data
  + chars :: single unicode char, eg: 'u' or '\u00DA' (for 'u' with accent: \u followed by 4digits hex value of char)
  + integer :: byte (8bits), short (16bits), int (32bits), long (eg: 9L)
  + decimal :: float (32bits, eg: 3.14f), double (64bits, eg: 3.14 or 3.14d)
  + boolean :: true/false (primitive)
    - note ::
      + xor operator ==^== is true only when the two operands are differents (0^1 or 1^0)
      + conditional logical operators (&& and ||) evalueate the right side only when needed (in case of ||, only evaluate right hand side when left is false)
- ==var== "type" :: type then inferred with first assignment, no need then to explicitly define the type of the variable
  + constraints :: need to be assigned when declared, and variable is statically typed (cannot change the type of assigned value), therefore need for cast when assigning a non matching value
- ==final== :: constant variable/attributes/classes/methods
- ==static== :: set what's defined to only one instance of object/class/method/etc., and have persistent lifetime (object is associated to the class)
  + static variables get loaded when class is loaded by ClassLoader, and removed when Classloader used is garbage collected
  + static methods *only* work with static variables
  + "static import statement" ::
    - "import statement" :: allows a type name to be used without being package-qualified (give the full package path: ~package com.example.etc~)
    - "static import statement" :: used with static methods, allows method name to be used without being class qualified
      #+begin_src java
      // instead of importing using : import com.example.something.AClass;
      // use static keyword with the full path to the static member
      import static com.example.something.AClass.staticMember;

      staticMember; // and now the static member can be called without the call to the class (without "qualifying" the member by its class)

      // can do even better by referencing all static members of class AClass:
      // import static com.example.something.AClass.*;
      #+end_src
  + static initializer :: run only once, before type's first use (can be used for example for using connection services)
    - has access to static members only
    - static keyword preceded
    - and *out of any constructor or method*
      #+begin_src java
      public class A {
          private int member1;
          private static boolean statMember;

          static { // will run only once, before class A is used
              AdminService admin = new AdminService(); // dummy service that hypothetically check if there is no restriction exists based on some implementation
              admin.connect();
              statMember = admin.anyRestriction() ? false : true;
              admin.close();
              }

          public A(int member1) {
              this.member1 = member1;
              }

          }
      #+end_src
- operators ::
  + operators precedence :: left to right when equivalent or when tied
    - precedence order :: postfix, prefix, multiplicative (==* / %==), additive (==+ -==)
      - table ::
        +-----+----------+--------------+-------------+
        | 16  | ()       |parentheses   |left-to-right|
        +-----+----------+--------------+-------------+
        |     | []       |   array      |             |
        |     |          |  access      |             |
        +-----+----------+--------------+-------------+
        |     |  .       |  member      |             |
        |     |          |  access      |             |
        +-----+----------+--------------+-------------+
        | 15  | ++       |    unary     |left-to-right|
        |     |          |post-increment|             |
        +-----+----------+--------------+-------------+
        |     | --       |    unary     |             |
        |     |          |post-decrement|             |
        +-----+----------+--------------+-------------+
        | 14  |  +       |  unary plus  |right-to-left|
        +-----+----------+--------------+-------------+
        |     |  -       | unary minus  |             |
        +-----+----------+--------------+-------------+
        |     |  !       |unary logical |             |
        |     |          |     NOT      |             |
        +-----+----------+--------------+-------------+
        |     |  ~       |unary bitwise |             |
        |     |          |     NOT      |             |
        +-----+----------+--------------+-------------+
        |     | ++       |    unary     |             |
        |     |          |pre-increment |             |
        +-----+----------+--------------+-------------+
        |     | --       |    unary     |             |
        |     |          |pre-decrement |             |
        +-----+----------+--------------+-------------+
        | 13  | ()       |     cast     |right-to-left|
        +-----+----------+--------------+-------------+
        |     | new      |    object    |             |
        |     |          |   creation   |             |
        +-----+----------+--------------+-------------+
        | 12  |* / %     |multiplicative|left-to-right|
        +-----+----------+--------------+-------------+
        | 11  | + -      |   additive   |left-to-right|
        +-----+----------+--------------+-------------+
        |     |  +       |    string    |             |
        |     |          |concatenation |             |
        +-----+----------+--------------+-------------+
        | 10  |<< >>     |    shift     |left-to-right|
        +-----+----------+--------------+-------------+
        |     | >>>      |              |             |
        +-----+----------+--------------+-------------+
        |  9  |< <=      |  relational  |left-to-right|
        +-----+----------+--------------+-------------+
        |     |> >=      |              |             |
        +-----+----------+--------------+-------------+
        |     |instanceof|              |             |
        +-----+----------+--------------+-------------+
        |  8  |    ==    |   equality   |left-to-right|
        +-----+----------+--------------+-------------+
        |     |    !=    |              |             |
        +-----+----------+--------------+-------------+
        |  7  |    &     | bitwise AND  |left-to-right|
        +-----+----------+--------------+-------------+
        |  6  |    ^     | bitwise XOR  |left-to-right|
        +-----+----------+--------------+-------------+
        |  5  |    |     |  bitwise OR  |left-to-right|
        +-----+----------+--------------+-------------+
        |  4  |    &&    | logical AND  |left-to-right|
        +-----+----------+--------------+-------------+
        |  3  |    ||    |  logical OR  |left-to-right|
        +-----+----------+--------------+-------------+
        |  2  |    ?:    |   ternary    |right-to-left|
        +-----+----------+--------------+-------------+
        |  1  | =   +=   |  assignment  |right-to-left|
        |     |    -=    |              |             |
        +-----+----------+--------------+-------------+
        |     |*=   /=   |              |             |
        |     |    %=    |              |             |
        +-----+----------+--------------+-------------+
        |     |&=   ^=   |              |             |
        |     |    |=    |              |             |
        +-----+----------+--------------+-------------+
        |     | <<=  >>= |              |             |
        |     |   >>>=   |              |             |
        +-----+----------+--------------+-------------+
        |  0  |    ->    |    lambda    |right-to-left|
        |     |          |  expression  |             |
        |     |          |    arrow     |             |
        +-----+----------+--------------+-------------+
  + operator 'instanceof' :: ~(object) instanceof (type)~, checks if object is of type 'type' (note: instanceof is still an operation, and hence imply a cost, so try to reduce this with better design)
- Type conversion ::
  + implicit :: performed by compiler (eg: long valLong = valInt; // where valInt is explicitly declared as int, said as "widening conversion")
  + explicit :: with cast operator (eg: int valInt = (int) valLong; // where valLong is explicitly declared as long, careful of *side-effects*: precision loss, and compiling errors)
- conditional logic and operators ::
  + ==switch default== cases :: only supported on primitive types: byte, char, short, int, long
    - format :: ==switch(val) {case k0: ...; break;...;default:...;break;}
- Non primitive types ::
  + non primitive types do not directly hold object values, but rather hold references to values => new instances of the objects are created
    - eg = doing ~String str = "I";~ and then ~str += ' Love'; str += " you"~, will create 3 string instances : "I", "I Love", "I Love you", and then str will reference the 3 strings in order until the last => *BE CAREFUL*
    - can use StringBuilder for more efficiency
  + equality operator =='=='== DOES NOT check equality of values, but rather if the operands are pointing to the same reference
  + strings ::
    - 
  + arrays :: format : ==type[] = new type[nElements];==, or with list initialization: ==type[] = {ele1, ..., eleN};==
    - size of array :: ==arrayVar.length;==
*** Methods, Class, Objects
[2023-11-29 Wed 14:05]
**** Notes
[2023-12-02 Sat 02:14]
- members of class (its 'fields') can also be called its 'states'
- default access modifiers :: 'package-private': members are only visible within the package (inside the same package to which the class belongs)
- default constructors in java will fill default values where possible (primitive types and default constructors for embedded object)
  + *careful* :: java generates default constructors only when none is provided, thus if custom constructors are provided, then all the different constructors have also to be provided for the different type of signatures that will be needed
  + when constructors are provided, the constructor with no arguments is then called the default constructor
- "chained constructors": embedded constructors calls :: to avoid boilerplates and use available constructors to cascade all the parameters until the top (no order in the constructors declaration needed)
  #+begin_src java
  public class A {
      int member1;
      int member2;
      public A(int member1, int member2) {
          this(member1);
          this.member2 = member2;
          }
      }
      public A(int member1) {
          this.member1 = member1;
          }
      }
  #+end_src
- "initialization blocks" :: code that runs during object creation (not related to default constructor, works as completely separate (but interdependent))
  + initialization order :: field initializers -> initialization blocks -> constructors
  #+begin_src java
  public class A {
      int n = 5;
      boolean[] arrBool = new boolean[n];
      int member1;
      
      { // initialization block
          for(int i = 0; i < n; i++) {
              arrBool[i] = true;
          }
      }
      public A(int member1) {
          // initialization block above will run
          this.member1 = member1;
          }
      }
  #+end_src 
- null in java : ==null==
- "accessors" and "mutators" :: eg: getSmthing(), setSmthing(smthing)
- same as all non primitive types, classes instanciations (using ==new==) allocate new memory the size of the class specified. So, each time the variable is re-assigned with 'new', a new instance of the class is created, and the reference of the variable is changed to the new object, the old one being lost if not referenced anywhere else.
**** Methods
- Method arguments :: in java, every non primitive objects are references to objects. So when declaring a new object, it's just a reference to an instance. Furthermore, when calling a method, this method will create copy references of the arguments
  + wrong modifications of objects :: where changes have no effect outside of the method, as may be intended
    #+begin_src java
    // file A.java
    public class A {
      int i;
      public A(int i) {
          this.i = i;
      }

      static void swap (A a1, A a2) {
          A buff = a1; // here, a new reference 'buff' is pointing to the same instance as 'a1'
          a1 = a2; // the reference a1 is a new local reference (reference copy of the content passed as argument to method swap). So a1 will point to the same content as the reference used when calling method swap. new copy reference a1 == 20
          a2 = buff; // same as for a1, the new local copy reference a2 will then point to the content of reference buff, ie. a2 will point to the same content as buff <=> a2 == 10, but the content of the calling reference used on 'swap' will still point to the same content as before (no swap outside of the method)
      }
    }

    // Main
    public class Main {

      public static void main(String[] args) {
          A a1 = new A(10);
          A a2 = new A(20);

          A.swap(a1, a2); // when calling swap, the method will create copy reference, in that case the content is unchanged, ie. a1.i == 10; a2.i == 20
      }
    }
    #+end_src
  + right way of applying changes outside of the method :: changes apply on the *content* of the calling references (using setters and getters)
    #+begin_src java
    // file A.java
    public class A {
        // same as above, but with accessors and mutators
        ...
        static void swap (A a1, A a2) {
          A buff = a1.aGetter(); // buff member is a new reference to the content of copy reference a1
          a1.aSetter(a2); // here the changes apply on the *content* of the instance referenced by a1, ie. a1 points to object where the content is modified to 20 <=> a1.i == 20, and applies also outside of the method
          a2.aSetter(buff); // same as above, a2.i == 10
      }
    }

    // Main
    public class Main {

      public static void main(String[] args) {
          A a1 = new A(10);
          A a2 = new A(20);

          A.swap(a1, a2); // the content of the instances referenced by a1 and a2 were properly swapped: a1.i == 20; a2.i == 10;
      }
    }
    #+end_src
- Overloading :: when there is no signature for an overladed method that matches the one, the java compiler will cope: eg: if exists signature ~method(int)~, and one passes ~method(short)~, then the short can be promoted as an int to match the existing signature.
  + for more details about the steps of method selection at compile and run time, see [[https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html#jls-15.12][dedicated oracle page]]
    - runtime for overriding, and compile time for overloading
**** Wrapper classes, enums, and records
[2023-12-02 Sat 19:35]
- primitive wrapper classes :: are classes that can hold primitive data values, *and* also provide methods (since they're classes), and enable compatibility with richer aspects of java type system
  + each primitive types have wrapper classes :: eg: Integer is the wrapper classes for integers int
  + "boxing" :: process to convert primitive types to their wrapper classes (often done implicitly by the compiler, and creates a new *copy* of the source primitive type, it doesn't just create a reference to the value)
  + "unboxing" :: the opposite of boxing, create a primitive type from a wrapper (same, creates a new copy)
- enums :: useful for defining a type with a list of *finite* valid values (use of keyword ==enum==)
  + enum support equality tests with content, not with reference
  + enum values are ordered from first value as lowest to last value as highest, so value can be quantitatively compared (relative comparisons with method ~compareTo~ that returns a negative, 0, or positive value)
  + supports ~switch cases~, and enum switch case labels must be unqualified (~ENUMVALUE~, instead of ~EnumClass.ENUMVALUE~)
  + enums are classes: explicit inheritance of java's ~Enum~ class, can have members, constructors, methods, etc.
    - main difference with usual classes :: enum types values are instances, meaning if the enum type has other member types, these are considered as instances, an can for example use constructor defined in the enum class
      #+begin_src java
      public enum Weekends {
          SATURDAY("Let's have fun!"), // enum values are separated by commas, not semicolons
          SUNDAY("Let's rest!"); // when finished enumerating values, then semicolons

          public String getTitle() {return title;}
          private:
              Weekends(String title) {
                  this.title = title;
              }
              String title;
          }
      // Main
      // ...
      Weekends day1 = Weekends.SATURDAY;
      Weekends day2 = Weekends.SUNDAY;
      assertTrue(day2 == Weekends.SUNDAY); // Yaayy!!
      assertFalse(day1 == day2); // Yaayy!!
      #+end_src
- records (or data-only classes) :: classes that only store data: useful to carry data around for example (data transportation)
  + help reducing boilerplates code (for example constructors implementation (particularly when complex models are being constructed), getters, and other common methods (equals, hashCode, toStrings, etc.))
  + use of keyword ==records== :: when keyword used, compiler automatically :
    - generate code (constructors, getters, equals, hashCode, etc.),
    - and apply *restrictions* (*immutability* being the main)
  #+begin_src java
  public record A (/* arguments as in methods : [type identifier], ... */String name, int age) {} // that's all
  // Main:
  // ...
  A a = new A(Toto, 12);
  A a2 = new A(Tata, 12);
  String nameA = a.name(); // OK, since generated by compiler
  // syso(a); also OK, since toString also generated by compiler
  assertFalse(a.equals(a2)); // same, also OK since equals is generated too and compares all the values of the objects
  #+end_src
*** Algorithms and standard library
**** Basics
- class 'Object' main methods  ::
  + clone :: create a duplicate instance of the source
  + toString :: by default prints reference numbers, not content (need to override)
  + equals :: compare content of objects for equality. By default, same as ~==~ and compare equality of references, not the content => needs for specialization (overriding Object's default equals) within the class:
    #+begin_src java
    public class A {
        private int member;
        A(int member) {
            this.member = member;
            }
        public boolean equals(Object o) {
            if (!(o instanceof A))
                return false;
            return this.member == ((A)o).member;
            }
        }
    #+end_src
  + getClass :: returns type information of the source
  + hashCode :: objects with same content have equal hash code, but different objects do not need to return different hash codes
    - hashCode algorithm contract ::
      1. same object must consistently return the same value (provided not modified meanwhile, and hash value can change through different execution)
      2. if objects are equal according to the equals(Object) method, hashCode() method on each of the two objects must produce the same value
      3. if two objects are unequal according to the equals(java.lang.Object) method, calling hashCode method on each of the two objects doesn’t need to produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables
- exceptions :: ~printStackTrace()~
- Wrapper classes :: converting to/from other primitive types (eg: ~Double.parseDouble(doubleAsString);~), extracting values from strings (for eg when strings contains integers), finding max/min values, etc.
- enums :: ~values~ (returns an array that contains all the enum values), ~valueOf~, etc.
- foreach :: ==for(loop-variable : array)==
- parsing ::
  + parse string as double :: Double.parseDouble(str);
- strings ::
  + strings are the same :: ==str1.equals(str2)==
    - can still use equality operator through "interning strings" (method ==str.intern()==) :: intern checks if no other string *reference* does not have the same content as str, and if it exists, then a new object won’t be created and the new reference will point to this other string
      #+begin_src java
      @Test
      public void whenIntern_thenCorrect() {
          String s1 = "abc";
          String s2 = new String("abc");
          String s3 = new String("foo");
          String s4 = s1.intern();
          String s5 = s2.intern();
          
          assertFalse(s3 == s4);
          assertTrue(s1 == s5);
      }
      #+end_src
      + *BE AWARE OF OVERHEADS!!!** with interning
  + useful String methods :: length, charAt, substring, replace, concat, toLowerCase, split (with separator given as regex ~str.split(",")~), format, contains, endsWith, compareToIgnoreCase, lastIndexOf, valueOf (convert primitive type to string, can also be done implicitly, eg : ~String res = 10 + " is an integer"~)
  + StringBuilder ::
    - provides mutable string buffer :: efficient, add new content with ==append==, add new content within with ==insert==
    - however :: need to extract string at the end with ==toString==, but can still keep using the string builder
      #+begin_src java
      String str = "toto";
      int n = 1;
      Stringbuilder strBuilder = new StringBuilder(40);
      strBuilder.append("I");
      strBuilder.append(" say");
      strBuilder.append(" I am ");
      strBuilder.append(str);
      strBuilder.append(" number ");
      strBuilder.append(n);
      String msg = strBuilder.toString(); // msg = I say I am toto number 1
      int pos = strBuilder.indexOf(" I am"); // can still work on the string builder
      String addendum = " will you tell him";
      strBuilder.insert(pos, addendum);
      msg = strBuilder.toString(); // msg = I say will you tell him I am toto number 1
      #+end_src
- CLI IO interactive ::
  + IO from cli :: object ==Scanner==
    #+begin_src java
    import java.util.scanner;
    ...
    Scanner scanner = new Scanner(System.in);
    scanner.nextLine(); // reads user input until end of key or EOF
    ...
    #+end_src
**** Streams
[2023-12-05 Tue 12:51]
- filter, foreach :: eg:
  #+begin_src java
  List<AircraftTarget> targets; // suppose it is initialized with latitudes and longitudes (integers)
  var aircraftInRange = targets.stream()
      .filter(a -> {
              var distance = (int) Math.sqrt((originLat - a.lat()) * (originLat - a.lat()) +(originLon - a.lon()) * (originLon - a.lon()));
              return distance <= range;}).foreach(System.out.println);
  #+end_src
  
*** Annotations
[2023-12-03 Sun 00:35]
**** Notes
- useful to extend basic type system to incorporate extended infos about types within those types
- this allows tools and other code to act on context and intent based on the extended annotations :: eg: XML and JSON processors use annotations to simplify mapping between the java types and their respective representations
- annotations are special types that act as metadata. These metadata can be interpreted by different tools (compiler, IDE, etc.), execution environments, and even other programs (those that generate documentation for example)
- can even use annotations within the program, by writing programs that interpret needed annotations
- annotations are preceded by ==@== :: @Override (used by the java core platform), @Deprecated (to say that the marked element should no longer be used, and the compiler will generate warnings when used, but will still work), @SuppressWarnings (to indicate to the compiler to not generate certain kind of warnings, eg: to suppress deprecated compiler warnings: ~@SupressWarnings("deprecation")~)
- annotations can be used anywhere, so it's always good to reduce their scope so that one doesn't miss anything, eg for the case of SuppressWarnings, better to place ~@SupressWarnings("deprecation")~ on the deprecated method, instead of its whole class
** Design with JAVA

** Definitions
- Fields :: same as saying class members
- Encapsulation :: hiding the implementation of the details about methods, members variables, etc. inside a class
- overloading vs overriding :: former: changing the signature of a method with different types of arguments, the latter: use in inheritance context, sets which method will be called, the base or the derived
- Classloader :: object that is responsible for loading classes
- Class vs Object :: object is an instance of a class, and a Class is its blueprint or template from which the object is created


* Spring
[2023-12-04 Mon 22:52]
* project rest user-manager

- Spring Initializr (https://start.spring.io/) to generate a new Spring Boot project. Make sure to include the following dependencies
  * when added dependencies and generated, the resulting ZIP file is an archive of applications is configured with selected choices

- structure of code ::
src/
   main/
      java/
         com.example.myapp/
            controller/
               UserController.java    // expose the REST endpoints for registering and retrieving models details
            dao/
               UserRepository.java    // for CRUDs
            model/
               User.java
            service/
               UserService.java       // business logic
               UserServiceImpl.java
	    aspect/
	       UserAspect.java        // to handle the aspect of logging the method calls
      resources/
         application.properties
   test/
      java/
         com.example.myapp/
            controller/
               UserControllerTest.java
            service/
               UserServiceTest.java
      resources/
         test.properties



#+begin_src org :exports src
Project       : Maven
Language      : Java 11
Springboot    : 3.0.5
Group         : com.peppermint
Artifact      : rest-user-manager
Name          : rest-user-manager
Description   : Simple user input-output manager of users.
Package name  : com.peppermint.rest-user-manager
Packaging     : War
Dependencies :
    Spring Web
    Spring Data MongoDB
    Spring AOP // for Aspect Oriented Programming: programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns, and validating inputs
    Lombok
#+end_src

** Notes
*** Miscs
    - Dto :: for "Data Transfer Object", carries data between processes to facilitate communication between two systems (like an API and a server) without potentially exposing sensitive information
      + source :: https://www.baeldung.com/java-dto-pattern
      + context :: OOP environments rely on "calls.", each one a bit like a data lookup, thus requiring both time and processing speed. If programmer not careful, calls can also expose sensitive data, eg :: employee addresses, account numbers, social security numbers, etc.
	- a Dto can help send only the required information, not everything in the database
	- Dtos are objects that carry data between processes in order to reduce the number of methods calls
	- purpose is to reduce roundtrips to the server by batching up multiple parameters in a single call => reduces the network overhead in such remote operations
	- other benefit is the encapsulation of the serialization's logic
	  + serialization :: mechanism that translates the object structure and data to a specific format that can be stored and transferred
	- DTO should just contain data, not business logic
	- how to use Dtos ::
	  + DTOs normally are created as POJOs (Plain Old Java Objects)
	    - only contain storage, accessors and eventually methods related to serialization or parsing
	    - data is mapped from the domain models to the DTOs, normally through a mapper component in the presentation or facade layer
	      + front (html, json, etc.) exchange with presentation layer ::
		- presentation layer ::
		  + Dto only point communicating with front
		  + to request data, Dto goes through *only* the mapper and gathers only the data required for the front
		  + Dto can gather content of different models, eg :: Dto (userName, roleName), combines data from two models: User, and Role
    - binding results :: general interface that represents binding results, extends the interface for error registration capabilities, allowing for a Validator to be applied, and adds binding-specific analysis and model building
    - AOP ::
      + source ::
	- https://www.baeldung.com/spring-aop
	- https://www.baeldung.com/spring-aop-annotation
      + AOPs are a way of adding behavior to existing code without modifying that code
      + eg ::
	- method 'afterReturn' which takes one argument of type Object and logs in that value
	#+begin_src org :exports src
	public class AdderAfterReturnAspect {
	    private Logger logger = LoggerFactory.getLogger(this.getClass());
	    public void afterReturn(Object returnValue) throws Throwable {
	        logger.info("value return was {}",  returnValue);
	    }
	}
	#+end_src
    - Mongo ::
      + basic commands (start, stop, status, etc.) :: https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-debian/
	- mongosh :: command to run mongodb in cli (default database: 'test')
	  + switch database :: ==use <db>== // swith to database name 'db'
	  + in database, show content :: ==db.<collection>.find( {} )==
	    - eg :: db.user.find( {} ) // show all content from collection user
      + ==@Document(collection = "<name_of_collection_to_use>")== annotation needed by spring to know which mongodb collection to query :: 

*** annotations
    - @RequestBody :: maps the HttpRequest body to a transfer or domain object, enabling automatic deserialization of the inbound HttpRequest body onto a Java object
    - @PathVariable :: can be used to handle template variables in the request URI mapping, and set them as method parameters
      #+begin_src org :exports src
      @GetMapping("/api/employees/{id}")
      @ResponseBody
      public String getEmployeesById(@PathVariable String id) {
        return "ID: " + id;
      }
      #+end_src
      + will extract the templated part of the URI (represented by the variable {id})
    - @Document :: annotation used for the same purpose as @Entity annotation in JPA
    - @SpringBootTest :: creates an application context to be used in a test
*** dependencies
    - ModelMapper :: provides a drop-in solution when our source and destination objects are similar to each other
*** debugging
    + "no java projects found in the current workspace vscode" :: java project structure not correct
    + "Class has been compiled by a more recent version of the Java Environment" :: spring framework not compatible with jre, eg: with jre 11 matches spring framework 2.x.x, not above
    + "Illegalstate failed to load applicationcontext" :: occured on test class, added annotation '@SpringBootTest'
      - could be object in unit test not properly instantiated
      - could be issue with already build version => try to rebuild project
	+ eg, with vscode :: 'file explorer' -> 'JAVA projects' -> right click on project -> 'rebuild project/all'
    + "java.lang.IllegalArgumentException: warning no match for this type name: com.example.demo.service.UserService [Xlint:invalidAbsoluteTypeName]" ::
    + "No qualifying bean of type 'org.springframework.test.web.servlet.MockMvc' available" :: could be object MockMvc not properly instantiated. Add  ==@AutoConfigureMockMvc== to enable and configure auto-configuration of MockMvc
    + "Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'text/plain;charset=UTF-8' not supported]" :: raw Postman not supported.
      - Solution :: in postman, set 'Headers' of http request to : key: 'Content-type', value: 'application/json'
    + " expected:[201] but was:[404]" :: means request was not found. => try to check if url path is correct
    + " expected:[201] but was:[400]" :: well, since http error 400 is bad request, means request is a bad request
    + conversion of Localdate to json :: add json serialize/deserialize to output dto
      - eg ::
          #+begin_src org :exports src
	    @JsonDeserialize(using = LocalDateDeserializer.class)
            @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
          #+end_src

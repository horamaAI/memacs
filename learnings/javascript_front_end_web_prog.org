# -*- mode: org -*-
#+title: learning Javascript web programming language and tools
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+TAGS: Java


* JavaScript (JS) and TypeScript (JS)
[2023-12-19 Tue 14:42]
- Notes ::
  + the official JS language specification standard is called ES (ECMAScript): ES version defined previously by sequential number (eg: ES3, ES5, etc, supported by older browsers), but from ES6, that was renamed 2015 -and brought many new features such as classes and arrow functions-, new version is released each year
    - => newer JS features have to be transpiled to older JS
  + TS :: open source, superset to JS (every JS code supported by TS), transpiles to plain JS (TS code must be compiled and converted to comparable JS syntax before the browser executes it)
    - dig further :: https://www.typescriptlang.org/
  + 'let' :: to define local variable
  + 'for...of' vs 'for...in' ::
    - for...of :: loops on iterable objects
    - for...in :: loops on properties of an object:
      #+begin_src javascript
      let arr = ['a', 'b', 'c'];
      for (let obj in arr) {
          console.log(obj); // 0, 1, 2. The array indexes are enumerable properties with integer names
          }
      #+end_src
  + private variables prefixed with underscore :: ~private _something: sometype;~
  + arrow function :: compact syntax to define a function, no 'return' keyword ~(param: paramType) => {param.doSomething(); param.doAnotherThing(); }~
  + JS arrays ::
    - filter method :: ~products.filter()~
      + creates new array by filtering content from previous array :: => use two arrays: one for the base array property, and one for its filtered version. Otherwise you might loose the base array when filtering
      + 'filter' method needs true/false logic to compare objects (arrow function)
      #+begin_src javascript
      performFilter(): IProduct {
          return products.filter( ( product: IProduct ) => product.productName.includes( filteringParameter ) );
          }
      #+end_src
    
* Angular
** Notes
- angular :: JS framework for building client-side applications
- benefits :: more expressive html, powerful data-binding (to connect data directly to UI), promotes modularity ("modular by design": app built as a set of blocks (set of components), so that it is easier to create and reuse the contents), built-in support for back-end integration (easier communication with a back-end server)
- installing manually ::
  + nvm :: to select which version of node.js to install  (https://github.com/nvm-sh/nvm#installing-and-updating)
  + npm :: install it with nvm when done: ==nvm install --lts==, to install latest Node.js LTS release
    - check if everything is installed properly ::
      #+begin_src bash
      node -v
      npm -v
      #+end_src
- installation ::
  1. needed ::
     + angular framework and libraries :: 
     + angular cli :: 
     + TS ::
     + testing tools, linters ::
     + and others :: 
  2. for installing dependencies/packages, two options:
     + either use npm commands to install all those manually;
     + or as commonly done, define a ==package.json== file listing each needed packages, and use npm to install defined packages, their dependencies, with all the versions (~npm install~ in folder)
- in package.json, :: the list of packages is divided into two parts:
  + 'dependencies' :: packages required for development AND deployment, eg: primary angular packages, and supporting packages (~rxjs~) : ~@angular/(animations|common|compiler|etc.)~
  + 'devDependencies' :: packages only required for development, eg: ~@angular/(compiler|compiler-cli)~
- some TS types ::
  + any[]: array of any object (eg: ~products: any[];~)
  
** Anatomy of an angular app
[2023-12-19 Tue 14:04]
- angular ::
  + comprised of a set of components, or can also be seen as comprised of a set of services that provide functionality across components. eg of services: accessing data from a back end server, standard logging, exception handling, performing tax calculations, etc.
  + an angular application can be seen as a set of components, the developer arranges those components to form the application
- angular component :: each angular component has a: ==component = UI (template) + code (class (properties, methods)) + extra-data (metadata)==
  + template (UI) :: html defining a view for the application, can be seen as the UI,
  + class (code) :: contains the code associated with a view, the code behind the UI, contains:
    - properties :: or property variables, or data elements, hold the data to display in the UI, available for binding to the view
    - methods :: that perform actions for the view, eg: handle click on button
  + metadata :: provides further infos about the component to angular
*** angular project's folder structure
- uppermost files (at root of project, also called 'boilerplate files') :: configuration and setup files 
- ==src== :: by convention, all source code in 'src'
  + src subfolders ::
    - app :: contains source file specific to the application per se
      + app folder contains subfolders specific to each major feature of the application
- ==node_modules== :: contains the libraries and dependencies of installed packages
  + don't forget to escape it in the version controller, it is too heavy, and anyway we have the package.json to fetch all the required dependencies
    
** Components and modules in Angular
[2023-12-19 Tue 14:32]
*** Notes
[2023-12-20 Wed 10:46]
- component :: ==component = UI (template) + code (class (properties, methods)) + extra-data (metadata)==
  + template :: view layout, created with html, defines what is rendered on the page, includes binding and directives
  + class :: code supporting the view, created with TS, divided into properties (data), and methods (logic behind the view), eg: if wants to define a title in the view, then define a class property 'title' for the title; if wants to show/hide an image in the view, then add logic in class method
    - property :: defines a data element associated with a class (variables for example), format: ~propertyName: dataType = assignement~
  + metadata :: defines extra data for angular component (for eg, it's the metadata that defines a class to be a component class), metadata defined with decorators (function that adds metadata to a class, its members, or its method's arguments)
  + so in the end :: an angular *component is a view defined in a template, its associated code defined with a class, and metadata defined with a decorator*
  + eg :: imports, template, class, metadata
    #+begin_src javascript    
    import { Component } from '@angular/core'; // imports

    @Component({ // metadata & template components
      selector: 'pm-root', // root directive when the component used as a directive, prefixed to reference it as a part of the application (convention)
      templateUrl: './app.component.html', /* specific to view */
      styleUrls: ['./app.component.css']
    })
    export class AppComponent { // class component
      title = 'Angular: Getting Started';
    }
    #+end_src
- data binded variables :: between double curly braces
  + data binding ties template values to class property values
    #+begin_src javascript
    @Component({
      selector: 'pm-root',
      template: '<div><h1>{{myTitle}}</h1></div>' // myTitle is binded to its property value in class AppComponent
    })
    export class AppComponent {
      myTitle: String = 'Toto is Getting Started';
    }
    #+end_src
- imports :: ~import { MemberNameToImport, MemberNameToImport2, MemberNameToImport3 } from 'LibraryOrComponentContainingTheImportedElement';
  + needed in order to use external function/class
  + allow using exported members from :: (need to 'export' the class so that it can be imported)
    - other files in the application
    - angular framework, eg: @Component from angular core, so ~import { Component } from '@angular/core';~
    - external javascript libraries
  + even for installed external packages (locally/globally), still need to import them :: in the component, in the style sheet, etc. eg:
    #+begin_src javascript
    // global css file: src/styles.css
    @import "~bootstrap/dist/css/bootstrap.min.css";
    @import "~font-awesome/css/font-awesome";
    //...
    // to install bootstrap and font-awesome:
    // $> npm install bootstrap font-awesome
    #+end_src
    
*** Creating component classes
[2023-12-20 Wed 10:46]
- structure :: ~'export' 'class' ClassName {}~
  + eg ::
    #+begin_src js
    export class ClassName {
        propertyName: propertyType = assignment; // a property
        
    }
    #+end_src
  + naming convention ::
    - class name :: feature name + suffix 'Component', eg: class BookManagerComponent, and root class component named: AppComponent
    - camelCase ::
    - methods name :: verbs, describing the action the method performs
  + inside class :: properties + methods
  + 'export' keyword :: to export class and make it available to be referenced outside
- still need to define templates associated with the class to make the whole chunk a working component ::
  + in TS, the metadata ==component== is attached to the class component as a decorator
    
*** Defining metadata with decorators
[2023-12-20 Wed 10:47]
- a class becomes an angular component when given metadata component :: metadata are needed to understand how to:
  + instantiate the component
  + construct the view
  + interact with the component
- we define metadatas for a class by decorating (annotating for people with java background) the class with @Component decorator :: ~@Component({...})~
- decorators :: TS features/functions that add metadata to a class, its members, or its method arguments
  + decorators are prefixed with ~@~
  + scope of decorator :: limited to the feature that it decorates
  + angular integrates several built-in decorators :: eg: ~@Directive, @NgModule, @Injectable~, but most importantly ~@Component~ decorator to identify the class as a component
    #+begin_src javascript
    @Component({ // ClassName class is decorated with @Component for metadata
        ...
        })
    export class ClassName {
        propertyName: propertyType = assignment; // a property
    
    }
    #+end_src
  + decorator functions format :: ~@Adecorator({...})~
    - decorators are functions with argument objects (as seen passed as curly braces)
    - decorator object have properties too: eg:
      + 'selector:' :: to find (select) the html elements needed to style; in angular, represents the root directive for the component
        - convention :: use prefixed value for the selector to reference it as part of the application being implemented (eg: 'pm-root' is the root of the element to be styled, and defined in application for project management ('pm'))
        - can cross reference directives from different components :: and insert templates from some components into others:
          + don't forget to declare the source component in the AppModule declarations :: so that the component can be found in the app globally
          #+begin_src javascript
          // component1.ts
          @Component({
            selector: 'pm-root',
            template: `<div><h1>{{myTitle}}</h1>
                         <pm-products></pm-products> <!-- referencing ProductListComponent's template using its selector: will view as defined in the component -->
                       </div>`
          })
          export class AppComponent {
            title = 'Angular: Getting Started';
          }

          // component2.ts
          @Component({
            selector: 'pm-products',
            templateUrl: './product-list.component.html'
          })
          export class ProductListComponent {
            //...
          }          

          // AppModule.ts
          @NgModule({
            declarations: [
              AppComponent,
              ProductListComponent // <-- HERE
            ],
            imports: [
              BrowserModule
            ],
            bootstrap: [AppComponent]
          })
          export class AppModule { }
          #+end_src
      + linked template 'templateUrl' :: define template (view) file (can directly enter the html code with decorator ==template==)
        - inline template ::
          + one line template with one line (surrounded with quotes, single quotes =='==, or backticks =='==`) :: ~template: '<div><h1>{{myTitle}}</h1></div>'~
          + one line template multipe lines (surrounded with single quotes =='==, or backticks =='==`) ::
      + styleUrls :: for css,
      + etc.
      #+begin_src javascript
      @Component({          
        selector: 'pm-root',
        templateUrl: './app.component.html',
        styleUrls: ['./app.component.css']
      }
      #+end_src
*** Bootstrapping app component
[2023-12-20 Wed 10:47]
- notes ::
  + in angular, the transpiled (to javascript) default page 'index.html' contains script tags referencing the javascript version of the angular application files
    - these transpiled javascript files are then downloaded and processed by the browser (client side) ::
      + angular *modules* help building/transpiling those javascript files ::
        - angular modules :: mechanism to group components, directives, pipes and services that are related, in such a way that can be combined with other modules to create an application
      + eg ::
        - angular version ::
           #+begin_src javascript
           // app.component.ts
           import { Component } from '@angular/core'; // imports

           @Component({ // metadata & template components
             selector: 'pm-root',
             template: '<div><h1>{{myTitle}}</h1></div>'
           })
           export class AppComponent { // class component
             title = 'Angular: Getting Started';
           }

           #+end_src
        - transpiled index.html ::
          #+begin_src html
          <body>
            <!-- angular modules define the html rendering  -->
            <!-- not static, so might not be exactly the same as this result  -->
            <pm-root _nghost-yra-c12="" ng-version="14.3.0">
            <div _ngcontent-yra-c12="" style="text-align: center;">
              <h1 _ngcontent-yra-c12=""> Angular: Getting Started </h1>
              Starter Files
            </div>
            </pm-root>
          </body>
          #+end_src
- hosting the application ::
- defining the angular module

*** Angular Modules
[2023-12-20 Wed 17:15]
- modules ::
  + handy for organization and boundaries from context (provided by the components) :: angular modules help organize applications into cohesive blocks of functionality and provide boundaries within the application
    - for example, when a component contains a directive, angular need to look into the component's module to determine which directives are visible to that component, 
  + template resolution environment :: when angular compiler sees a directive and a template, it looks to the angular module for the definition => a component is declared in an angular module so that compiler can find it
  + root application module 'AppModule' :: mandatory module for all angular application (as other modules, declares application's root components)
  + a module is also used to bootstrap the startup component (AppComponent) ::
  + a component must belong to one and only one module :: 
  + module 'BrowserModule' :: is also added to the module imports so that the application works properly in a browser
  + eg :: the root angular module of the application
    - Angular is defined using a class :: ~export class AppModule { }~
    - decorate the class as an angular module (@NgModule), and pass in the metadatas to define the details of the module :: ~@NgModule({/* metadatas ...*/})~
      + metadata array 'declarations' :: defines which components belong to the module ~declarations: [AppComponent]~
        - convention :: root component 'AppComponent' belongs to root module 'AppModule'
      + metadata array 'imports' :: defines external modules needed to be available to all the components that belong to the module ~imports: [BrowserModule]~
      + metadata array 'bootstrap' :: defines the startup component of the application ~bootstrap: [AppComponent]~
        - startup component should contain the selector used in index.html
          #+begin_src javascript
          import { NgModule } from '@angular/core';
          import { BrowserModule } from '@angular/platform-browser';
          import { AppComponent } from './app.component';

          @NgModule({
            declarations: [
              AppComponent
            ],
            imports: [
              BrowserModule
            ],
            bootstrap: [AppComponent]
          })
          export class AppModule { }
          #+end_src
  + angular components must be declared in a module :: modules are like project's files that reference the components parts of the application
*** Interfaces components, methods, and Nested components
[2023-12-22 Fri 00:59]
**** Notes
- methods :: parameters also have strong typing :: ~func(aVariable: aVariableType): aFuncReturnType {}~
- interfaces :: ~export interface IAnInterface{}~ specifications identifying a related set of properties (data properties associated with a class) and methods (perform the logic required for the class)
  + two primary ways to use interfaces ::
    - to identify the properties for a specific type :: interface declares the properties' types, and then instead of using 'any', we use the interface, eg: ~products: IProduct[] = []~)
    - as a feature set :: declare properties and methods required to implement a specific feature (declarations only, no implementation, and then a class can implement the interface: ~export class MyComponent implements IDeclaresSomeThings~)
**** Nested components
[2023-12-22 Fri 15:54]
- Notes ::
  + handy for implementing complex components, or re-using components
  + benefit of making a component nested :: when its templates manages a fragment of a larger view
  + nested component have selectors :: => it can be used as a directive
  + nested component can even communicate with its container
- communication of nested components :: 
- use 'shared' folder if nested components is to be re-used by other components :: 

*** Component life cycle hooks
[2023-12-22 Fri 09:35]
**** Notes
[2023-12-22 Fri 09:43]
- component life cycle :: created -> rendered -> create and render children -> process changes (continuous operations) -> destroy before removing its template from the DOM

**** Life cycle hooks (OnInit, OnChanges, OnDestroy, etc.)
- life cycle hooks :: interfaces (so need to implement the interfaces first: ~export class AComponent implements OnInit {}~) provided for implementation when a component life cycle occurs
- some life cycle hooks :: (the signatures of methods needed to implement, not the interfaces)
  + ngOnInit :: perform on component initialization
  + ngOnChanges :: perform after change to ==input properties==
  + ngOnDestroy :: perform cleanup
  
*** convention for components
[2023-12-20 Wed 21:52]
- class ::
  + component name ::
    - suffix it with :: 'Component' 
    - PascalCase ::
  + 'export' the component class so that it can be imported :: 
- properties ::
  + appropriate data type and default value ::
  + camelCase :: 
- methods ::
  + camelCase ::
*** Getters and setters
[2023-12-22 Fri 11:25]
- use of private properties :: and access to members through getters and setters
- eg ::
  #+begin_src javascript
  export class AClass {
      private _amount: number = 0;
      get amount(): number {
          return this._amount;
          }
      set amount(value: number): void {
          this._amount = value;
          }
      }
  #+end_src

*** Debugging
[2023-12-20 Wed 10:48]

** Data binding, pipes, Templates, interpolation and directives
[2023-12-19 Tue 14:33]
*** Binding
**** data binding and binding types (interpolation, property binding, event binding, two-ways binding)
- data binding :: passing data and coordinating communication between the component's class and its templates
  + to pass values from class to template and vice-versa, raise events to the class, etc.
  + binding syntax always defined in the templates
  + useful to change element values, style, based on user preferences, catch notifications or events from user actions or other events from the DOM
  + 'template expression' :: just another way of calling data bindings expression in the template, getting binding values from the context (the target components)
- interpolation :: (=={{}}==, double curly brackets) interpolation is replacing the binded variable in curly braces to display values gotten from the context properties (the components)
  + interpolation is a one way binding :: from class to template
  + can go way beyond :: , examples: ~{{'Title: '+ pageTitle}}~: concatenation; ~{{2*20+2}}~: math operation; ~<h1 innerText={{pageTitle}}></h1>~: as value for attributes
- property binding :: (with ==[]==, square brackets)
  + property binding :: eg: ~<img [src]='product.imageUrl'>~, 'img' is the element, '[src]' (in square brackets) is the property of element 'img' , and 'product.imageUrl' is the template expression
  + property binding also one way :: from component to html element property
- property binding vs interpolation ::
  + property binding allows binding to type other than strings :: ~<input type='text' [disabled]='isDisabled'>~, where 'isDisabled' returns a string (whereas interpolation always assign to string)
  + with interpolation :: no quotes, and curly braces for the template expression in place of square brackets : ~<img src={{product.imageUrl}}>~
  + with property binding :: can add more attributes of different types
    - template ::
      #+begin_src javascript
      <tr *ngFor='let product of products'>
          <td><img class='center-block img-responsive' [style.width.px]='imageWidth' [style.margin.px]='imageMargin' [src]='product.imageUrl' [title]='product.productName'></td>
      </tr>
      #+end_src
    - component ::
      #+begin_src javascript
      export interface IProduct {
        pageTitle: string = 'Product List';
        imageWidth: number = 50;
        imageMargin: number = 2;
        products: any[] = [                
            {
              "productId": 1,
              "productName": "Leaf Rake",
              "productCode": "GDN-0011",
              "releaseDate": "March 19, 2021",
              "description": "Leaf rake with 48-inch wooden handle.",
              "price": 19.95,
              "starRating": 3.2,
              "imageUrl": "assets/images/leaf_rake.png"
            },
            {
              "productId": 2,
              "productName": "Garden Cart",
              "productCode": "GDN-0023",
              "releaseDate": "March 18, 2021",
              "description": "15 gallon capacity rolling garden cart",
              "price": 32.99,
              "starRating": 4.2,
              "imageUrl": "assets/images/garden_cart.png"
            }
       ];
      }
      #+end_src
  + property bindings preferred over interpolation :: , but sometimes interpolation more appropriate, eg: ~<img src='https://myimages.org/{{product.imageUrl}}'>~
- event bindings :: (~(click)~, where click is an event)
  + component listens for user's actions and executes component method when event occurs
  + event bindings links an event to a method in a component :: ~<button (click)='toggleImage()'>~: binded method in parentheses and in single quotes, event in parentheses (~(click)~)
    - available events :: https://developer.mozilla.org/en-US/docs/Web/Events
  + by conventions methods are defined after properties definitions (at the bottom of properties)
  + eg ::
    - template ::
      + also made use of conditional if to change button text to change as interpolation value is toggled :: ~{{showImage ? 'Hide' : 'Show'}}~
      + ngIf in this example is bound to value of showImage, and thus to the event handler 'toggleImage' :: 
      #+begin_src xml
      <th>
        <button class='btn btn-primary'
                (click)='toggleImage()'>
          {{showImage ? 'Hide' : 'Show'}} Image <!-- change text as 'showImage' value changes -->
        </button>
      </th>
      <!-- ... -->
      <td>
        <img *ngIf='showImage'
             [src]='product.imageUrl'
             [title]='product.productName'
             [style.width.px]='imageWidth'
             [style.margin.px]='imageMargin'>
      </td>
      #+end_src
    - component ::
      #+begin_src javascript
       @ Component({
          templateUrl: './product-list.component.html',
          styleUrls: ['./product-list.component.css'],
          standalone: true,
          imports: [FormsModule, NgIf, NgFor,
              RouterLink, StarComponent, LowerCasePipe,
              CurrencyPipe, ConvertToSpacesPipe]
      })
      export class ProductListComponent implements OnInit, OnDestroy {
          pageTitle = 'Product List';
          imageWidth = 50;
          imageMargin = 2;
          showImage = false;
          errorMessage = '';
          sub!: Subscription;

          listFilter = signal(''); // Angular signals feature to perform the filter
          filteredProducts = computed(() => this.performFilter(this.listFilter()));
          products: IProduct[] = [];


          toggleImage(): void {
              this.showImage = !this.showImage;
          }

          performFilter(filterBy: string): IProduct[] {
              filterBy = filterBy.toLocaleLowerCase();                    
              return this.products.filter((product: IProduct) => product.productName.toLocaleLowerCase().includes(filterBy));
          }
      }
      #+end_src
- two-way bindings :: (==[()]==, eg: ~[(ngModel)]~): parentheses inside square brackets
  + interactive: listens to changes from the user, and reacts accordingly
  + [()] :: square brackets ==[]== to indicate property binding (component to input element), and parentheses ==()== to indicate event binding (send notification of user input to component property)
    - event handler has to be enclosed in single quotes
  + always remember to make an angular directive visible by the component :: so, ngModel which is a directive from ==FormsModule==, has to be imported in the application module
    - eg ::
      + template ::
        - set a default value for filter field
        #+begin_src xml
        <div class='col-md-4'>
          <input type='text'
                 [(ngModel)] = 'listFilter()' />
        </div>
        <!-- ... -->
        <div class='row' *ngIf='listFilter'>
          <div class='col-md-6'>
            <h4>Filtered by: {{listFilter()}}</h4>
          </div>
        </div>
        #+end_src
      + component ::
        - FormsModule imported
        #+begin_src javascript
        // AppModule
        @NgModule({
            declarations: [AppComponent, ProductListComponent],
            imports: [BrowserModule, FormsModule, NgIf, NgFor /* FormsModule in 'import' and not in 'dec' since external package */]
            bootstrap: [AppComponent]
        })
        export class AppModule {}
        #+end_src

*** Pipes (to transform data before displaying for better rendering)
[2023-12-21 Thu 16:46]
**** Notes
- specified with pipe symbol :: ==|==
- pipe can have parameters :: separated by colons ==:==
  
**** Angular built-in pipes
- built-in pipes :: for dates, number, decimal, percent, currency, json, lowercase, etc.
  + eg :: display product code in lowercase: ~{{product.productCode | lowercase}}~, or using property binding: ~<img [src]='product.imageUrl' [title]='product.productCode | uppercase'>~
  + or using pipe chaining :: ~{{ product.price | currency | lowercase }}~
  + using piping with parameters :: (by defining parameters with a colon and the parameter value) ~{{ product.price | currency:'USD':'symbol':'1.2-2' }~ here the currency pipe has 3 parameters: 1. the desired currency code, 2. string defining how to show the currency symbol (dollar sign instead of currency abbreviation), 3. digits info: minimum number of integer digits (1), minimum number of fractional digits (2), and the maximum number of fractional digits (2) => (at least format X.XX)
  + eg ::
    #+begin_src xml
    <td>{{ product.productCode | lowercase }}</td>
    <td>{{ product.releaseDate }}</td>
    <td>{{ product.price | currency:'USD':'symbol':'1.2-2' }}</td> <!-- formatting for currency and add USD symbol with piping -->
    #+end_src
    
**** Custom pipes
- need @Pipe decorator (import 'Pipe') :: to the class
- has to implement PipeTransform :: => need to implement method 'transform'
- need to catch the property to apply the pipe to :: as first parameter to method transform
- need to give name of custom pipe as argument to decorator :: @Pipe
- if multiple modules are being used, need to declare the pipe in the module that needs the pipe :: (as for all components and pipes anyway)
- location :: pipe are generally shared with multiple components and templates, so better to put them in the ==src/shared== folder
- use :: ~{{ aStringWithDashSeparators | lowercase | convertToSpaces:'-' }}~
- eg :: here generalized to replace any character (given as parameter to the pipe) to a space character (the property to apply the pipe to is caught as first parameter for function 'transform' 'value: string')
  #+begin_src javascript
  import { Pipe, PipeTransform } from "@angular/core";

  @Pipe({
      name: 'convertToSpaces',
      standalone: true
  })
  export class ConvertToSpacesPipe implements PipeTransform {

    transform(pi: string, character: string): string {
      return value.replace(character, ' ');
    }
  }
  #+end_src

*** Directives (custom and angular's)
[2023-12-21 Thu 14:17]
- Notes ::
  + directives :: classes that can add new behavior to the elements in the template or modify existing behavior
  + custom directives :: when using a component as a directive, one uses the component selector as a custom html tag (eg: ~selector: 'pm-products'~)
  + angular directives :: adds logic to html (with loops and if statements for example)
  + angular components :: allow nested user interface fragments  
- angular built-in directives :: eg: ~*ngIf~ for if logics (if assigned expression value is true, then the element is added to the DOM, removed from the DOM otherwise), ~*ngFor~ for for-loops
  + structural directives :: that modify the structure or layout of a view by adding, removing, or manipulating elements and their children
    - prefixed with ~*~
    - ~*ngIf~ and ~*ngFor~ are both structural directives
      #+begin_src xml
      <div class='table' *ngIf='products.length'><!-- only display table if it has content.  -->
      <!-- ... -->
      </div>
      #+end_src
  + need to expose the angular directives (*ngIf, *ngFor, *ngModel, etc.) :: by importing BrowserModule, which is why it needs to be imported in the application module
  + some angular directives ::
    - *ngFor ::
      #+begin_src xml
      <table class='table' *ngIf='products.length'>        
        <thead>
          <tr> <!-- table row -->
            <th> <!-- table header -->
              <button class='btn btn-primary' (click)='toggleImage()'>{{showImage ? 'Hide' : 'Show'}} Image</button>
            </th>
            <th>Product</th>
            <th>Code</th>
            <th>Available</th>
            <th>Price</th>
            <th>5 Star Rating</th>
          </tr>
        </thead>
        <tbody>
          <tr *ngFor='let product of filteredProducts()'>
            <td> <!-- table data -->
              <img *ngIf='showImage' [src]='product.imageUrl' [title]='product.productName' [style.width.px]='imageWidth' [style.margin.px]='imageMargin'>
              </td>
              <td>
                <a [routerLink]="['/products', product.productId]">{{ product.productName }}</a>
              </td>
              <td>{{ product.productCode | lowercase | convertToSpaces:'-' }}</td>
              <td>{{ product.releaseDate }}</td>
              <td>{{ product.price | currency:'USD':'symbol':'1.2-2' }}</td> <!-- formatting for currency and add USD symbol with piping -->
              <td>
                <pm-star [rating]='product.starRating' (ratingClicked)='onRatingClicked($event)'/>
              </td>
            </tr>
        </tbody>
      </table>
      #+end_src
      
** Services and dependency injection
[2023-12-19 Tue 14:34]


** Navigation and routing
[2023-12-19 Tue 14:36]

** Retrieving data using http
[2023-12-19 Tue 14:35]

** Angular cli
[2023-12-19 Tue 14:40]
- used to generate code, execute the application, deploy to production, etc., etc.

* Styling with angular
[2023-12-21 Thu 10:32]
** Notes
- encapsulating styles with component decorator :: ~@Component({styleUrls: ['./product-detail.component.css']})~, or ~@Component({styles: ['thead {color: #337AB7}']})~ (array, so can add multiple styles separated with commas)
  + when encapsulated in component's template, styles won't leak out to other parts of the application
- div class='card' :: to use styles from bootstrap

** Bootstrap
[2023-12-21 Thu 10:41]
- different styling classes (attribute class='') made available by bootstrap :: 'card', 'card-header', 'tables', etc.

* NVM, Node, NPM
[2023-12-19 Tue 15:18]
- what's npm ? :: many things: repository, command line tool, package manager, etc
- what does npm can do ? ::
  + install libraries, packages, dependencies, applications, etc.
  + execute scripts to perform tasks, such as: run JS application
- npm cli :: to interact with repository
** npm scripts
[2023-12-19 Tue 17:18]
- eg from package.json ::
  + if type:
    - ~npm start~, will run ~ng serve -o~;
    - ~npm build~, will run ~ng build~; etc.
    - ~ng~ executes the angular cli on the command given by the string after ng
      + two ways of installing angular 'ng' :: locally, globally. In the former case, running ~ng~ commands on a terminal won't do anything. Angular cli needs to be installed globally to use 'ng' commands in the terminal
      + for example ~serve -o~: builds the application, and starts a local web server that serves up the application without deploying it; ~-o~: option to open the url in the default browser
        #+begin_src js
        {
            // ...
            "scripts": {
                "ng": "ng",
                "start": "ng serve -o",
                "build": "ng build",
                "watch": "ng build --watch --configuration development",
                "test": "ng test"
                },
            "private": true
            // ...
            }
        #+end_src

** Some commands
*** angular cli (~ng~)
[2023-12-20 Wed 10:29]
- ng new anapp --prefix pm :: create new angular app 'anapp' with prefix 'pm' (for 'product manager' in case it's a product management app)

*** npm
[2023-12-19 Tue 15:43]
- install dependencies ::
  + npm install :: (without explicit call to package), install packages defined in package.json
  + npm install abc :: request package abc from npm repository, install it in current folder, subfolder ==node_modules==. ==node_modules== contains the libraries and dependencies of installed packages
  + be aware :: installation warning logs are not all pertinent, if suggests you for example to ~npm audit fix --force~, DON'T!!, the new updated versions might mess up your application
- start angular application :: ~npm start~
- generate ::
  + generate new component :: ~ng generate component a-new-component-name~ (no need to suffix with 'Component')
    - do not create new folder in the process (options: --flat) :: ~ng g component afolder/a-new-component-name --flat~, will add component 
  + generate module :: 
  + generate interface :: ~ng generate interface an-interface~

*** nvm
- nvm ls :: list installed versions
- nvm install --lts :: install latest Node.js LTS release
  + nvm ls-remote :: to list available versions
  + nvm install 8.16.2 :: install specific version of node
  + nvm install node :: install latest release
  + nvm install carbon :: nstall an older LTS release by codename
- nvm use 10.16.3 :: switch node version for the active shell
  + nvm use node :: switch to the latest installed version
  + nvm use --lts :: use the latest LTS version
- nvm alias default 10.0.0 :: change lts alias version to 10.0.0
* Developer tools
[2023-12-20 Wed 21:37]
- f12 is your friend when debugging
- element tab :: to view html
- source tab :: helpful for debugging
  + angular cli uses 'webpack', so the TS files will be listed under the webpack node, and it's possible to debug directly from there and see the result live, but also set breakpoints
- styling tools :: bootstrap, font-awesome
  
* Definitions
[2023-12-19 Tue 12:15]
- bootstrapping :: in tech, means self-starting process that loads and then run
- DOM :: document object model representing an html as a node tree where each node is a part of the html
- node :: Node.js (a JavaScript runtime that allows you to build scalable and efficient web applications)
- npm ::  package manager (node package manager) for the JavaScript programming language (provids access to a vast ecosystem of libraries and tools)
  + online registry/repository of open source libraries and packages
  + contains many JS packages (angular, TS, bootstrap, etc.)
- nvm :: version manager for node.js (allows you to quickly install and use different versions of node via the command line.)
- transpiling :: convert source code from a programming language into an equivalent source code of the same or a different programming language

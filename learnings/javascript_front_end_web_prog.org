# -*- mode: org -*-
#+title: learning Javascript web programming language and tools
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+TAGS: Java


* JavaScript (JS) and TypeScript (JS)
[2023-12-19 Tue 14:42]
- Notes ::
  + the official JS language specification standard is called ES (ECMAScript): ES version defined previously by sequential number (eg: ES3, ES5, etc, supported by older browsers), but from ES6, that was renamed 2015 -and brought many new features such as classes and arrow functions-, new version is released each year
    - => newer JS features have to be transpiled to older JS
  + TS :: open source, superset to JS (every JS code supported by TS), transpiles to plain JS (TS code must be compiled and converted to comparable JS syntax before the browser executes it)
    - dig further :: https://www.typescriptlang.org/
  + 'let' :: to define local variable
  + 'for...of' vs 'for...in' ::
    - for...of :: loops on iterable objects
    - for...in :: loops on properties of an object:
      #+begin_src javascript
      let arr = ['a', 'b', 'c'];
      for (let obj in arr) {
          console.log(obj); // 0, 1, 2. The array indexes are enumerable properties with integer names
          }
      #+end_src
  + private variables prefixed with underscore :: ~private _something: sometype;~
  + arrow function :: compact syntax to define a function, no 'return' keyword ~(param: paramType) => {param.doSomething(); param.doAnotherThing(); }~
  + javascript 'template litterals' :: allow use of a placeholder to insert an expression within a string (using backticks ==``==), eg: ~`The rating ${this.rating} was clicked!`~
  + JS arrays ::
    - filter method :: ~products.filter()~
      + creates new array by filtering content from previous array :: => use two arrays: one for the base array property, and one for its filtered version. Otherwise you might loose the base array when filtering
      + 'filter' method needs true/false logic to compare objects (arrow function)
      #+begin_src javascript
      performFilter(): IProduct {
          return products.filter( ( product: IProduct ) => product.productName.includes( filteringParameter ) );
          }
      #+end_src
    
* Angular
** Notes
- angular :: JS framework for building client-side applications
- benefits :: more expressive html, powerful data-binding (to connect data directly to UI), promotes modularity ("modular by design": app built as a set of blocks (set of components), so that it is easier to create and reuse the contents), built-in support for back-end integration (easier communication with a back-end server)
- installing manually ::
  + nvm :: to select which version of node.js to install  (https://github.com/nvm-sh/nvm#installing-and-updating)
  + npm :: install it with nvm when done: ==nvm install --lts==, to install latest Node.js LTS release
    - check if everything is installed properly ::
      #+begin_src bash
      node -v
      npm -v
      #+end_src
- installation ::
  1. needed ::
     + angular framework and libraries :: 
     + angular cli :: 
     + TS ::
     + testing tools, linters ::
     + and others :: 
  2. for installing dependencies/packages, two options:
     + either use npm commands to install all those manually;
     + or as commonly done, define a ==package.json== file listing each needed packages, and use npm to install defined packages, their dependencies, with all the versions (~npm install~ in folder)
- in package.json, :: the list of packages is divided into two parts:
  + 'dependencies' :: packages required for development AND deployment, eg: primary angular packages, and supporting packages (~rxjs~) : ~@angular/(animations|common|compiler|etc.)~
  + 'devDependencies' :: packages only required for development, eg: ~@angular/(compiler|compiler-cli)~
- some TS types ::
  + any[]: array of any object (eg: ~products: any[];~)
  
** Anatomy of an angular app
[2023-12-19 Tue 14:04]
- angular ::
  + comprised of a set of components, or can also be seen as comprised of a set of services that provide functionality across components. eg of services: accessing data from a back end server, standard logging, exception handling, performing tax calculations, etc.
  + an angular application can be seen as a set of components, the developer arranges those components to form the application
- angular component :: each angular component has a: ==component = UI (template) + code (class (properties, methods)) + extra-data (metadata)==
  + template (UI) :: html defining a view for the application, can be seen as the UI,
  + class (code) :: contains the code associated with a view, the code behind the UI, contains:
    - properties :: or property variables, or data elements, hold the data to display in the UI, available for binding to the view
    - methods :: that perform actions for the view, eg: handle click on button
  + metadata :: provides further infos about the component to angular
*** angular project's folder structure
- uppermost files (at root of project, also called 'boilerplate files') :: configuration and setup files 
- ==src== :: by convention, all source code in 'src'
  + src subfolders ::
    - app :: contains source file specific to the application per se
      + app folder contains subfolders specific to each major feature of the application
- ==node_modules== :: contains the libraries and dependencies of installed packages
  + don't forget to escape it in the version controller, it is too heavy, and anyway we have the package.json to fetch all the required dependencies
    
** Components and modules in Angular
[2023-12-19 Tue 14:32]
*** Notes
[2023-12-20 Wed 10:46]
- component :: ==component = UI (template) + code (class (properties, methods)) + extra-data (metadata)==
  + template :: view layout, created with html, defines what is rendered on the page, includes binding and directives
  + class :: code supporting the view, created with TS, divided into properties (data), and methods (logic behind the view), eg: if wants to define a title in the view, then define a class property 'title' for the title; if wants to show/hide an image in the view, then add logic in class method
    - property :: defines a data element associated with a class (variables for example), format: ~propertyName: dataType = assignement~
  + metadata :: defines extra data for angular component (for eg, it's the metadata that defines a class to be a component class), metadata defined with decorators (function that adds metadata to a class, its members, or its method's arguments)
  + so in the end :: an angular *component is a view defined in a template, its associated code defined with a class, and metadata defined with a decorator*
  + eg :: imports, template, class, metadata
    #+begin_src javascript    
    import { Component } from '@angular/core'; // imports

    @Component({ // metadata & template components
      selector: 'pm-root', // root directive when the component used as a directive, prefixed to reference it as a part of the application (convention)
      templateUrl: './app.component.html', /* specific to view */
      styleUrls: ['./app.component.css']
    })
    export class AppComponent { // class component
      title = 'Angular: Getting Started';
    }
    #+end_src
- data binded variables :: between double curly braces
  + data binding ties template values to class property values
    #+begin_src javascript
    @Component({
      selector: 'pm-root',
      template: '<div><h1>{{myTitle}}</h1></div>' // myTitle is binded to its property value in class AppComponent
    })
    export class AppComponent {
      myTitle: String = 'Toto is Getting Started';
    }
    #+end_src
- imports :: ~import { MemberNameToImport, MemberNameToImport2, MemberNameToImport3 } from 'LibraryOrComponentContainingTheImportedElement';
  + needed in order to use external function/class
  + allow using exported members from :: (need to 'export' the class so that it can be imported)
    - other files in the application
    - angular framework, eg: @Component from angular core, so ~import { Component } from '@angular/core';~
    - external javascript libraries
  + even for installed external packages (locally/globally), still need to import them :: in the component, in the style sheet, etc. eg:
    #+begin_src javascript
    // global css file: src/styles.css
    @import "~bootstrap/dist/css/bootstrap.min.css";
    @import "~font-awesome/css/font-awesome";
    //...
    // to install bootstrap and font-awesome:
    // $> npm install bootstrap font-awesome
    #+end_src
    
*** Creating component classes
[2023-12-20 Wed 10:46]
- structure :: ~'export' 'class' ClassName {}~
  + eg ::
    #+begin_src js
    export class ClassName {
        propertyName: propertyType = assignment; // a property
        
    }
    #+end_src
  + naming convention ::
    - class name :: feature name + suffix 'Component', eg: class BookManagerComponent, and root class component named: AppComponent
    - camelCase ::
    - methods name :: verbs, describing the action the method performs
  + inside class :: properties + methods
  + 'export' keyword :: to export class and make it available to be referenced outside
- still need to define templates associated with the class to make the whole chunk a working component ::
  + in TS, the metadata ==component== is attached to the class component as a decorator
    
*** Defining metadata with decorators
[2023-12-20 Wed 10:47]
- a class becomes an angular component when given metadata component :: metadata are needed to understand how to:
  + instantiate the component
  + construct the view
  + interact with the component
- we define metadatas for a class by decorating (annotating for people with java background) the class with @Component decorator :: ~@Component({...})~
- decorators :: TS features/functions that add metadata to a class, its members, or its method arguments
  + decorators are prefixed with ~@~
  + scope of decorator :: limited to the feature that it decorates
  + angular integrates several built-in decorators :: eg: ~@Directive, @NgModule, @Injectable~, but most importantly ~@Component~ decorator to identify the class as a component
    #+begin_src javascript
    @Component({ // ClassName class is decorated with @Component for metadata
        ...
        })
    export class ClassName {
        propertyName: propertyType = assignment; // a property
    
    }
    #+end_src
  + decorator functions format :: ~@Adecorator({...})~
    - decorators are functions with argument objects (as seen passed as curly braces)
    - decorator object have properties too: eg:
      + 'selector:' :: to find (select) the html elements needed to style; in angular, represents the root directive for the component
        - convention :: use prefixed value for the selector to reference it as part of the application being implemented (eg: 'pm-root' is the root of the element to be styled, and defined in application for project management ('pm'))
        - can cross reference directives from different components :: and insert templates from some components into others:
          + don't forget to declare the source component in the AppModule declarations :: so that the component can be found in the app globally
          #+begin_src javascript
          // component1.ts
          @Component({
            selector: 'pm-root',
            template: `<div><h1>{{myTitle}}</h1>
                         <pm-products></pm-products> <!-- referencing ProductListComponent's template using its selector: will view as defined in the component -->
                       </div>`
          })
          export class AppComponent {
            title = 'Angular: Getting Started';
          }

          // component2.ts
          @Component({
            selector: 'pm-products',
            templateUrl: './product-list.component.html'
          })
          export class ProductListComponent {
            //...
          }          

          // AppModule.ts
          @NgModule({
            declarations: [
              AppComponent,
              ProductListComponent // <-- HERE
            ],
            imports: [
              BrowserModule
            ],
            bootstrap: [AppComponent]
          })
          export class AppModule { }
          #+end_src
      + linked template 'templateUrl' :: define template (view) file (can directly enter the html code with decorator ==template==)
        - inline template ::
          + one line template with one line (surrounded with quotes, single quotes =='==, or backticks =='==`) :: ~template: '<div><h1>{{myTitle}}</h1></div>'~
          + one line template multipe lines (surrounded with single quotes =='==, or backticks =='==`) ::
      + styleUrls :: for css,
      + etc.
      #+begin_src javascript
      @Component({          
        selector: 'pm-root',
        templateUrl: './app.component.html',
        styleUrls: ['./app.component.css']
      }
      #+end_src
*** Bootstrapping app component
[2023-12-20 Wed 10:47]
- notes ::
  + in angular, the transpiled (to javascript) default page 'index.html' contains script tags referencing the javascript version of the angular application files
    - these transpiled javascript files are then downloaded and processed by the browser (client side) ::
      + angular *modules* help building/transpiling those javascript files ::
        - angular modules :: mechanism to group components, directives, pipes and services that are related, in such a way that can be combined with other modules to create an application
      + eg ::
        - angular version ::
           #+begin_src javascript
           // app.component.ts
           import { Component } from '@angular/core'; // imports

           @Component({ // metadata & template components
             selector: 'pm-root',
             template: '<div><h1>{{myTitle}}</h1></div>'
           })
           export class AppComponent { // class component
             title = 'Angular: Getting Started';
           }

           #+end_src
        - transpiled index.html ::
          #+begin_src html
          <body>
            <!-- angular modules define the html rendering  -->
            <!-- not static, so might not be exactly the same as this result  -->
            <pm-root _nghost-yra-c12="" ng-version="14.3.0">
            <div _ngcontent-yra-c12="" style="text-align: center;">
              <h1 _ngcontent-yra-c12=""> Angular: Getting Started </h1>
              Starter Files
            </div>
            </pm-root>
          </body>
          #+end_src
- hosting the application ::
- defining the angular module

*** Angular Modules
[2023-12-20 Wed 17:15]
- modules ::
  + handy for organization and boundaries from context (provided by the components) :: angular modules help organize applications into cohesive blocks of functionality and provide boundaries within the application
    - for example, when a component contains a directive, angular need to look into the component's module to determine which directives are visible to that component, 
  + template resolution environment :: when angular compiler sees a directive and a template, it looks to the angular module for the definition => a component is declared in an angular module so that compiler can find it
  + root application module 'AppModule' :: mandatory module for all angular application (as other modules, declares application's root components)
  + a module is also used to bootstrap the startup component (AppComponent) ::
  + a component must belong to one and only one module :: 
  + module 'BrowserModule' :: is also added to the module imports so that the application works properly in a browser
  + eg :: the root angular module of the application
    - Angular is defined using a class :: ~export class AppModule { }~
    - decorate the class as an angular module (@NgModule), and pass in the metadatas to define the details of the module :: ~@NgModule({/* metadatas ...*/})~
      + metadata array 'declarations' :: defines which components belong to the module ~declarations: [AppComponent]~
        - convention :: root component 'AppComponent' belongs to root module 'AppModule'
      + metadata array 'imports' :: defines external modules needed to be available to all the components that belong to the module ~imports: [BrowserModule]~
      + metadata array 'bootstrap' :: defines the startup component of the application ~bootstrap: [AppComponent]~
        - startup component should contain the selector used in index.html
          #+begin_src javascript
          import { NgModule } from '@angular/core';
          import { BrowserModule } from '@angular/platform-browser';
          import { AppComponent } from './app.component';

          @NgModule({
            declarations: [
              AppComponent
            ],
            imports: [
              BrowserModule
            ],
            bootstrap: [AppComponent]
          })
          export class AppModule { }
          #+end_src
  + angular components must be declared in a module :: modules are like project's files that reference the components parts of the application
*** Interfaces components, methods, and Nested components
[2023-12-22 Fri 00:59]
**** Notes
- methods :: parameters also have strong typing :: ~func(aVariable: aVariableType): aFuncReturnType {}~
- interfaces :: ~export interface IAnInterface{}~ specifications identifying a related set of properties (data properties associated with a class) and methods (perform the logic required for the class)
  + two primary ways to use interfaces ::
    - to identify the properties for a specific type :: interface declares the properties' types, and then instead of using 'any', we use the interface, eg: ~products: IProduct[] = []~)
    - as a feature set :: declare properties and methods required to implement a specific feature (declarations only, no implementation, and then a class can implement the interface: ~export class MyComponent implements IDeclaresSomeThings~)
**** Nested components
[2023-12-22 Fri 15:54]
- Notes ::
  + handy for implementing complex components, or re-using components
  + benefit of making a component nested :: when its templates manages a fragment of a larger view
  + nested component have selectors :: => it can be used as a directive
  + nested component can even communicate with its container
- use 'shared' folder if nested components is to be re-used by other components ::
- communication between nested components and containers :: 
  + from a container to its nested component :: with ==input properties==
    - requires the property in the nested component that receives the data, to be decorate with :: ==@Input()== (function)
    - the container then passes the data using property binding :: eg: in template (html): ~[rating]='product.starRating'~
  + from a nested component to the container :: by emitting ==events binding==
    - if nested wants to send an event to its container :: it must decorate a property using ==@Output()==
    - outputted must be an event :: angular events are defined with an event emitter (~EventEmitter<T>~, package EventEmitter, where T is the type of data that is passed with the event)
    - nested components usually need to communicate with its container, for example to get events or data sent from the container template
- eg of propagating event to container :: nested component event for displaying 5 stars rating in the page title header
  + process ::
    - when user clicks on a star (StarComponent), only the starcomponent templates receives the event
    - with EventEmitter in StarComponent, on click (on a star), the event 'ratingClicked' is emitted (sends a string in this example) to the container's template
    - thanks to event binding (~(ratingClicked)~ in container's template), the method 'onRatingClicked($event)' (of container component, and event accessed via ==$event==) is called, and pageTitle is modified, due to interpolation, to display the rating in the page title header ("Product List: The rating XXX was clicked!")
  + style sheet nested component ::
    #+begin_src css
    .crop {
      overflow: hidden;
    }
    div {
      cursor: pointer;
    }    
    #+end_src
  + template of nested component ::
    #+begin_src html
    <!--  -->
    <div class="crop"
      [style.width.px]="cropWidth" <!-- set to 75 (pixels) to fit the 5 stars, but cropping also allows fractional values: 1.5, 2.5, 4.5, etc. -->
      [title]="rating" <!-- gotten from container component -->
      (click)='onClick()'> <!-- event bindings: on click, emits `The rating ${this.rating} was clicked!` -->
      <div style="width: 75px">
        <span class="fa fa-star"></span>
        <span class="fa fa-star"></span>
        <span class="fa fa-star"></span>
        <span class="fa fa-star"></span>
        <span class="fa fa-star"></span>
      </div>
    </div>  
    #+end_src
  + nested component ::
    #+begin_src javascript
    import { Component, EventEmitter, Input, OnChanges, Output } from "@angular/core";

    @Component({
        selector: 'pm-star',
        templateUrl: './star.component.html',
        styleUrls: ['./star.component.css'],
        standalone: true
    })
    export class StarComponent implements OnChanges {
      @Input() rating = 0; // input properties => expect data coming from container
      cropWidth = 75;
      @Output() ratingClicked: EventEmitter<string> = new EventEmitter<string>(); // output event

      ngOnChanges(): void {
        this.cropWidth = this.rating * 75 / 5; // to fit the 5 stars
      }

      onClick(): void {
        this.ratingClicked.emit(`The rating ${this.rating} was clicked!`);
      }
    }
    #+end_src
  + nesting component (container) ::
    #+begin_src javascript
    import { StarComponent } from "../shared/star.component";

    // ...
    @Component({
        templateUrl: './product-list.component.html',
        styleUrls: ['./product-list.component.css'],
        standalone: true,
        imports: [FormsModule, NgIf, NgFor, 
          RouterLink, StarComponent, LowerCasePipe, // <- starcomponent
          CurrencyPipe, ConvertToSpacesPipe]
    })
    export class ProductListComponent implements OnInit, OnDestroy {
        
        pageTitle = 'Product List';
        imageWidth = 50;
        imageMargin = 2;
        showImage = false;
        errorMessage = '';
        sub!: Subscription;
        
        // Use the new Angular signals feature to perform the filter
        listFilter = signal('');
        filteredProducts = computed(() => this.performFilter(this.listFilter()));
        products: IProduct[] = [];
        
        constructor(private productService: ProductService) {}
        
        performFilter(filterBy: string): IProduct[] {
          filterBy = filterBy.toLocaleLowerCase();
          return this.products.filter((product: IProduct) =>
            product.productName.toLocaleLowerCase().includes(filterBy));
        }
        
        toggleImage(): void {
          this.showImage = !this.showImage;
        }
        
        ngOnInit(): void {
          this.sub = this.productService.getProducts().subscribe({
            next: products => this.products = products,
            error: err => this.errorMessage = err
          });
        }
        
        ngOnDestroy(): void {
          this.sub.unsubscribe();
        }
        
        onFilterChange(value: string) {
          this.listFilter.set(value);
        }
        
        onRatingClicked(message: string): void {
          this.pageTitle = 'Product List: ' + message;
        }
    }
    #+end_src
  + nesting template ::
    #+begin_src html
    <!-- ... -->
    <td>
      <!-- pm-star is the selector for directive component starcomponent -->
      <pm-star [rating]='product.starRating' <!-- starRating is part of the IProduct definition, one of a product field -->
               (ratingClicked)='onRatingClicked($event)'>
      </pm-star>
    </td>
    <!-- ... -->
    #+end_src

*** Component life cycle hooks
[2023-12-22 Fri 09:35]
**** Notes
[2023-12-22 Fri 09:43]
- component life cycle :: created -> rendered -> create and render children -> process changes (continuous operations) -> destroy before removing its template from the DOM

**** Life cycle hooks (OnInit, OnChanges, OnDestroy, etc.)
- life cycle hooks :: interfaces (so need to implement the interfaces first: ~export class AComponent implements OnInit {}~) provided for implementation when a component life cycle occurs
- some life cycle hooks :: (the signatures of methods needed to implement, not the interfaces)
  + ngOnInit :: perform on component initialization
  + ngOnChanges :: perform after change to ==input properties==
  + ngOnDestroy :: perform cleanup
  
*** convention for components
[2023-12-20 Wed 21:52]
- class ::
  + component name ::
    - suffix it with :: 'Component' 
    - PascalCase ::
  + 'export' the component class so that it can be imported :: 
- properties ::
  + appropriate data type and default value ::
  + camelCase :: 
- methods ::
  + camelCase ::
*** Getters and setters
[2023-12-22 Fri 11:25]
- use of private properties :: and access to members through getters and setters
- eg ::
  #+begin_src javascript
  export class AClass {
      private _amount: number = 0;
      get amount(): number {
          return this._amount;
          }
      set amount(value: number): void {
          this._amount = value;
          }
      }
  #+end_src

*** Debugging
[2023-12-20 Wed 10:48]

** Data binding, pipes, Templates, interpolation and directives
[2023-12-19 Tue 14:33]
*** Binding
**** data binding and binding types (interpolation, property binding, event binding, two-ways binding)
- data binding :: passing data and coordinating communication between the component's class and its templates
  + to pass values from class to template and vice-versa, raise events to the class, etc.
  + binding syntax always defined in the templates
  + useful to change element values, style, based on user preferences, catch notifications or events from user actions or other events from the DOM
  + 'template expression' :: just another way of calling data bindings expression in the template, getting binding values from the context (the target components)
- interpolation :: (=={{}}==, double curly brackets) interpolation is replacing the binded variable in curly braces to display values gotten from the context properties (the components)
  + interpolation is a one way binding :: from class to template
  + can go way beyond :: , examples: ~{{'Title: '+ pageTitle}}~: concatenation; ~{{2*20+2}}~: math operation; ~<h1 innerText={{pageTitle}}></h1>~: as value for attributes
- property binding :: (with ==[]==, square brackets)
  + property binding :: eg: ~<img [src]='product.imageUrl'>~, 'img' is the element, '[src]' (in square brackets) is the property of element 'img' , and 'product.imageUrl' is the template expression
  + property binding also one way :: from component to html element property
- property binding vs interpolation ::
  + property binding allows binding to type other than strings :: ~<input type='text' [disabled]='isDisabled'>~, where 'isDisabled' returns a string (whereas interpolation always assign to string)
  + with interpolation :: no quotes, and curly braces for the template expression in place of square brackets : ~<img src={{product.imageUrl}}>~
  + with property binding :: can add more attributes of different types
    - template ::
      #+begin_src javascript
      <tr *ngFor='let product of products'>
          <td><img class='center-block img-responsive' [style.width.px]='imageWidth' [style.margin.px]='imageMargin' [src]='product.imageUrl' [title]='product.productName'></td>
      </tr>
      #+end_src
    - component ::
      #+begin_src javascript
      export interface IProduct {
        pageTitle: string = 'Product List';
        imageWidth: number = 50;
        imageMargin: number = 2;
        products: any[] = [                
            {
              "productId": 1,
              "productName": "Leaf Rake",
              "productCode": "GDN-0011",
              "releaseDate": "March 19, 2021",
              "description": "Leaf rake with 48-inch wooden handle.",
              "price": 19.95,
              "starRating": 3.2,
              "imageUrl": "assets/images/leaf_rake.png"
            },
            {
              "productId": 2,
              "productName": "Garden Cart",
              "productCode": "GDN-0023",
              "releaseDate": "March 18, 2021",
              "description": "15 gallon capacity rolling garden cart",
              "price": 32.99,
              "starRating": 4.2,
              "imageUrl": "assets/images/garden_cart.png"
            }
       ];
      }
      #+end_src
  + property bindings preferred over interpolation :: , but sometimes interpolation more appropriate, eg: ~<img src='https://myimages.org/{{product.imageUrl}}'>~
- event bindings :: (~(click)~, where click is an event)
  + component listens for user's actions and executes component method when event occurs
  + event bindings links an event to a method in a component :: ~<button (click)='toggleImage()'>~: binded method in parentheses and in single quotes, event in parentheses (~(click)~)
    - available events :: https://developer.mozilla.org/en-US/docs/Web/Events
  + by conventions methods are defined after properties definitions (at the bottom of properties)
  + eg ::
    - template ::
      + also made use of conditional if to change button text to change as interpolation value is toggled :: ~{{showImage ? 'Hide' : 'Show'}}~
      + ngIf in this example is bound to value of showImage, and thus to the event handler 'toggleImage' :: 
      #+begin_src xml
      <th>
        <button class='btn btn-primary'
                (click)='toggleImage()'>
          {{showImage ? 'Hide' : 'Show'}} Image <!-- change text as 'showImage' value changes -->
        </button>
      </th>
      <!-- ... -->
      <td>
        <img *ngIf='showImage'
             [src]='product.imageUrl'
             [title]='product.productName'
             [style.width.px]='imageWidth'
             [style.margin.px]='imageMargin'>
      </td>
      #+end_src
    - component ::
      #+begin_src javascript
       @ Component({
          templateUrl: './product-list.component.html',
          styleUrls: ['./product-list.component.css'],
          standalone: true,
          imports: [FormsModule, NgIf, NgFor,
              RouterLink, StarComponent, LowerCasePipe,
              CurrencyPipe, ConvertToSpacesPipe]
      })
      export class ProductListComponent implements OnInit, OnDestroy {
          pageTitle = 'Product List';
          imageWidth = 50;
          imageMargin = 2;
          showImage = false;
          errorMessage = '';
          sub!: Subscription;

          listFilter = signal(''); // Angular signals feature to perform the filter
          filteredProducts = computed(() => this.performFilter(this.listFilter()));
          products: IProduct[] = [];


          toggleImage(): void {
              this.showImage = !this.showImage;
          }

          performFilter(filterBy: string): IProduct[] {
              filterBy = filterBy.toLocaleLowerCase();                    
              return this.products.filter((product: IProduct) => product.productName.toLocaleLowerCase().includes(filterBy));
          }
      }
      #+end_src
- two-way bindings :: (==[()]==, eg: ~[(ngModel)]~): parentheses inside square brackets
  + interactive: listens to changes from the user, and reacts accordingly
  + [()] :: square brackets ==[]== to indicate property binding (component to input element), and parentheses ==()== to indicate event binding (send notification of user input to component property)
    - event handler has to be enclosed in single quotes
  + always remember to make an angular directive visible by the component :: so, ngModel which is a directive from ==FormsModule==, has to be imported in the application module. Same for components in your app so that they can be reached from the other components (in the example below the component ProductListComponent will be available from the other components since was declared within the 'declarations' section of the module)
    - eg ::
      + template ::
        - set a default value for filter field
        #+begin_src xml
        <div class='col-md-4'>
          <input type='text'
                 [(ngModel)] = 'listFilter()' />
        </div>
        <!-- ... -->
        <div class='row' *ngIf='listFilter'>
          <div class='col-md-6'>
            <h4>Filtered by: {{listFilter()}}</h4>
          </div>
        </div>
        #+end_src
      + component ::
        - FormsModule imported
        #+begin_src javascript
        // AppModule
        @NgModule({
            declarations: [AppComponent, ProductListComponent],
            imports: [BrowserModule, FormsModule, NgIf, NgFor /* FormsModule in 'import' and not in 'dec' since external package */]
            bootstrap: [AppComponent]
        })
        export class AppModule {}
        #+end_src

*** Pipes (to transform data before displaying for better rendering)
[2023-12-21 Thu 16:46]
**** Notes
- specified with pipe symbol :: ==|==
- pipe can have parameters :: separated by colons ==:==
  
**** Angular built-in pipes
- built-in pipes :: for dates, number, decimal, percent, currency, json, lowercase, etc.
  + eg :: display product code in lowercase: ~{{product.productCode | lowercase}}~, or using property binding: ~<img [src]='product.imageUrl' [title]='product.productCode | uppercase'>~
  + or using pipe chaining :: ~{{ product.price | currency | lowercase }}~
  + using piping with parameters :: (by defining parameters with a colon and the parameter value) ~{{ product.price | currency:'USD':'symbol':'1.2-2' }~ here the currency pipe has 3 parameters: 1. the desired currency code, 2. string defining how to show the currency symbol (dollar sign instead of currency abbreviation), 3. digits info: minimum number of integer digits (1), minimum number of fractional digits (2), and the maximum number of fractional digits (2) => (at least format X.XX)
  + eg ::
    #+begin_src xml
    <td>{{ product.productCode | lowercase }}</td>
    <td>{{ product.releaseDate }}</td>
    <td>{{ product.price | currency:'USD':'symbol':'1.2-2' }}</td> <!-- formatting for currency and add USD symbol with piping -->
    #+end_src
    
**** Custom pipes
- need @Pipe decorator (import 'Pipe') :: to the class
- has to implement PipeTransform :: => need to implement method 'transform'
- need to catch the property to apply the pipe to :: as first parameter to method transform
- need to give name of custom pipe as argument to decorator :: @Pipe
- if multiple modules are being used, need to declare the pipe in the module that needs the pipe :: (as for all components and pipes anyway)
- location :: pipe are generally shared with multiple components and templates, so better to put them in the ==src/shared== folder
- use :: ~{{ aStringWithDashSeparators | lowercase | convertToSpaces:'-' }}~
- eg :: here generalized to replace any character (given as parameter to the pipe) to a space character (the property to apply the pipe to is caught as first parameter for function 'transform' 'value: string')
  #+begin_src javascript
  import { Pipe, PipeTransform } from "@angular/core";

  @Pipe({
      name: 'convertToSpaces',
      standalone: true
  })
  export class ConvertToSpacesPipe implements PipeTransform {

    transform(pi: string, character: string): string {
      return value.replace(character, ' ');
    }
  }
  #+end_src

*** Directives (custom and angular's)
[2023-12-21 Thu 14:17]
- Notes ::
  + directives :: classes that can add new behavior to the elements in the template or modify existing behavior
  + custom directives :: when using a component as a directive, one uses the component selector as a custom html tag (eg: ~selector: 'pm-products'~)
  + angular directives :: adds logic to html (with loops and if statements for example)
  + angular components :: allow nested user interface fragments  
- angular built-in directives :: eg: ~*ngIf~ for if logics (if assigned expression value is true, then the element is added to the DOM, removed from the DOM otherwise), ~*ngFor~ for for-loops
  + structural directives :: that modify the structure or layout of a view by adding, removing, or manipulating elements and their children
    - prefixed with ~*~
    - ~*ngIf~ and ~*ngFor~ are both structural directives
      #+begin_src xml
      <div class='table' *ngIf='products.length'><!-- only display table if it has content.  -->
      <!-- ... -->
      </div>
      #+end_src
  + need to expose the angular directives (*ngIf, *ngFor, *ngModel, etc.) :: by importing BrowserModule, which is why it needs to be imported in the application module
  + some angular directives ::
    - *ngFor ::
      #+begin_src xml
      <table class='table' *ngIf='products.length'>        
        <thead>
          <tr> <!-- table row -->
            <th> <!-- table header -->
              <button class='btn btn-primary' (click)='toggleImage()'>{{showImage ? 'Hide' : 'Show'}} Image</button>
            </th>
            <th>Product</th>
            <th>Code</th>
            <th>Available</th>
            <th>Price</th>
            <th>5 Star Rating</th>
          </tr>
        </thead>
        <tbody>
          <tr *ngFor='let product of filteredProducts()'>
            <td> <!-- table data -->
              <img *ngIf='showImage' [src]='product.imageUrl' [title]='product.productName' [style.width.px]='imageWidth' [style.margin.px]='imageMargin'>
              </td>
              <td>
                <a [routerLink]="['/products', product.productId]">{{ product.productName }}</a>
              </td>
              <td>{{ product.productCode | lowercase | convertToSpaces:'-' }}</td>
              <td>{{ product.releaseDate }}</td>
              <td>{{ product.price | currency:'USD':'symbol':'1.2-2' }}</td> <!-- formatting for currency and add USD symbol with piping -->
              <td>
                <pm-star [rating]='product.starRating' (ratingClicked)='onRatingClicked($event)'/>
              </td>
            </tr>
        </tbody>
      </table>
      #+end_src
      
** Services and dependency injection (sharing data across components)
[2023-12-19 Tue 14:34]
*** Services
**** Notes
[2023-12-23 Sat 00:05]
- service :: class with a focused purpose. Services usually used for features that:
  + are independent from any particular component
  + provide shared data or logic across components
  + encapsulate external interactions (eg: data access)
- by shifting those responsabilities from components to services :: code is easier to use, debug, and reuse
- things to be careful about ::
  + share the service to all the components that might need it, otherwise might be difficult to reuse, test with mocking, etc.
    - => register the service with angular, angular then creates a single instance of the service class (singleton)
      + recommended way -> angular injectors :: angular provides built-in injector, and the services are registered with the angular injector, which maintain a container of created service instances. The injector then manages the singleton of each registered service
      + the injector is already managing instances of different services, eg: log, math, etc.
- process :: build service -> register service -> inject service
  
**** Build service
- if component needs a service, the component class defines the service as a dependency
- process :: (same steps as building component, modules, and pipes)
  + create service class
  + define the metadata with a decorator (~@Injectable()~)
  + import where needed, and what's needed
- eg ::
  + service component ::
    #+begin_src javascript
    import { Injectable } from "@angular/core"; // using angular core injectors

    @Injectable() // needs to be imported
    export clas ProductService {
        // no properties here, service just used to encapsulate product data access
        // single responsability => providing products list
        getProducts(): IProduct[] {
            // return products list
            }
        }
    #+end_src

**** Register service
[2023-12-23 Sat 00:07]
- angular has root injector, but also injectors for each component mirroring the component tree ::
  + service registered with a root application injector :: is available to all the components (or other service) of the application (registering with root: use @Injectable() metadata ~providedIn~
  + service registered with a specific application injector :: is only available to that component and its child or nested components
- service do not need to be defined in the angular module. Use @Component() metadata ~providers: [NameOfSourceService]~ in the target component decorator @Component
- old way of registering a service :: through the target module usually, use ~providers: [NameOfSourceService]~ in the component decorator
  + recommended :: register in the component (local or global (appcomponent))
- since when service is registered with the root injector this makes it available to the whole application, this is the recommended registration for most scenarios
  + when a service registered in component injector, it provides multiple instances of the service for each instances of the component, eg (from base example with star nested component): when have multiple instances of object star (one for each product), exists a service that tracks each of the product rating (not a common scenario)
- to specify a service as a dependency :: use a constructor and inject the service as an argument to the constructor
- dependency injection in TS :: through the constructor:
  + constructor functions defined with ~constructor(/* ... */)~ method (otherwise default used)
  + for dependency injection an explicit constructor is required (note: heavy constructor can have an impact when several objects need to be initialized, so, use it with moderation)
  + eg ::
    #+begin_src javascript
    @Component({/* ... */})
    export clas ProductListComponent {
        constructor(private productService: ProductService /* service is injected */) {
            // specific feature of TS: can define and assign local member in one go with keyword 'private': ~private productService~ will be a *private* member of the component and will take the value of the argument passed to the constructor
            // feature works with public or protected as well
            }
        }
    #+end_src
- registering a service depends on which injector is used ::
  + registering a service with the root injector :: in the service
    #+begin_src javascript
    @Injectable(
        providedIn: 'root' // root injector service => can then access service from any component or other service in the application
        )
    export clas ProductService {
        getProducts(): IProduct[] {
            return [                
            {
              "productId": 1,
              "productName": "Leaf Rake",
              "productCode": "GDN-0011",
              "releaseDate": "March 19, 2021",
              "description": "Leaf rake with 48-inch wooden handle.",
              "price": 19.95,
              "starRating": 3.2,
              "imageUrl": "assets/images/leaf_rake.png"
            },
            {
              "productId": 2,
              "productName": "Garden Cart",
              "productCode": "GDN-0023",
              "releaseDate": "March 18, 2021",
              "description": "15 gallon capacity rolling garden cart",
              "price": 32.99,
              "starRating": 4.2,
              "imageUrl": "assets/images/garden_cart.png"
            }
            ];
            }
        }
    #+end_src
  + consuming the service ::
    #+begin_src javascript
      // component product-list
    ngOnInit(): void {
      this.products = this.productService.getProducts();
      this.filteredProducts = this.products;
    }
    #+end_src

**** Inject service
[2023-12-23 Sat 00:07]

** Retrieving data using http (and observables)
[2023-12-19 Tue 14:35]
*** Notes
- use of RxJS :: Reactive extensions for javascript, is a library for composing data using observable sequences () and transforming that data using a set of operators
  + angular uses RxJS for working with data, especially asynchronous data (such as http requests)
- http requests are asynchronous :: requests and responses
  + set to be notified when got a response from the request
- observable sequence (or observable stream, or just observable) :: a collection of items over time (arriving over time, regard;ess of )

*** Observables and reactive extensions
[2023-12-26 Tue 09:35]
**** Notes
[2023-12-26 Tue 12:16]
- observables ::
  + do nothing until subscribe
  + when subscribed, sends notifications. 3 types of notifications ""
    1. ~next~ notification :: occurs when the next item is emitted and provides it. eg: each time a key is pressed, an observable can emit a next notification and provides the pressed character
    2. ~error~ notification :: if error occurs, an observable emits an error notification and provides the occurred error information. The observable then completes and no more item is emitted
    3. ~complete~ notification :: when there are no more items to emit, the observable then emits a complete notification
  + process ::
    1. application sends an http method (get for example)
    2. http returns an observable which will emit notifications, so one will know when response arrives
    3. one has then to subscribe to start the observable
    4. request is send, and application continues without waiting for the response
    5. when response is finally received, the observable emits a ~next~ notification and the application processes the response
  + process in an nutshell :: start observable (subscribe and define what to do with received data) -> pipe emitted data if required -> process notification -> stop observable (unsubscribe)
- observables pipelines ::
  + allow to use set of operators to transform each emitted item, eg: pipe through a lowercase operator data that are uppercase
  + observables have over 100 built-in operators to map, combine, filter, etc.
- by convention :: use ==$== at the end to reference an observable, eg: ~source$~
- eg of a simple observable (without http) ::
  #+begin_src javascript
  import { Observable, range, map, filter } from 'rxjs';

  const source$: Observable<number> = range(0, 10); // create an observable with 'range()' that emits numbers from 0 to 10

  source$.pipe( // use pipes to transform the data, 
      map.(x => x * 3),
      filter(x => x % 2 === 0)
      ).subscribe(x => console.log(x));

  #+end_src

**** Http Observables
- Http client Service :: is provided by angular, and serves as a buffer between to send/receive http services that allow communication with a back end server
  + Notes ::
    - context process ::
      1. application sends a get request to the http client service that returns an observable
      2. when subscribed to the observable, the http client service then sends a get request to the web server
      3. response is send from web server to the http client service
      4. which then emits a next notification
    - subscription ::
      + syntax for subscribe :: key-value pair, where key is the function name, and the value is an arrow function, eg: ~....subscribe({nex: products => this.products = products})~: when receiving an observable next notification, will assign the local products list with the one received from the observable
      + subscribe function returns a subscription :: ~const sub = x.subscribe({nextFn, erroFn, completeFn});~
      + convention for notifications handler names :: nextFn (for each value the observable emits), errorFn, completeFn
      + usually, subscription is performed on init of the component that waits to the observable :: insert subscription in the ~@NgOnInit~ part
      + possible to use the getter method to directly subscribe instead of assignment :: ~x.getX().subscribe({...})~
      + use the subscription returned to unsubscribe :: (when needed)
      + use ~NgOnDestroy~ part to unsubscribe
    - recommended way of using http :: encapsulate observables into a service (like ProductService), and expose the observable for use by any component that needs the data: in the following eg, the service is ProductService, and the consumer is ProductListComponent (need to subscribe)
  + tip ::
    - when building an observable, dont forget to inject the angular http client :: ~constructor(private http: HttpClient) {};~
    - always be careful when dealing with asynchronous data
    - bang char ==!== :: tells the compiler that the variable assignment will be handle later (in TS default value is required)
    - if you don't want http client service to use http requests, but instead use local data (json files for examples), one needs to define where to locate the files for angular cli to find them when serving up the application: in the application's root ==angular.json==, node ~projects/apm/architect/build/options/assets~. Can also define those for tests, eg: in node ~projects/apm/architect/test/options/assets~:
      #+begin_src js
      "test": {
          "builder": "@angular-devkit/build-angular:karma",
          "options": {
            "polyfills": [
              "zone.js",
              "zone.js/testing"
            ],
            "tsConfig": "tsconfig.spec.json",
            "assets": [
              "src/favicon.ico",
              "src/assets",
              "src/api" // <--- HERE, folder containing the local data source files
            ],
            "styles": [
              "src/styles.css"
            ],
            "scripts": []
          }
      }
      #+end_src      
  + eg:
    - the subscribed to part ::
      #+begin_src javascript
      import { HttpClient } from '@angular/common/http';
      import { Injectable } from '@angular/core';
      import { Observable, catchError, tap } from 'rxjs'; // to use 'tap' and 'catchError' (see further details in the example)
      import { IProduct } from './product';

      @Injectable(
          providedIn: 'root'
          )
      export clas ProductService {
          private productUrl = 'www.mywebservice.com/api/v1/products'; // <--- HERE, make it point to appropriate web server

          // don't forget to register Httpclient service provider through external module 'HttClientModule' import in the application module (~@NgModule({ imports: [...,HttClientModule,...] ...})~)
          constructor(private http: HttpClient) {};

          getProducts(): Observable<IProduct[]> { // returns an observable that will emit notifications when data received
              return this.http.get<IProduct[]>(this.productUrl).pipe( // piped since retrieved data need to be used:
                  tap(data => console.log('All: ', JSON.stringify(data))), // 'tap': taps into the observable stream and allows looking at the emitted values in the stream without transforming the data -> handy when debugging or logging
                  catchError(this.handleError) // exceptions and error handling
                  );
              }

          private handleError(err: HttpErrorResponse): Observable<never> {
              // in a real world app, we may send the server to some remote logging infrastructure
              // instead of just logging it to the console
              let errorMessage = '';
              if (err.error instanceof ErrorEvent) {
                // A client-side or network error occurred. Handle it accordingly.
                errorMessage = `An error occurred: ${err.error.message}`;
              } else {
                // The backend returned an unsuccessful response code.
                // The response body may contain clues as to what went wrong,
                errorMessage = `Server returned code: ${err.status}, error message is: ${err.message}`;
              }
              console.error(errorMessage);
              return throwError(() => errorMessage);
              }
          }
      #+end_src
    - the app module ::
      #+begin_src javascript
      import { HttpClientModule } from '@angular/common/http';
      // AppModule.ts
      @NgModule({
        declarations: [ /* ...: application internal components */
        ],
        imports: [
          HttpClientModule /* and others needed external modules */
        ],
        bootstrap: [AppComponent]
      })
      export class AppModule { }
      #+end_src
    - the component subscribing to the observable ::
      #+begin_src javascript
      // ProductListComponent
      // ...
      sub!: Subscription; // bang char ==!==, tells the compiler that the variable assignment will be handle later (in TS default value is required)

      ngOnInit(): void {
        // 'subscribe' function returns the subscription
        this.sub = this.productService.getProducts().subscribe({
          next: products => {
              this.products = products;
              this.filteredProducts = this.products;
              },
          error: err => this.errorMessage = err
        });
        // careful!!!: with subscribed to data, they are asynchronous!!!
        // if do the following in that line, this.products might be not set yet after subscription (not available yet)
        // and if binding to other data that are not notified that the observable data are available, here 'this.filteredProducts' will not be set:
        // this.filteredProducts = this.products;
        // possible solution: move ~this.filteredProducts = this.products~ to 'next' part of the subscription: will not set filteredProducts until observable are emited
      }

      ngOnDestroy(): void {
        this.sub.unsubscribe();
      }

      #+end_src

** Navigation and routing
[2023-12-19 Tue 14:36]
*** Notes
[2023-12-26 Tue 17:37]
- routing :: one can define the paths in the application and the user actions required to access each path
- building routing steps ::
  1. configure route for each component
  2. define options/actions
  3. tie a route to each option/action
  4. activate the route base on user action (the activation then displays the component's view)

*** Configuring routes
- routing is component based :: so need to identify the set of needed components as routing targets, and define a route for each one
- angular provides 'RouterModule' ::
  + that registers the router service provider,
  + declares the router directives (eg: RouterLink, RouterOutlet),
  + by importing RouterModule, a component template can use router directives
  + exposes configured routes
    - before one can navigate to a route, one needs to know that route is available to the application :: to do that => pass route to the RouterModule: ~RouterModule.forRoot([])~, and pass the array of routes to the method forRoot. This establishes the routes for the root of the application
- need a start base element tag (in template) :: set to ==/==
- router configured with list of route definitions (each definition specifies a route object, which is a tuple with 'path' property that is mandatory). Some properties ::
  + 'path' :: defines url path segment for the route, can have parameters (separated with /), eg: ~{path: 'products/:id', component: ProductDetailComponent}~, to show the details of product of id 'id'
  + 'component' :: defines component associated to the route (component's template displayed when route is activated)
  + 'redirectTo' :: to redirect to when the path matches, requires pathMatch property to the tell the router how to match the url path segment to the path of a route, eg: ~{path: '', redirectTo: 'welcome', pathMatch: 'full'}~, redirect to routing 'welcome', when default page called (==''==, no routing path and matches empty path)
  + wildcard ::  eg: ~{path: '**', component: PageNotFoundComponent}~: when requested url doesn't match any prior path defined in the configuration
  + order matters in the routing arry :: first-match-wins strategy (use: specific to less specific)

*** Tie routes to actions
[2023-12-26 Tue 17:38]
- in template :: use attribute directive ~[routerLink]~, eg: ~<a [routerLink]="['/welcome']">Home</a>~ for route path ~'welcome'~
  
*** Place the views
[2023-12-26 Tue 17:38]
- use ~<router-outlet></router-outlet>~ to place the views in the host component template
- when a route is activated, its associated component template is displayed in the router-outlet placeholder
  
*** Passing parameters to a route
[2023-12-27 Wed 00:00]
- first element of routerLink is the path route :: and the remaining are the parameters, eg :: ~<a [routerLink]="['/products', product.productId]">{{product.productName}}</a>~
- specified url with parameters must match route configuration path
- to read parameter from the url :: need an ActivatedRoute service provided by the router, and defined as a dependency  eg: ~constructor(private route: ActivatedRoute){}~
- reading parameters from a route ::
  + snapshot :: read parameter one time only ~this.route.snapshot.paramMap.get('id');~
    #+begin_src javascript
    constructor(private route: ActivatedRoute) {
    }

    ngOnInit(): void {
      const id = Number(this.route.snapshot.paramMap.get('id'));
      if (id) {
        this.getProduct(id);
      }
    }
    #+end_src
  + observable :: read parameter as they change (without snapshot method) eg:
    #+begin_src javascript
    this.route.paramMap.subscribe({
              params => console.log(params.get('id'))
            });
    #+end_src
- handling null and undefined ::
  + handling bang assignments (==!==), or undefined values (~product: IProduct | undefined;~) might cause issues, especially with data that can be fetched with a delay such as http response
  + two ways to prevent undefined property issues ::
    1. safe navigation error :: (with ==?==, eg: ~product?.productName~, ~product?.supplier?.companyName~), returns null and doesn't attempt to access the property
       + doesn't work with 2 way bindings
    2. use *ngIf to enclose properties, and the properties won't appear in the DOM
    3. can still use a combination of the two in the same template (some with safe navigation, others with ngIf)
       
*** Activating a route with code (in place of routerlink in the templates)
[2023-12-27 Wed 00:40]
- to route with code :: use router service, eg: ~this.router.navigate(['/products'])~
- need to ::
  + import 'Router' (not router module)
  + inject it
  + eg
    - routing ::
      #+begin_src javascript
      constructor(private route: ActivatedRoute, private router: Router) {
      }

      ngOnInit(): void {
        const id = Number(this.route.snapshot.paramMap.get('id'));
        if (id) {
          this.getProduct(id);
        }
      }

      onBack(): void {
          this.router.navigate(['/products']);
          }
      #+end_src
    - template ::
      #+begin_src html
      <button class='btn btn-outline-secondary'
              style='width:80px'
              (click)='onBack()'>
        <i class='fa fa-chevron-left'></i> Back
      </button>
      #+end_src
      
*** Protecting routes with guards (limiting access to routes)
[2023-12-27 Wed 00:59]
- use to :: limit access to a route, but also require confirmation before navigating away for example (save before leaving)
- guards types ::
  + CanActivate :: guard navigation to a route
  + CanDeactivate :: guard navigation from a route
  + Resolve :: pre-fetch data before activating a route
  + CanLoad :: prevent asynchronous routing
- eg :: prevent product navigation if url provided is not valid
  + guarding component ::
    #+begin_src javascript
    import { Injectable } from '@angular/core';
    import { ActivatedRouteSnapshot, Router, RouterStateSnapshot, UrlTree } from '@angular/router';
    import { Observable } from 'rxjs';

    @Injectable({
      providedIn: 'root'
    })
    export class ProductDetailGuard  implements CanActivate {

      constructor(private router: Router) {}

      canActivate(
        route: ActivatedRouteSnapshot, // ActivatedRouteSnapshot contains the infos about a route at any moment in time
        state: RouterStateSnapshot) 
        : Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree { // can return an observable, a promise, or a boolean
        const id = Number(route.paramMap.get('id'));
        if (isNaN(id) || id < 1) {
          alert('Invalid product id');
          this.router.navigate(['/products']);
          return false; // to cancel activating product details route
        }
        return true;
      }
    }
    #+end_src
  + guarded component ::
    #+begin_src javascript
    import { Routes } from "@angular/router";
    import { ProductListComponent } from "./product-list.component";
    import { ProductDetailComponent } from "./product-detail.component";
    import { ProductDetailGuard } from "./product-detail.guard";

    export const PRODUCT_ROUTES: Routes = [
      { path: '', component: ProductListComponent },
      {
          path: ':id',
          canActivate: [ProductDetailGuard], // array for guards to be checked before path is activated
          component: ProductDetailComponent
      }
    ];
    #+end_src
  + definitions ::
    #+begin_src javascript
    // app.routes.ts
    import { Routes } from '@angular/router';
    import { WelcomeComponent } from './home/welcome.component';

    export const routes: Routes = [
      { path: 'welcome', component: WelcomeComponent },
      { path: '', redirectTo: 'welcome', pathMatch: 'full' },
      {
        path: 'products',
        loadChildren: () => import('./products/product.routes').then(r => r.PRODUCT_ROUTES)
      },
      { 
        path: 'about', 
        loadComponent: () => import('./about/about.component').then(c => c.AboutComponent)
      },
      { path: '**', redirectTo: 'welcome', pathMatch: 'full' },
    ];

    #+end_src

** Angular cli
[2023-12-19 Tue 14:40]
- used to generate code, execute the application, deploy to production, etc., etc.

* Styling with angular
[2023-12-21 Thu 10:32]
** Notes
- encapsulating styles with component decorator :: ~@Component({styleUrls: ['./product-detail.component.css']})~, or ~@Component({styles: ['thead {color: #337AB7}']})~ (array, so can add multiple styles separated with commas)
  + when encapsulated in component's template, styles won't leak out to other parts of the application
- div class='card' :: to use styles from bootstrap

** Bootstrap
[2023-12-21 Thu 10:41]
- different styling classes (attribute class='') made available by bootstrap :: 'card', 'card-header', 'tables', etc.

* NVM, Node, NPM
[2023-12-19 Tue 15:18]
- what's npm ? :: many things: repository, command line tool, package manager, etc
- what does npm can do ? ::
  + install libraries, packages, dependencies, applications, etc.
  + execute scripts to perform tasks, such as: run JS application
- npm cli :: to interact with repository
** npm scripts
[2023-12-19 Tue 17:18]
- eg from package.json ::
  + if type:
    - ~npm start~, will run ~ng serve -o~;
    - ~npm build~, will run ~ng build~; etc.
    - ~ng~ executes the angular cli on the command given by the string after ng
      + two ways of installing angular 'ng' :: locally, globally. In the former case, running ~ng~ commands on a terminal won't do anything. Angular cli needs to be installed globally to use 'ng' commands in the terminal
      + for example ~serve -o~: builds the application, and starts a local web server that serves up the application without deploying it; ~-o~: option to open the url in the default browser
        #+begin_src js
        {
            // ...
            "scripts": {
                "ng": "ng",
                "start": "ng serve -o",
                "build": "ng build",
                "watch": "ng build --watch --configuration development",
                "test": "ng test"
                },
            "private": true
            // ...
            }
        #+end_src

** Some commands
*** angular cli (~ng~)
[2023-12-20 Wed 10:29]
- ng new anapp --prefix pm :: create new angular app 'anapp' with prefix 'pm' (for 'product manager' in case it's a product management app)
- generate :: ~ng g [type_of_file_needed] [component_name] [options]~
  + angular also automatically generates test files :: [component-name].specs.ts
  + generate new component :: ~ng generate component a-new-component-name~ (no need to suffix with 'Component')
    - to not create new folder in the process (options: --flat) :: ~ng g c pathtoneededfolder/a-new-component-name --flat~, will add component without creating a new folder (angular's default)
  + generate module :: 
  + generate router :: 
  + generate interface :: ~ng generate interface an-interface~
  + generate guard :: ~ng g g a-guard~

*** npm
[2023-12-19 Tue 15:43]
- install dependencies ::
  + npm install :: (without explicit call to package), install packages defined in package.json
  + npm install abc :: request package abc from npm repository, install it in current folder, subfolder ==node_modules==. ==node_modules== contains the libraries and dependencies of installed packages
  + be aware :: installation warning logs are not all pertinent, if suggests you for example to ~npm audit fix --force~, DON'T!!, the new updated versions might mess up your application
- start angular application :: ~npm start~

*** nvm
- nvm ls :: list installed versions
- nvm install --lts :: install latest Node.js LTS release
  + nvm ls-remote :: to list available versions
  + nvm install 8.16.2 :: install specific version of node
  + nvm install node :: install latest release
  + nvm install carbon :: nstall an older LTS release by codename
- nvm use 10.16.3 :: switch node version for the active shell
  + nvm use node :: switch to the latest installed version
  + nvm use --lts :: use the latest LTS version
- nvm alias default 10.0.0 :: change lts alias version to 10.0.0
* Developer tools
[2023-12-20 Wed 21:37]
- f12 is your friend when debugging
- element tab :: to view html
- source tab :: helpful for debugging
  + angular cli uses 'webpack', so the TS files will be listed under the webpack node, and it's possible to debug directly from there and see the result live, but also set breakpoints
- styling tools :: bootstrap, font-awesome
  
* Definitions
[2023-12-19 Tue 12:15]
- bootstrapping :: in tech, means self-starting process that loads and then run
- DOM :: document object model representing an html as a node tree where each node is a part of the html
- node :: Node.js (a JavaScript runtime that allows you to build scalable and efficient web applications)
- npm ::  package manager (node package manager) for the JavaScript programming language (provids access to a vast ecosystem of libraries and tools)
  + online registry/repository of open source libraries and packages
  + contains many JS packages (angular, TS, bootstrap, etc.)
- nvm :: version manager for node.js (allows you to quickly install and use different versions of node via the command line.)
- transpiling :: convert source code from a programming language into an equivalent source code of the same or a different programming language

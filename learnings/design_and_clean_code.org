# -*- mode: org -*-
#+title: Software crafting in general, careful though, some topics not available on all programming languages
#+SETUPFILE: ~/set-up-files/basic-setups.org
#+TAGS: Cpp C++ Java Craft


* Conventions
[2023-12-06 Wed 09:39]
** Notes
[2023-12-06 Wed 09:52]
- QAs should also review their own codes for quality
- basically use DRY (don't repeat yourself) : avoid boilerplates (as much as one can)
- avoid abbreviations (not all abbreviations are used everywhere, eg: km not recognized in the us)
- careful with typos and spelling (can affect searching the method with misspelling with the right keyword)
  
** Naming conventions and best practices
*** java
[2023-12-06 Wed 09:45]
- variables ::
  + never a single letter, always be specific, descriptive, and concise, ideally 1-2 words (*words*, not chars), camelCase
  + bool prefixed with "is" (isValid, isActive)
  + constants :: all caps, and with underscores (ALL_CAPS)
- class ::
  + *noun*, *specific* and detailed in order to adhere to SRP solid principle. Even for helper classes, should try to be as specific as possible
  + eg ::
    - class CommonUtils shouldn't contain every helper of the program (countOccurences(String stringToSearch, char charToFind) that works on strings, printNewYorkTime on dates, generateRandomNumberBetween(int low, int high) on ints, etc.). solution 1: rename class to 'StringAndTimeAndNumberUtils' (nooope), solution 2: split helpers into smaller utils: TimeUtils, StringUtils, NumberUtils
  + can refine class name by having a look at the methods it implements: 'Client' is too vague, if it has a method that sends http requests, then it should be renamed to 'WebHttpClient'
  + avoid using catch-all or vague terms (Coordinator, Manager, Runner, etc). Those can be used to name a higher scope tool (eg: ApplicationManager)
    - prefer or narrow down the scope by adding a qualifier: Builder, Writer, Reader, Handler, Container (eg: Filepath)
  + if class implements a design pattern role, manifest it in the name of the class (StringBuilder, CarFactory, etc.)
  + keep the names short though, *don't overdo* it and clutter the code eg (SingletonCarFactoryProxyHandler)
  + tips on fixing bad class names: split class, rename, use 
- methods ::
  + if one needs to look inside the method to know what it does,
  + should reveal intent: do what (verb), to what (noun): eg 1: load (do what) page (to what) => loadPage, 2: set (do what) price (to what) => setPrice, 3: convert (do what) currency (to what) => convertCurrency
    - *attention*, same as classes, avoid too vague terms: data, value, request, calculate, etc., eg:
      - loadData (NOPE) => loadCustomerDetails;
      - setValue (NOPE) => setPrice;
      - sendRequest (NOPE) => sendHttpRequest (or if more details can be found in the class name, just the type of the request then: if class name is WebHttpClient, then can just name the method 'setGet' for get methods requests)
      - preCalculate (NOPE) => convertToLocalCurrency
  + exceptions to the rule ::
    - if specificity and clarity are better than suggested rules, then can apply them, eg of methods not following the rules: endsWith, concat, append, charAt, etc.
    - static factory methods, builder patterns, "fluent interface" patterns, method chaining :: for which focus is more on readability than the rule "verb + noun", eg: stream(), andThen(), orElseThrow(), etc.
      + static factory methods :: eg: Optional.empty(), String.valueOf(1), etc. none of those respect the naming rule (but some those)
  + Anti-patterns (what to avoid) ::
    - method does more than what its name says :: no 'convertCurrency' but also changes the state of an unrelated object, then the name is not correct 
    - no use of: "and", "or", "if" :: checkout single responsibility principle SRP
*** cpp

** Implementing methods and constructors
[2023-12-06 Wed 09:55]
*** java
**** Implementing constructors
[2023-12-06 Wed 17:49]
- static factory methods :: static factory methods encapsulate the construction logic, so they can be a good alternative for constructors replacement
- constructor chaining :: cascading constructors to avoid duplicating codes (go up from smallest constructor, and propagate up until reach the biggest one that will be the one doing the field assignment logic)
    #+begin_src java
    public class A {
    int i, j, k;
    public A() {
        this(0);
    }
    public A(int i) {
        this(i,0);
    }
    public A(int i, int j, int k) {
        this.i = i;
        this.j = j;
        this.k = k;
    }
    }
    #+end_src

  + builder pattern :: 
- constructor telescoping anti-pattern :: drawback of constructor chaining when there are too many fields to assign, and lots of combinations need to have its own constructor
  + possible solution: use a builder pattern, downside:
    #+begin_src java
    // eg: select which ingredients to put in a pizza
    // bad
    Pizza(int size) {/*...*/}
    Pizza(int size, boolean cheese) ...
    Pizza(int size, boolean cheese, boolean ham) ...
    Pizza(int size, boolean cheese, boolean ham, ...) ...

    // better, ugly (boilerplate, embedded classes), but better rendition
    // rendition:
    var pizza = new Pizza.Builder(12)
                              .cheese(true)
                              .ham(false)
                              .build();

    class Pizza {
        static class Builder {
            // mandatory
            private final int size;

            // default is false
            private boolean int size;
            private boolean int size;

            Builder(int size) {
                this.size = size;
                }

            Builder cheese(boolean value) {
                this.cheese = value;
                return this;
                }

            Builder ham(boolean value) {
                this.ham = value;
                return this;
                }
            }
        }


    #+end_src

**** Implementing methods
*** cpp
[2023-12-06 Wed 17:09]

** Class Organization
[2023-12-06 Wed 09:57]

** Handling exceptions
[2023-12-06 Wed 09:56]

** Maintaining clean code
[2023-12-06 Wed 09:58]

* SOLID principles
[2023-12-04 Mon 09:30]
- Notes :: examples are
- SOLID :: design principles 
- dangers of not using SOLID :: (main cause of technical debt)
  + code fragility :: tendency of software to break in many places every time it is changed
  + code rigidity :: tendency of software to be difficult to change even in simple ways: every change causes a cascade of subsequent changes in dependent modules
  + technical debt :: cost of prioritizing fast delivery (which is not time consuming) over code quality (takes longer, but maintainable) for long periods of time
    - loop through continuous improvement to minimize technical debt :: write code (fast delivery) <--> refactor (to reduce technical debt)
- Pyramid of clean code :: (from foundational to advanced): SOLID, design patterns, TDD, continuous refactoring
      
** Single-responsibility principle (SRP)
- SRP :: every function/class/module, have one and only one reason to change (responsabilities examples: logging, a business logic, orchestration, persistence, end users, networking, IO, error handling, etc.)
- pros :: makes code easy to read and understand, fix, maintain; less coupling, more resilient to change; more testable design, thus avoid side effects
- symptoms :: hardly readable, low maintainability and evolution, hard to test, high coupling
- trick on identifying multiple reasons to change ::
  + if else statements :: usually logics into if else statements can be changed into different methods/classes
    - note that not all if/else, switch cases are bad. As long that there is no logic or algorithm with changes apply, they're ok.
    #+begin_src java
    // bad
    public double isSeparationSafe(Aircraft otherAirCraft, Airspace airSpace) { // has lots of reason to change
        var distance = this.calculateDistanceTo(otherAirCraft);
        if (this.altitudeFeet > 2000) { // need for changes when altitude not right
            // check upper altitude rules
            }
        else {
            if (this.inAirSpace(airSpace)) { // need for changes when air space changes
                // check air space rules
                }
            if (this.isRSVMEquipped) { // more changes needed
                // check RSVM reduced rules
                }
            }
        }
    // better: move calculation of safe separation in a separate class or specialized service to handle the rules. Thus, the aircraft will call the service to check if separation is safe, but won't be burdened with internal details on how the calculations are made
    #+end_src
  + switch case statements :: each case represent a logic => can be split into different methods/classes
  + "Monster methods" and "God classes" :: usually have large number of lines of codes, and/or mix levels of abstraction within the implementation. The methods and/or classes are not focused and very specialized, examples:
    #+begin_src java
    // eg 1
    Income getIncome(Employee e) {
        Income income = employeeRepository.getIncome(e.id);
        StateAuthorityApi.sent(income, e.fullName); // doesn't follow SRP, since instead of just fetching the income, it also generates payslips in json and sends them. Lots of dependencies that are not related to getting income
        Payslip payslip = PlayslipGenerator.get(income);
        JsonObject payslipJson = converToJson(payslip);
        EmailService.send(e.email, payslipJson);
        // ...
        return income;
        }

    // eg 2
    class Utils { // prefer more specialized classes instead of one vague: UtilsDB, UtilsConversion, UtilsLoggingn, UtilsSerialize, etc.
        // this example does too much and does not follow the SRP
        void saveToDb(Object o) {/*...*/}
        void convertToJson(Object o) {/*...*/}
        byte[] serialize(Object o) {/*...*/}
        void log(String msg) {/*...*/}
        String toFriendlyDate(LocalDateTime date) {/*...*/}
        int roundDoubleToInt(double a) {/*...*/}
        }

    // eg 3
    Report generate() {
        // suppose method is used by both HR and Management departement, but since all criteria don't apply given the department, in order to avoid changes to apply on both, better to split the method for each department.
        // SRP is just not about the code and the business logic, but also on the actors using the application
        }

    // eg 4: tight coupling
    Income getIncome(Employee e) {
        RepositoryImpl repo = new RepositoryImpl(srv, port, db); // Tight coupling. If for ex the repository constructor changes => code rigidity, but also code fragility since code will break => solution: pass asbtraction of repository as argument to getIncome

        return repo.getIncome(e.id);
        }

    // eg 5:
    // Bad
    public void save(Employee emp) { // 'save' is a persistent method, so should be in appropriate class, eg: EmployeeRepo in persistency package
        // can be reduced to much readable code following SRP

        try {

            // serialization SRP, EmplyeeFileSerializer in persistency package
            StringBuilder buffStr = new StringBuilder();
            buffStr.append("==Employee record==");
            buffStr.append(System.lineSeparator());
            buffStr.append("=NAME=");
            buffStr.append(emp.firstName() + " " + emp.lastName());
            buffStr.append(System.lineSeparator());
            buffStr.append("==POSITION==");
            buffStr.append(emp.getClass().getTypeName());
            buffStr.append(System.lineSeparator());
            buffStr.append("==MONTHLY WAGE==");
            buffStr.append(emp.getMonthlyIncome());
            buffStr.append(System.lineSeparator());

            // File access SRP, 
            Path path = Paths.get(emp.getFullName().replace(" ", "_") + ".rec");
            Files.write(path, sb.toString().getBytes());

            // ...
            // Logging SRP, ConsoleLogger
        } catch (IOException exc) {
            // Logging SRP
        }

    }
    // better
    public void save(Employee emp) throws IOException { // In model class Employee, and stating throw in signature so that the caller catches the exception
        String serializedString = this.serializer.serialize(employee);

        Path path = Paths.get(emp.getFullName().replace(" ", "_") + ".rec");
        Files.write(path, sb.toString().getBytes());

    }
    #+end_src
  + People or roles :: the responsibilities seem related at first sight, but when looked into details, some roles imply different behavior or parameters (usually done by adding if/else/switch). In that case better to duplicate code, sometimes code duplication is exactly what's needed
    #+begin_src java
    // bad
    FlightReport generate() {
        // could be different depending on the role of the actor doing the generation and its rights, eg: HR, Training department, technical staff, etc.
        }
    // better
    FlightReport generateForHR() {
        // ...
        }
    FlightReport generateForTrainingDepartment() {
        // ...
        }
    FlightReport generateForTechnicalStaff() {
        // ...
        }
    #+end_src
  + orchestration :: components responsible for handling coordination and orchestration have a habits of needing too many dependencies, thus resulting in RSP violations
    #+begin_src java
    // bad-ish
    public class FlightPlanScheduler {
        private DatabaseRepo repo;
        private Emailservice emailService;
        private AirportDashboardService airportDashboardService;

        // responsibility should only be to orchestrate the scheduling of a flight plan
        public void scheduleFlightPlan(FlightPlan fp) {
            var availableTimeSlot = this.repo.getFreeTimeSlot();
            if (availableTimeSlot == null) {
                Logger.writeWarning("No free time available");
                return;
            }

            this.repo.assignTimeSlot(fp, availableTimeSlot);

            // can regroup this two responsibilities in a separate responsibility to handle the events that will occur
            this.emailService.notifyPassengers(fp, availableTimeSlot);
            this.airportDashboardService.updateWithPlan(fp, availableTimeSlot);
        }
    // better
    public class FlightPlanScheduler {
        private DatabaseRepo repo;
        private EventHandler eventHandler;

        // By adding an event handler, the method will not change if more parties are involved when a flight plan is scheduled. It will be done by the publishing responsibility
        public void scheduleFlightPlan(FlightPlan fp) {
            var availableTimeSlot = this.repo.getFreeTimeSlot();
            if (availableTimeSlot == null) { // No: this responsibility do not belong here
                Logger.writeWarning("No free time available");
                return;
            }

            this.repo.assignTimeSlot(fp, availableTimeSlot);

            // schedule new flight, and notify all interested parties
            this.eventHandler.publish(new FlightPlanScheduleEvent(fp, availableTimeSlot));
        }
    // EmailService is one component that need to react when a flight plan is scheduled, but there can be others, and they will be able to implement their own ways as many handlers as needed without modifying the code for the flight scheduling
    public class EmailService implements Handler<FlightPlanScheduleEvent> {
        @Override
        public void handle(FlightPlanScheduleEvent eventData) {
            // logic to send mails to pax interested in the flight
            }
        }
    #+end_src
- in good SRP context, the names should be explicit, and the functions and features should be in line with that purpose
- when more than one reasons to change are identified one can ::
  + move responsibilities to separate methods, classes, packages, but the structure has to stay coherent 
  + for more complex processes, can help to use events to limit coupling between components

** Open–closed principle (OCP)
- OCP :: classes/methods/modules should be open for extension (component should be extendable to make it behave in new ways), but closed for modification (each new feature should not modify existing code)
- pros :: easier to add new features and test, minimizes risk of regression bugs, enforces decoupling by isolating changes in specific components (which is good too for SRP)
- OCP implementation strategies :: inheritance (but still exists couplings between base and derived class), and/or design pattern: strategy pattern
  + eg :: context: add feature for international money transfers when national already existed with method tranferMoney of class BankAccount
    - problematic :: international and national transfers are not processed the same way due to: fees, currency rate, etc.
    - solution 1 :: create class InternationalBankAccount that extends BankAccount
    - con of solution 1 :: tight coupling, InternationalBankAccount depends on BankAccount, whereas InternationalBankAccount might have its own specificity that is not shared with BankAccount
    - solution 2, better :: use strategy pattern: create an interface for the feature transferMoney, and make both BankAccount and InternationBankAccount implement it => no coupling between the two, each can compute transferMoney in its own way
- Tips ::
  + start small, improve progressively when needed. When fixing bugs it is safe to make small changes as long as they are covered by tests. When big changes are needed and runtime decisions seems to be needed, consider interfaces and patterns like decorator and strategy
  + the main idea is implement components that can be extended easily
  + bug fixes don't always need applying OCP, so fix them without necessarily applying OCP
  + strategy and decorator design patterns can be a great way to effectively implement OCP
  + eg ::
    #+begin_src java
    // if we want to take into considerations luggage with the following code:
    public class AircraftWeightService {
        private int nbPax;
        private int fuelQuantity;

        public int calculate() {
            final int avgWeightKg = 70;
            return nbPax * avgWeightKg + fuelquantity;
            }
        }
    // solution 1: tempting and easy to modify the class members and the method 'calculate', but that would be bad since that might break other modules of the program
    // solution 2: add new method 'calculateWithLuggage(luggageWeight)' and return the calculation with all the parameters taken into consideration: return nbPax * avgWeightKg + fuelquantity + luggageWeight;
    // better than solution 1 since the class is not really modified, but extended with method not yet used. However, that is still rudimentary and not really efficient
    // solution 3: extend AircraftWeightService
    public class AircraftWithLuggageWeightService extends AircraftWeightService {
        private int luggageWeight;

        @Override
        public int calculate() {
            return super.calculateWithLuggage() + luggageWeight;
            }
        }

    #+end_src
  + if area of code likely to change a lot over time, prefer to start with inheritance, and if strategy pattern could greatly improve the code, then do it. Strategy pattern helps the algorithm behavior to be decided at runtime
    #+begin_src java
    // how to add a new requirement for planes that are flying at more than 3000 meters, it's safer-ish 
    public class SeparationCalculator {
        private Aircraft a1;
        private Aircraft a2;
        private final int minDistanceMeters = 2000;

        public boolean areAircraftTooClose() { // modifying this method is too critical a risk to do, so better to use strategy pattern
            var distance = calculateDistance(a1, a2);
            if (distance < minDistanceMeters) {
                return true;
                }
            return false;
            }
        }
    // new requirement with strategy pattern
    public interface SeparationCalculator {
        boolean areAircraftTooClose();
        }
    public class LowerAltitudeSeparationCalculator implements SeparationCalculator { // uses the standard separation calculator of 2000m
        private Aircraft a1;
        private Aircraft a2;
        private final int lowerMinDistanceMeters = 2000;

        public boolean areAircraftTooClose() {
            var distance = calculateDistance(a1, a2);
            if (distance < lowerMinDistanceMeters) {
                return true;
                }
            return false;
            }
        }
    public class UpperAltitudeSeparationCalculator implements SeparationCalculator { // adds the new requirement
        private Aircraft a1;
        private Aircraft a2;
        private final int upperMinDistanceMeters = 1500;

        public boolean areAircraftTooClose() { // modifying this method is too critical a risk to do, so better to use strategy pattern
            var distance = calculateDistance(a1, a2);
            if (distance < upperMinDistanceMeters) {
                return true;
                }
            return false;
            }
        }
    // the factory that decides which algorithm to use at runtime
    // which is nice since new requirements can be added without breaking the standard use => add new strategy and modify the factory
    public interface SeparationCalculatorFactory {
        private Aircraft a1;
        private Aircraft a2;

        public SeparationCalculator build() {
            if (a1.getAltitude() > 3000 && a2.getAltitude() > 3000) {
                return new UpperAltitudeSeparationCalculator();
                }
            return new LowerAltitudeSeparationCalculator;
            }
        }

    #+end_src
  + when creating APIs, be aware of retro compatibility when changing methods signatures, clients tools/applications might fail otherwise => use OCP and make the API open for extensions, closed for modifications
  + OCP can also allow APIs clients to extend your libraries with their own implementations: declare an abstract interface for an unsuitable class, and the client can implement the class in their own class
    #+begin_src java
    // Library side
    public interface AnOpenForExtensionClass {
        /*...*/
        }

    // Client side
    class TheImplementationOnClientSide implements AnOpenForExtensionClass {
        /*Client business logic*/
        }
    #+end_src
  + best practices when changing APIs ::
    - DON'T change existing public contracts
    - expose abstractions to customer so they can add new features on top of the framework
    - if a breaking change is inevitable, give time for client to prepare :: notify the clients, mark the feature as ==deprecated==, and overload the deprecated method with the new one
      
** Liskov substitution principle (LSP)
- LSP :: any object of a type must be substitutable by objects of a derived type without altering the correctness of the program. Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
- wrong relationship between types can cause lots of issues, so inheritance should not be seen as a relationship of type 'is a' (an ostrich is a bird), but rather as *'is substitutable by'* (is a rectangle substitutable by a square?). In the case of the ostrich it is biologically a bird, but in inheritance context an ostrich cannot bu fully substituted to a bird since it cannot implement the function 'fly' (an ostrich cannot fly)
- detecting LSP violations :: (some symptoms)
  + violating "not substitutable by" relationship :: examples:
    - a rectangle is not substitutable by a square :: unless setWidth and setHeight reset both height and width at the same time, which is not really efficient. So, a rectangle is not substitutable by a square and should not inherit from each other
    - an 2d point is not substitutable by a 3d point :: the distance implemented between two points doesn't yield the same result if the height coordinates is not taken into account
  + violating LSP with partially implemented interfaces :: also possible to violate LSP with interfaces if not paid attention to, if for example some class implements some of the interface methods, but not all (in that case better to break down the interface into smaller pieces)
    #+begin_src java
    // bad
    public interface Aircraft {
        public void land();
        public void takeoff();
        public void brake(int brakingPower);
        }
    // interface ok for a plane, but not ok for helicopter that doesn't really "brake" (no breaking power)
    public class Helicopter implements Aircraft {
        @Override
        public void land() {/*...*/}
        @Override
        public void takeoff() {/*...*/}
        @Override
        public void brake(int brakingPower) {/*...*/} // NOPE!! but have to implement the complete interface => BOUM!!!
        }
    
    // better to break the interface into smaller pieces
    public interface Aircraft {
        public void land();
        public void takeoff();
        }
    // special interface for planes and other that can brake
    public interface Plane extends Aircraft {
        public void break(int brakingPower);
        }
    // now ok
    public class Helicopter implements Aircraft {
        @Override
        public void land() {/*...*/}
        @Override
        public void takeoff() {/*...*/}
        }
    #+end_src
  + violating LSP with type checking :: if not all types can be substituted properly, eg: by filtering out some cases with if/else
- tricks to eliminate LSP violations ::
  + move out incorrect relations between objects
  + for type checking violations, use the "tell don't ask" principle to eliminate type checking and casting
    - "tell don't ask": instead of checking types with if/else (asking), it's better to "tell" by creating a class that extends (inherits) the "normal" class, override the method that comes after the usual case, and move the additional part of the code that is done in the type checking
      #+begin_src java
      // Bad
      for (Task task: tasks) {
          if (task instanceof BugFix) { // type checking and casting, LSP violation
              BugFix bf = (BugFix) task;
              bf.initializeBugDescription();
              }
          task.setInProgress();
          }

      // Better
      class BugFix extends Task {
          @Override
          public void setInProgress() {
              this.initializeBugDescription();
              super.setInProgress();
              }
          }
      // ...
      for (Task task: tasks) {
          // no more type checking
          task.setInProgress();
          }
      #+end_src
        
** Interface segregation principle (ISP)
- ISP :: don't try to force clients to depend on methods that they don't need
- understand "interface" in general :: interfaces, abstract classes, any public method the classes depend upon
- pros :: gives lean and focused interfaces that minimize tight couplings, provides more composable interfaces with more flexibility, and reinforce LSP and SRP
- identigying "fat" interfaces :: too many methods in the interface, methods that throw exceptions (or empty methods) when used because they extend/implement classes/interfaces that are not really needed, interfaces with low cohesion or not granular enough (eg: adding payment related methods in a class 'ShoppingCart')
- tricks ::
  + reduce as much as possible the interfaces size (not number) and break tight couplings by creating interfaces that are lean and focused
  + on external or legacy code where one doesn't have a way to control the code, better to use the design pattern 'Adapter' (basically create a set of classes that will translate the transactions between your interface that is exposed to the client, and the legacy framework)
- eg ::
  #+begin_src java
  // bad
  interface Account {
      double getBalance();
      void processLocalPayment(double amount);
      void processInternationalPayment(double amount); // International payment does need further data that local payment doesn't have
      }
  // better
  interface BaseAccount {
      double getBalance();
      }
  interface LocalMoneyTransferCapability {
      void processLocalPayment(double amount);
      }
  // anytime a user wants to extend or implement the interface his own way, he just can do it
  interface InternationalMoneyTransferCapability {
      void processInternationalPayment(double amount);
      }
  public class SchoolAccount implements BaseAccount, LocalMoneyTransferCapability {
      // ... only the implementation needed
      }
  // can even reuse interface
  public class InternationLoanService implements InternationalMoneyTransferCapability {
      // ...
      public void processInternationalPayment(double amount);
      }
  #+end_src
  
** Dependency inversion principle (DIP)
- DIP :: "Depend upon abstractions, not concretions.": high level modules (features that are mapped to business domain, what the software should do, not how they should do it) should not depend on low level ones (implementation details, how the software should do the tasks: logging, network, data access, UI, IO, etc.), both should depend on abstractions. Abstractions should not depend on details, details should depend on abstractions
- by dictating that both high-level and low-level objects must depend on the same abstraction, DIP inverts the way some people may think about object-oriented programming
- pros :: minimize coupling, the high level should not depend on the low level and vice-versa, otherwise one could find that changing any of the concrete level will induce changes on other levels
- Dependency Injection (DI) :: pattern different than DIP, but often used together. It's a technique that makes a class independent of its dependencies. It allows the creation of dependent objects outside of a class and provides those objects to the class. Note: Using setters not efficient since might leave the object in uninitialized state
  + DI approach ::
    - declare dependencies as abstractions in the constructor
    - have a component that creates and passes them in the constructor
  + Note ::
    - in example above, PaymentProcessor is still dependent of ProductRepoFactory. Dependencies are inevitable, but rather than instantiating within methods and classes, which creates tight coupling, one can pass the dependencies as arguments to constructors and assign them to local members. That reduces the coupling, and makes it easier to use the dependencies outside of the method/class, for example by mocking with tests
  + we've seen above that setters are not the ideal for dependency injection, but there is other solutions ::
    - declaring dependencies in constructor (most used DI) :: eg: ~PaymentProcessor(ProductRepo productRepo)~
      + however, can be tiresome if done manually and have lots of dependencies injections (lots of parameters to pass to a class constructor), of some dependencies need to be singletons => use design pattern "inversion of control"
    - Inversion of control design pattern (IOP) :: takes away the responsibility to create objects manually. IOC is a design principle in which the control of object creation, configuration, and lifecycle is passed to a container or a framework (no 'new'). The process of creating new objects is left to the "IOC container".
      + control of object is "inverted" (as in *inversion* of control) :: it's not the programmer but something else that controls the objects
      + makes sense to use IOC for some objects in the application (service, data access, controllers), *however* for some other entities it should still be left to the coder (entities, values objects, etc.), don't use it for all objects
      + pros of IOC :: easy to switch between different implementations at runtime, increase program modularity, manages objects lifecycle and their configuration
      + some popular IOC containers :: spring, google guice, dagger
- eg ::
  #+begin_src java
  // bad
  class SqlProductRepo { // Low level class
      public Product getById(String productId) {
          // fetch by id
          }
      }
  class PaymentProcessor { // High level class
      public void pay(String productId) {
          SqlProductRepo repo = new SqlProductRepo(); // Low level module, and the High level module 'PaymentProcessor' has a direct dependency with SqlProductRepo (low level module), which violates DIP
          Product product = repo.getById(productId);
          this.processPayment(product);
          }
      }
  // better
  interface ProductRepo {
      Product getById(String productId); // the source of the product is unknown, could be from any data source
      }
  class SqlProductRepo implements ProductRepo { // Low level, and now implements abstraction ProductRepo, eg: MongoProductRepo, ExcelProductRepo, etc.
      @Override // any other source can now override getById
      public Product getById(String productId) {
          // concrete details for fetching a product
          }
      }
  class ProductRepoFactory {
      public static ProductRepo create() { // the return type is an interface, to allow for diverse concrete types to be returned
          return new SqlProductRepo(); // for now, but can implement further objects, and create objects based on runtime parameters, or any other option defined by the developer eg based on an input argument:
          // public static ProductRepo create(String type) {
          //     if (type.equals("mongo")) {
          //         return new MongoProductRepo();
          //         }
          //     return new SqlProductRepo();
          //     }
          }
      }
  class PaymentProcessor { // High level class
      ProductRepo repo; // abstraction
      public PaymentProcessor(ProductRepo repo) { // abstraction passed as argument (DI)
          this.repo = repo;// we get an abstraction ProductRepo interface that is created from a factory (generates a concrete MongoProductRepo, ExcelProductRepo, etc.), and that does not directly depend on concrete implementation of ProductRepo
          // easy to test too by passing a mocked repo object 
          }
      public void pay(String productId) {
          Product product = repo.getById(productId);
          this.processPayment(product);
          }
      }
  // outside of the class, create repo and pass it as argument
  // var repo = new ProductRepoFactory.create();
  // var payProcessor = new PaymentProcessor(repo);
  // payProcessor.pay(employeeToto.getById);
  #+end_src
        
* Design patterns
** Creational patterns :: all about class instantiation
- Notes ::
  + deals with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation
  + often, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed.
- can be further divided into two parts ::
  + class-creation patterns :: use inheritance effectively in the instantiation process
  + object-creation patterns :: use delegation effectively to get the job done
- main :: builder, factory, factory method, abstract factory, prototype, singleton
- builder :: separates object construction from its representation
  + pattern allows a client object to construct a complex object by specifying only its type and content, not its details
  + separates object construction from its representation
  + this way the construction process can be used to create different representations.
  + eg ::
    - Pizza: Object we want to build
    - PizzaBuilder: HawaiianPizzaBuilder, SpicyPizzaBuilder, with unique_ptr<Pizza> m_pizza;
      + // hawaiianpizzabuilder and spicypizzabuilder inherits of Pizzabuilder
      + // they are also associated to Pizza since in Pizzabuilder from which they inherit they contain the object Pizza
    - Cook (also called Director): PizzaBuilder* m_pizzaBuilder; // calls the builder
    - Client: Use cook to create and open pizza :: HawaiianPizzaBuilder hawaiianPizzaBuilder; cook.createPizza(&hawaiianPizzaBuilder); etc.
- abstract factory :: creates instance of several families of classes
  + provides an interface for creating families of related or dependent objects without specifying their concrete classes.
  + provides hierarchy that encapsulates: many possible "platforms", and the construction of a suite of "products".
  + 'new' operator considered harmful.
  + Abstract Factory classes are often implemented with Factory Methods, but they can be implemented using Prototype.
- factory :: creates an instance of a class from a family of derived classes.
  + problem :: once added new concrete product call, should also modify the Factory class. Not very flexible and violates open-close principle.
- factory method :: defines interface for creating an object, but leaves choice of its type to the subclasses, creation being deferred at run-time.
  + use of 'static' and avoiding 'new' => object re-use
  + it refers to the newly created object through a common interface.
  + similar to Abstract Factory but without the emphasis on families.
  + Factory Method: creation through inheritance. Prototype: creation through delegation.
- object pool :: avoid expensive acquisition and release of resources by recycling objects that are no longer in use
  + used to manage the object caching.
  + good option when cost of initializing class instance high, rate of instantiation of class is high, and number of instantiations in use at any one time is low
- prototype :: fully initialized instance to be copied or cloned
  + specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.
  + 'new' operator considered harmful
  + whereas factory methods are created through inheritance, prototypes are created through delegation
  + prototype doesn't require subclassing, but does require "initialize" operation. Factory Method requires subclassing, but doesn't require Initialize
  + designs that make heavy use of Composite and Decorator patterns often can benefit from Prototype
  + prototype co-opts one instance of a class for use as a breeder of all future instances
  + prototypes are useful when object initialization is expensive, and one anticipates few variations on the initialization parameters. In this context, Prototype can avoid expensive "creation from scratch", and support cheap cloning of a pre-initialized prototype
  + prototype is unique among others creational patterns in that it doesn't require a class – only an object.
- singleton :: class of which only a single instance can exist, global scope
  + declare instance as private static data member
  + provide a public static member function that encapsulates all initialization code, and provides access to the instance
  + should be considered only if all three criteria are satisfied ::
    - ownership of the single instance cannot be reasonably assigned
    - lazy initialization is desirable
    - global access is not otherwise provided for
  + deleting a Singleton class/instance is a non-trivial design problem
    
** Structural patterns
- Note :: design Patterns that ease the design by identifying a simple way to realize relationships between entities
- main :: adapter, bridge, composite, decorator, facade, flyweight, proxy, CRTP
- adapter :: match interfaces of different classes
  + can be implemented either with inheritance or with aggregation
  + adapter makes things work after they're designed; Bridge makes them work before they are.
  + adapter provides a different interface to its subject, proxy provides the same interface, decorator provides an enhanced interface
  + adapter is meant to change the interface of an existing object. Decorator enhances another object without changing its interface
  + facade defines a new interface, whereas adapter reuses an old interface
  + // in my opinion :: VERY UGLY, workaround to avoid refactoring (but refactoring VERY HEAVY though...)
- bridge :: separates an object's interface from its implementation
  + 
- composite :: tree structure of simple and composite objects
- decorator :: add responsibilities to objects dynamically
- facade :: single class that represents an entire subsystem
- flyweight :: fine-grained instance used for efficient sharing
- private Class Data :: restricts accessor/mutator access
- proxy :: object representing another object
  
** Behavioral patterns
- Note :: design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication
- observer :: way of notifying change to a number of classes
- chain of responsibility :: way of passing a request between a chain of objects
- interpreter :: way to include language elements in a program
- strategy :: encapsulates an algorithm inside a class or interface, enables the methods/classes behavior to be decided at runtime
- state :: alter object's behavior when its state changes
- visitor :: defines new operation to a class without change
- iterator :: sequentially access the elements of a collection
- command :: encapsulate command request as an object
- mediator :: defines simplified communication between classes
- memento :: capture and restore an object's internal state
- null Object :: designed to act as a default value of an object
- template method :: defer exact steps of an algorithm to a subclass

* Definitions
[2023-12-04 Mon 09:50]
- API :: contract/agreement between different software components on how they should work together
- Abstraction :: things not concrete, can't use 'new', but rather abstract classes or interfaces
- Component :: basic software unit: method, class, package, etc.
- Coupling :: level of inter-dependency between the various software components
- "Chaining" ::
  + constructor chaining :: cascading constructors
  + method chaining :: syntax for invoking multiple method calls, where each method returns an object, allowing the calls to be chained together in a single statement without requiring variables to store the intermediate results
    #+begin_src java
    somethings
        .filter(x => x.count > 10)
        .sort((a, b) => a.count - b.count)
        .map(x => x.name)
    #+end_src
- Refactoring :: systematic process of improving code without creating new functionality that can transform a mess into clean code and simple design (solid principles, design patterns, decouple components, tests, etc.)
- Static Factory Methods ::
- fluent interface patterns :: 
  
* Acronyms
- RAII :: Resource Acquisition Is Initialization
- CRTP :: Curiously Recurring Template Pattern
- SFINAE :: Substitution failure is not an error
